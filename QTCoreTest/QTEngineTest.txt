//@version=6
indicator("QTEngine Test", overlay=true, max_lines_count=500, max_labels_count=500)

import Jaw1312/QTEngine/1 as qt

// -----------------------------------------------------------------------------
// Inputs
// Nano Cycle — 4 quarters × 5 minutes 37.5 seconds each (22.5m total)
// -----------------------------------------------------------------------------
groupVis = "Drawings"
showNano = input.bool(true, "Draw Nano quarter dividers (22m30s cycle; q=5m37.5s)", group=groupVis)
keepCycles = input.int(50, "Cycles to display (Nano)", minval=1, maxval=200, group=groupVis)

groupOp = "Open Lines"
showOpens = input.bool(true, "Draw quarter open lines (Q1–Q4) to cycle end", group=groupOp)

q1OpenCol = input.color(color.rgb(255, 152, 0), "Q1 Open color", group=groupOp)
q2OpenCol = input.color(color.rgb(0, 0, 0), "Q2 Open / True Open color", group=groupOp)
q3OpenCol = input.color(color.rgb(76, 175, 80), "Q3 Open color", group=groupOp)
q4OpenCol = input.color(color.rgb(41, 98, 255), "Q4 Open color", group=groupOp)

q1OpenStyleStr = input.string("Solid", "Q1 Open style", options=["Solid", "Dashed", "Dotted"], group=groupOp)
q2OpenStyleStr = input.string("Solid", "Q2 Open / True Open style", options=["Solid", "Dashed", "Dotted"], group=groupOp)
q3OpenStyleStr = input.string("Solid", "Q3 Open style", options=["Solid", "Dashed", "Dotted"], group=groupOp)
q4OpenStyleStr = input.string("Solid", "Q4 Open style", options=["Solid", "Dashed", "Dotted"], group=groupOp)

groupDW     = "Data Window"
dwNanoStep1 = input.bool(true, "Step 1 — Nano boundaryTs checks", group=groupDW)
dwNanoStep2 = input.bool(true, "Step 2 — Nano QuarterRecord (q1–q4) — minimal", group=groupDW)

// -----------------------------------------------------------------------------
// Color palette (Old QT Indicator) + divider opacity rule
// -----------------------------------------------------------------------------
var color COL_Q1 = color.rgb(99, 99, 99)      // #636363
var color COL_Q2 = color.rgb(242, 54, 69)     // #f23645
var color COL_Q3 = color.rgb(76, 175, 80)     // #4caf50
var color COL_Q4 = color.rgb(41, 98, 255)     // #2962ff

var int V_TRANSP = 70
f_vcol(color c) =>
    color.new(c, V_TRANSP)

// -----------------------------------------------------------------------------
// Helpers (display-only)
// -----------------------------------------------------------------------------
f_hhmmss(int ts, string tz) =>
    int hh = hour(ts, tz)
    int mm = minute(ts, tz)
    int ss = second(ts, tz)
    float(hh * 10000 + mm * 100 + ss)

// QTIndicator mapping (string → TradingView style)
lineStyleFrom(string s) =>
    switch s
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        =>          line.style_dotted

f_clamp_int(int v, int lo, int hi) =>
    v < lo ? lo : v > hi ? hi : v

// -----------------------------------------------------------------------------
// Array helpers
// -----------------------------------------------------------------------------
f_find_int(int[] arr, int v) =>
    int idx = -1
    int i = array.size(arr) - 1
    while i >= 0 and idx == -1
        if array.get(arr, i) == v
            idx := i
        i -= 1
    idx

f_push_unique_int(int[] arr, int v, int maxN) =>
    if f_find_int(arr, v) == -1
        array.push(arr, v)
        while array.size(arr) > maxN
            array.shift(arr)
    0

// -----------------------------------------------------------------------------
// Old-QT vertical divider line storage helpers
// -----------------------------------------------------------------------------
type vset
    line[] ln
    int[]  ts

vset_new() =>
    vset.new(array.new_line(), array.new_int())

vset_clear(vset s) =>
    int i = array.size(s.ln) - 1
    while i >= 0
        line.delete(array.get(s.ln, i))
        i -= 1
    array.clear(s.ln)
    array.clear(s.ts)
    0

vset_has(vset s, int ts) =>
    bool found = false
    int i = array.size(s.ts) - 1
    while i >= 0 and not found
        found := array.get(s.ts, i) == ts
        i -= 1
    found

vset_add(vset s, int ts, color c) =>
    if not vset_has(s, ts)
        array.push(s.ln, line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c)))
        array.push(s.ts, ts)
    0

vset_trim_since(vset s, int cutoffTs) =>
    int i = array.size(s.ts) - 1
    while i >= 0
        int t = array.get(s.ts, i)
        if t < cutoffTs
            line ln = array.remove(s.ln, i)
            line.delete(ln)
            array.remove(s.ts, i)
        i -= 1
    0

f_set_or_make_vline(line ln, int ts, color c) =>
    line out = ln
    if na(out)
        out := line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c))
    else
        line.set_xy1(out, ts, low)
        line.set_xy2(out, ts, high)
        line.set_style(out, line.style_solid)
        line.set_width(out, 1)
        line.set_color(out, f_vcol(c))
    out

f_set_or_make_hline(line ln, int x1, int x2, float y, color c, sty) =>
    line out = ln
    if na(out)
        out := line.new(x1, y, x2, y, xloc=xloc.bar_time, extend=extend.none, style=sty, width=1, color=c)
    else
        line.set_xy1(out, x1, y)
        line.set_xy2(out, x2, y)
        line.set_extend(out, extend.none)
        line.set_style(out, sty)
        line.set_width(out, 1)
        line.set_color(out, c)
    out

f_kill(line ln) =>
    line out = na
    if not na(ln)
        line.delete(ln)
    out

// -----------------------------------------------------------------------------
// QT Core update (Nano only)
// -----------------------------------------------------------------------------
var qt.QTConfig   cfg = qt.qt_config_default()
var qt.CycleState st  = qt.qt_state_new()

int t  = time
int tc = time_close

[st2, n] = qt.qt_nano_update(st, cfg, t, tc)
st := st2

// -----------------------------------------------------------------------------
// Data Window — Step 1: boundaryTs checks
// -----------------------------------------------------------------------------
plot(dwNanoStep1 ? n.q1Ts : na, "Nano q1Ts", display=display.data_window)
plot(dwNanoStep1 ? n.q2Ts : na, "Nano q2Ts", display=display.data_window)
plot(dwNanoStep1 ? n.q3Ts : na, "Nano q3Ts", display=display.data_window)
plot(dwNanoStep1 ? n.q4Ts : na, "Nano q4Ts", display=display.data_window)
plot(dwNanoStep1 ? (n.q2Realized ? 1.0 : 0.0) : na, "Nano q2Realized", display=display.data_window)
plot(dwNanoStep1 ? (n.q3Realized ? 1.0 : 0.0) : na, "Nano q3Realized", display=display.data_window)
plot(dwNanoStep1 ? (n.q4Realized ? 1.0 : 0.0) : na, "Nano q4Realized", display=display.data_window)

// -----------------------------------------------------------------------------
// Data Window — Step 2: QuarterRecord (minimal)
// -----------------------------------------------------------------------------
float n_q1_o_hhmmss = f_hhmmss(n.q1.oTs, cfg.tz)
float n_q2_o_hhmmss = f_hhmmss(n.q2.oTs, cfg.tz)
float n_q3_o_hhmmss = f_hhmmss(n.q3.oTs, cfg.tz)
float n_q4_o_hhmmss = f_hhmmss(n.q4.oTs, cfg.tz)

plot(dwNanoStep2 ? n.q1.o : na, "Nano QR q1.o", display=display.data_window)
plot(dwNanoStep2 ? n.q1.h : na, "Nano QR q1.h", display=display.data_window)
plot(dwNanoStep2 ? n.q1.l : na, "Nano QR q1.l", display=display.data_window)
plot(dwNanoStep2 ? n.q1.c : na, "Nano QR q1.c", display=display.data_window)
plot(dwNanoStep2 ? n_q1_o_hhmmss : na, "Nano QR q1.oTs (HHMMSS)", display=display.data_window)

plot(dwNanoStep2 ? n.q2.o : na, "Nano QR q2.o", display=display.data_window)
plot(dwNanoStep2 ? n.q2.h : na, "Nano QR q2.h", display=display.data_window)
plot(dwNanoStep2 ? n.q2.l : na, "Nano QR q2.l", display=display.data_window)
plot(dwNanoStep2 ? n.q2.c : na, "Nano QR q2.c", display=display.data_window)
plot(dwNanoStep2 ? n_q2_o_hhmmss : na, "Nano QR q2.oTs (HHMMSS)", display=display.data_window)

plot(dwNanoStep2 ? n.q3.o : na, "Nano QR q3.o", display=display.data_window)
plot(dwNanoStep2 ? n.q3.h : na, "Nano QR q3.h", display=display.data_window)
plot(dwNanoStep2 ? n.q3.l : na, "Nano QR q3.l", display=display.data_window)
plot(dwNanoStep2 ? n.q3.c : na, "Nano QR q3.c", display=display.data_window)
plot(dwNanoStep2 ? n_q3_o_hhmmss : na, "Nano QR q3.oTs (HHMMSS)", display=display.data_window)

plot(dwNanoStep2 ? n.q4.o : na, "Nano QR q4.o", display=display.data_window)
plot(dwNanoStep2 ? n.q4.h : na, "Nano QR q4.h", display=display.data_window)
plot(dwNanoStep2 ? n.q4.l : na, "Nano QR q4.l", display=display.data_window)
plot(dwNanoStep2 ? n.q4.c : na, "Nano QR q4.c", display=display.data_window)
plot(dwNanoStep2 ? n_q4_o_hhmmss : na, "Nano QR q4.oTs (HHMMSS)", display=display.data_window)

// -----------------------------------------------------------------------------
// Divider + cycle-window management (QTIndicator model)
// -----------------------------------------------------------------------------
var int MAX_LINES = 500
var int STORE_MAX = 800

var int[] nanoStarts = array.new_int()
var vset  nanoV = vset_new()

var line projQ2  = na
var line projQ3  = na
var line projQ4  = na
var line projEnd = na

// -----------------------------------------------------------------------------
// Open-line history (per displayed cycle) — values captured from QTCore during
// the cycle, then retained + drawn as long as the cycle is inside keepCycles.
// -----------------------------------------------------------------------------
var int[]   histStart = array.new_int()
var int[]   histEnd   = array.new_int()

var float[] h_q1o     = array.new_float()
var int[]   h_q1oTs   = array.new_int()
var float[] h_q2o     = array.new_float()
var int[]   h_q2oTs   = array.new_int()
var float[] h_q3o     = array.new_float()
var int[]   h_q3oTs   = array.new_int()
var float[] h_q4o     = array.new_float()
var int[]   h_q4oTs   = array.new_int()

var line[]  l_q1o     = array.new_line()
var line[]  l_q2o     = array.new_line()
var line[]  l_q3o     = array.new_line()
var line[]  l_q4o     = array.new_line()

f_hist_kill_at(int idx) =>
    line a = array.get(l_q1o, idx)
    line b = array.get(l_q2o, idx)
    line c = array.get(l_q3o, idx)
    line d = array.get(l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(d)
        line.delete(d)
    array.set(l_q1o, idx, na)
    array.set(l_q2o, idx, na)
    array.set(l_q3o, idx, na)
    array.set(l_q4o, idx, na)
    0

f_hist_shift_front() =>
    if array.size(histStart) > 0
        f_hist_kill_at(0)
        array.shift(histStart)
        array.shift(histEnd)

        array.shift(h_q1o),  array.shift(h_q1oTs)
        array.shift(h_q2o),  array.shift(h_q2oTs)
        array.shift(h_q3o),  array.shift(h_q3oTs)
        array.shift(h_q4o),  array.shift(h_q4oTs)

        array.shift(l_q1o)
        array.shift(l_q2o)
        array.shift(l_q3o)
        array.shift(l_q4o)
    0

f_hist_trim_cutoff(int cutoffTs) =>
    while array.size(histStart) > 0 and array.get(histStart, 0) < cutoffTs
        f_hist_shift_front()
    0

f_hist_ensure_current() =>
    if n.inWindow and not na(n.q1Ts)
        int key = n.q1Ts
        int idx = f_find_int(histStart, key)
        if idx == -1
            array.push(histStart, key)
            array.push(histEnd, n.endTs)

            array.push(h_q1o, na), array.push(h_q1oTs, na)
            array.push(h_q2o, na), array.push(h_q2oTs, na)
            array.push(h_q3o, na), array.push(h_q3oTs, na)
            array.push(h_q4o, na), array.push(h_q4oTs, na)

            line naL = na
            array.push(l_q1o, naL)
            array.push(l_q2o, naL)
            array.push(l_q3o, naL)
            array.push(l_q4o, naL)
            idx := array.size(histStart) - 1

        // Update current cycle snapshot from QTCore values
        // IMPORTANT: For sub-TF-aligned opens (e.g., Nano forced to 5S), always anchor open-lines to q?.oTs.
        // Do NOT fall back to boundaryTs (q?Ts), or the line will be shifted on higher chart TFs.
        array.set(histEnd, idx, n.endTs)

        float q1o = n.q1.o
        int   q1t = n.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(h_q1o, idx, q1o)
            array.set(h_q1oTs, idx, q1t)

        float q2o = n.q2.o
        int   q2t = n.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(h_q2o, idx, q2o)
            array.set(h_q2oTs, idx, q2t)

        float q3o = n.q3.o
        int   q3t = n.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(h_q3o, idx, q3o)
            array.set(h_q3oTs, idx, q3t)

        float q4o = n.q4.o
        int   q4t = n.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(h_q4o, idx, q4o)
            array.set(h_q4oTs, idx, q4t)

        // Hard cap history storage (delete oldest if exceeded)
        while array.size(histStart) > STORE_MAX
            f_hist_shift_front()
    0

// -----------------------------------------------------------------------------
// Main draw logic
// -----------------------------------------------------------------------------
if not showNano
    // Clear everything
    vset_clear(nanoV)
    projQ2  := f_kill(projQ2)
    projQ3  := f_kill(projQ3)
    projQ4  := f_kill(projQ4)
    projEnd := f_kill(projEnd)

    // Kill open lines + clear history arrays
    int i = array.size(histStart) - 1
    while i >= 0
        f_hist_kill_at(i)
        i -= 1
    array.clear(histStart), array.clear(histEnd)
    array.clear(h_q1o), array.clear(h_q1oTs)
    array.clear(h_q2o), array.clear(h_q2oTs)
    array.clear(h_q3o), array.clear(h_q3oTs)
    array.clear(h_q4o), array.clear(h_q4oTs)
    array.clear(l_q1o), array.clear(l_q2o), array.clear(l_q3o), array.clear(l_q4o)

    array.clear(nanoStarts)
else
    // Projections (future boundaries only; killed once passed)
    if not na(n.q2Ts)
        projQ2 := tc > n.q2Ts ? f_kill(projQ2) : f_set_or_make_vline(projQ2, n.q2Ts, COL_Q2)
    if not na(n.q3Ts)
        projQ3 := tc > n.q3Ts ? f_kill(projQ3) : f_set_or_make_vline(projQ3, n.q3Ts, COL_Q3)
    if not na(n.q4Ts)
        projQ4 := tc > n.q4Ts ? f_kill(projQ4) : f_set_or_make_vline(projQ4, n.q4Ts, COL_Q4)

    // End projection always visible for the active cycle
    if not na(n.endTs)
        projEnd := f_set_or_make_vline(projEnd, n.endTs, COL_Q1)

    // Track printed cycle starts
    if n.inWindow and not na(n.q1Ts)
        f_push_unique_int(nanoStarts, n.q1Ts, STORE_MAX)

    // Determine effective keepCycles based on line budget
    int perCycle = showOpens ? 9 : 5
    int maxC = int(math.floor((MAX_LINES - 10) / (perCycle * 1.0)))
    maxC := f_clamp_int(maxC, 1, 200)

    int keepEff = f_clamp_int(keepCycles, 1, maxC)

    int cutoff = na(n.q1Ts) ? 0 : n.q1Ts
    int nAvail = array.size(nanoStarts)
    int nUse   = math.min(keepEff, nAvail)
    int first  = nAvail - nUse
    if nUse > 0
        cutoff := array.get(nanoStarts, first)

    // Trim realized divider set to cutoff window
    vset_trim_since(nanoV, cutoff)

    // Update current-cycle snapshot (from QTCore) into open history
    f_hist_ensure_current()

    // Trim open history to cutoff
    f_hist_trim_cutoff(cutoff)

    // Realized dividers (persist via vset; windowed by keepCycles)
    if n.inWindow
        if not na(n.q1Ts) and tc > n.q1Ts
            vset_add(nanoV, n.q1Ts, COL_Q1)
        if not na(n.q2Ts) and tc > n.q2Ts
            vset_add(nanoV, n.q2Ts, COL_Q2)
        if not na(n.q3Ts) and tc > n.q3Ts
            vset_add(nanoV, n.q3Ts, COL_Q3)
        if not na(n.q4Ts) and tc > n.q4Ts
            vset_add(nanoV, n.q4Ts, COL_Q4)

        // Only persist cycle-end once it’s actually passed
        if not na(n.endTs) and tc > n.endTs
            vset_add(nanoV, n.endTs, COL_Q1)

    // Draw/update open lines for every retained cycle
    if not showOpens
        int j = array.size(histStart) - 1
        while j >= 0
            f_hist_kill_at(j)
            j -= 1
    else
        int sz = array.size(histStart)
        int k = 0
        while k < sz
            int endTs = array.get(histEnd, k)

            // Q1 open line
            float y1 = array.get(h_q1o, k)
            int   x1 = array.get(h_q1oTs, k)
            line  l1 = array.get(l_q1o, k)
            if not na(y1) and not na(x1) and not na(endTs)
                l1 := f_set_or_make_hline(l1, x1, endTs, y1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                l1 := f_kill(l1)
            array.set(l_q1o, k, l1)

            // Q2 open / true open line
            float y2 = array.get(h_q2o, k)
            int   x2 = array.get(h_q2oTs, k)
            line  l2 = array.get(l_q2o, k)
            if not na(y2) and not na(x2) and not na(endTs)
                l2 := f_set_or_make_hline(l2, x2, endTs, y2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                l2 := f_kill(l2)
            array.set(l_q2o, k, l2)

            // Q3 open line
            float y3 = array.get(h_q3o, k)
            int   x3 = array.get(h_q3oTs, k)
            line  l3 = array.get(l_q3o, k)
            if not na(y3) and not na(x3) and not na(endTs)
                l3 := f_set_or_make_hline(l3, x3, endTs, y3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                l3 := f_kill(l3)
            array.set(l_q3o, k, l3)

            // Q4 open line
            float y4 = array.get(h_q4o, k)
            int   x4 = array.get(h_q4oTs, k)
            line  l4 = array.get(l_q4o, k)
            if not na(y4) and not na(x4) and not na(endTs)
                l4 := f_set_or_make_hline(l4, x4, endTs, y4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                l4 := f_kill(l4)
            array.set(l_q4o, k, l4)

            k += 1
