//@version=6
indicator("Quarterly Theory [JAW] TESTING", overlay=true, max_lines_count=500, max_labels_count=500)

// ============================================================================
// CONSTANTS
// ============================================================================
var string TZ = "America/New_York"

var int MS_SEC = 1000
var int MS_MIN = 60 * MS_SEC
var int MS_HR  = 60 * MS_MIN

// Cycle lengths
var int LEN_90M  = 90 * MS_MIN
var int LEN_6H   = 6  * MS_HR
var int LEN_24H  = 24 * MS_HR
var int LEN_22_5 = 22 * MS_MIN + 30 * MS_SEC              // 22.5m
var int LEN_NANO = 337500                                  // 5m 37.5s = 22.5m / 4

// Quarter colors (fixed)
var color COL_Q1 = color.rgb( 99,  99,  99)   // #636363
var color COL_Q2 = color.rgb(242,  54,  69)   // #f23645
var color COL_Q3 = color.rgb( 76, 175,  80)   // #4caf50
var color COL_Q4 = color.rgb( 41,  98, 255)   // #2962ff
var color COL_Q5 = color.rgb( 12,  50, 153)   // #0c3299 (weekly Q5)

// Vertical opacity: 30% opacity => 70 transparency
var int V_TRANSP = 70
f_vcol(color c) =>
    color.new(c, V_TRANSP)

// Use THIS exactly (your requested mapping)
lineStyleFrom(string s) =>
    switch s
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        =>          line.style_dotted

// ============================================================================
// INPUTS
// ============================================================================
// TIME CYCLES toggles (Weekly removed)
groupCycles = "TIME CYCLES"
useDaily    = input.bool(true,  "Daily",  group=groupCycles)
useM90      = input.bool(true,  "m90",    group=groupCycles)
useMicro    = input.bool(true,  "Micro",  group=groupCycles)
useNano     = input.bool(true,  "Nano",   group=groupCycles)

useWeekly   = input.bool(false, "Weekly", group=groupCycles)

// Single shared settings block controlling ALL cycles
groupAll        = "CYCLE SETTINGS"
showOpens       = input.bool(true,  "Show Opens", group=groupAll)
keepCycles      = input.int(1,      "# of Cycles", minval=1, maxval=200, group=groupAll)
q1OpenCol       = input.color(color.rgb(255, 152, 0), "Q1 Open Color", group=groupAll)
trueOpenCol     = input.color(color.rgb(0,   0,   0), "Q2 Open Color", group=groupAll)

// NEW: style options (two separate ones)
q1OpenStyleStr   = input.string("Dashed", "Q1 Open Style", options=["Solid","Dashed","Dotted"], group=groupAll)
trueOpenStyleStr = input.string("Dashed",  "Q2 Open Style", options=["Solid","Dashed","Dotted"], group=groupAll)

// ============================================================================
// HELPERS
// ============================================================================
f_clamp_int(int x, int lo, int hi) =>
    int a = x < lo ? lo : x
    int b = a > hi ? hi : a
    b

crosses_ts(int ts) =>
    bool havePrev = bar_index > 0 and not na(time[1])
    bool overlap  = (time <= ts) and (time_close > ts)
    bool gapCross = havePrev and (time >= ts) and (time[1] < ts)
    overlap or gapCross

f_chart_ms() =>
    int ms = 0
    if timeframe.isseconds
        ms := timeframe.multiplier * MS_SEC
    else if timeframe.isminutes
        ms := timeframe.multiplier * MS_MIN
    else if timeframe.isdaily
        ms := LEN_24H
    else if timeframe.isweekly
        ms := 7 * LEN_24H
    else if timeframe.ismonthly
        ms := 31 * LEN_24H
    else
        ms := 365 * LEN_24H
    ms

// QT-day session start timestamp for a given bar time
// Anchor: 18:00 America/New_York
f_qt_day_start(int t) =>
    int y  = year(t, TZ)
    int mo = month(t, TZ)
    int da = dayofmonth(t, TZ)
    int h  = hour(t, TZ)
    int mi = minute(t, TZ)
    int base = timestamp(TZ, y, mo, da, 18, 0)
    int out  = (h > 18 or (h == 18 and mi >= 0)) ? base : base - LEN_24H
    out


// Next QT-day start strictly AFTER `t` (calendar anchored to 18:00 NY)
f_next_ds_after(int t) =>
    int ds0 = f_qt_day_start(t)
    ds0 <= t ? ds0 + LEN_24H : ds0


// ============================================================================
// BULLETPROOF OPEN FETCH
// - m1 opens: pure request.security("1") only
// - micro/nano opens: NEVER call security_lower_tf("30S" or "5S")
//   Instead: always use security_lower_tf("1S") and derive bucket opens.
// ============================================================================

// m1 open for the 1-minute bar that CONTAINS `ts`
// (pure request.security() only - safe on any chart TF, including seconds)
open_at_ts_m1_containing(int ts) =>
    float out = na
    int   t0  = request.security(syminfo.tickerid, "1", time, lookahead=barmerge.lookahead_on)
    float o0  = request.security(syminfo.tickerid, "1", open, lookahead=barmerge.lookahead_on)
    if not na(t0) and ts >= t0 and ts < (t0 + MS_MIN)
        out := o0

    // Fallbacks
    if na(out) and time == ts
        out := open
    if na(out) and crosses_ts(ts)
        out := open

    out


// Open of the FIRST m1 candle that starts on/after `ts`.
// This survives gaps: if there is no candle exactly at `ts`, it picks the first printed minute after it.
open_m1_first_on_or_after(int ts) =>
    float out = request.security(
         syminfo.tickerid,
         "1",
         ta.valuewhen(time >= ts and nz(time[1], time - MS_MIN) < ts, open, 0),
         lookahead=barmerge.lookahead_on
    )
    out


// Universal sub-bar open using ONLY 1-second lower_tf.
// Returns the "open" of the bucket (first available 1S open inside [bucketStart, bucketEnd)).
// This handles gaps (no trades at exact boundary second).
open_at_ts_bucket_from_1s(int ts, int bucketMs) =>
    float out = na

    int[]   tArr = request.security_lower_tf(syminfo.tickerid, "1S", time)
    float[] oArr = request.security_lower_tf(syminfo.tickerid, "1S", open)

    int nT = tArr.size()
    int nO = oArr.size()
    int n  = nO < nT ? nO : nT
    if n > 0
        int bStart = ts - (ts % bucketMs)
        int bEnd   = bStart + bucketMs

        int bestT = na
        int i = 0
        while i < n
            int t0 = tArr.get(i)
            if t0 >= bStart and t0 < bEnd
                if na(bestT) or t0 < bestT
                    bestT := t0
                    out   := oArr.get(i)
            i += 1

    // Fallbacks (last resort)
    if na(out) and time == ts
        out := open
    if na(out) and crosses_ts(ts)
        out := open

    out

// --- Time snapping ---
f_snap_up(int ts, int stepMs) =>
    int r = ts % stepMs
    r == 0 ? ts : ts + (stepMs - r)

// --- Open sourcing from 5S ---
// Returns the OPEN of the 5S candle that starts at `ts` (or the first 5S candle inside [ts, ts+bucketMs)).
// Safe: never calls request.security_lower_tf unless the chart TF is strictly higher than 5S.
open_at_ts_bucket_from_5s(int ts, int bucketMs) =>
    float out = na
    int chartMs = f_chart_ms()

    // If chart is LOWER than 5S, we should not be drawing Nano at all; return na defensively.
    if chartMs < bucketMs
        out := na
    // If chart is EXACTLY 5S, use the chart's own open.
    else if chartMs == bucketMs
        if crosses_ts(ts)
            out := open
    // If chart is HIGHER than 5S, fetch the embedded 5S opens/times and pick the one starting at `ts`.
    // NOTE: request.security_lower_tf() can return empty arrays on some bars/symbols; guard all indexing.
    else
        if crosses_ts(ts)
            int[]   tArr = request.security_lower_tf(syminfo.tickerid, "5S", time)
            float[] oArr = request.security_lower_tf(syminfo.tickerid, "5S", open)
            int nT = array.size(tArr)
            int nO = array.size(oArr)
            int n  = nO < nT ? nO : nT

            if n > 0
                for i = 0 to n - 1
                    int t = array.get(tArr, i)
                    if t >= ts and t < ts + bucketMs
                        out := array.get(oArr, i)
                        break
            else
                // Fallback: only safe when the boundary equals THIS bar's open timestamp.
                if time == ts
                    out := open
    out


// ============================================================================
// STORAGE (vertical + horizontal sets)
// ============================================================================
type vset
    line[] ln
    int[]  ts

vset_new() =>
    vset.new(array.new_line(), array.new_int())

vset_clear(vset s) =>
    int i = s.ln.size() - 1
    while i >= 0
        line.delete(s.ln.get(i))
        i -= 1
    s.ln.clear()
    s.ts.clear()
    0

vset_trim_since(vset s, int cutoff) =>
    int i = s.ts.size() - 1
    while i >= 0
        if s.ts.get(i) < cutoff
            line.delete(s.ln.get(i))
            array.remove(s.ln, i)
            array.remove(s.ts, i)
        i -= 1
    0

vset_has(vset s, int ts) =>
    bool found = false
    int i = s.ts.size() - 1
    while i >= 0 and not found
        found := s.ts.get(i) == ts
        i -= 1
    found

vset_add(vset s, int ts, color c) =>
    if not vset_has(s, ts)
        s.ln.push(line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c)))
        s.ts.push(ts)
    0

type hset
    line[] ln
    int[]  st

hset_new() =>
    hset.new(array.new_line(), array.new_int())

hset_clear(hset s) =>
    int i = s.ln.size() - 1
    while i >= 0
        line.delete(s.ln.get(i))
        i -= 1
    s.ln.clear()
    s.st.clear()
    0

hset_trim_since(hset s, int cutoff) =>
    int i = s.st.size() - 1
    while i >= 0
        if s.st.get(i) < cutoff
            line.delete(s.ln.get(i))
            array.remove(s.ln, i)
            array.remove(s.st, i)
        i -= 1
    0

hset_has(hset s, int st) =>
    bool found = false
    int i = s.st.size() - 1
    while i >= 0 and not found
        found := s.st.get(i) == st
        i -= 1
    found

// UPDATED: style is a string param mapped by lineStyleFrom()
hset_add(hset s, int st, int et, float y, color c, string styleStr) =>
    if not hset_has(s, st)
        s.ln.push(line.new(st, y, et, y, xloc=xloc.bar_time, extend=extend.none, style=lineStyleFrom(styleStr), width=1, color=c))
        s.st.push(st)
    0

// Keep existing open lines synced if user changes style/color
hset_sync(hset s, color c, string styleStr) =>
    int i = s.ln.size() - 1
    while i >= 0
        line ln = s.ln.get(i)
        if not na(ln)
            line.set_color(ln, c)
            line.set_style(ln, lineStyleFrom(styleStr))
            line.set_width(ln, 1)
        i -= 1
    0

// ============================================================================
// PROJECTION HELPERS
// ============================================================================
f_set_or_make_vline(line ln, int ts, color c) =>
    line out = ln
    if na(out)
        out := line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c))
    else
        line.set_xy1(out, ts, low)
        line.set_xy2(out, ts, high)
        line.set_style(out, line.style_solid)
        line.set_width(out, 1)
        line.set_color(out, f_vcol(c))
    out

f_kill(line ln) =>
    line out = na
    if not na(ln)
        line.delete(ln)
    out

// ============================================================================
// PHASE B: GENERIC FIXED-CYCLE RUNNER (Daily / m90 / Micro / Nano)
// - Uses state-triggered logic: time_close > boundary timestamps.
// - Weekly is disabled in this build to isolate testing.
// ============================================================================

int OPEN_SRC_M1        = 0
int OPEN_SRC_BUCKET_1S = 1

f_push_unique_int(int[] a, int v, int maxSize) =>
    if array.size(a) == 0 or array.get(a, array.size(a) - 1) != v
        array.push(a, v)
        while array.size(a) > maxSize
            array.shift(a)
    0

f_open_at_ts(int ts, int openSrc, int bucketMs) =>
    float out = na
    float m1o = open_at_ts_m1_containing(ts)
    if openSrc == OPEN_SRC_M1
        out := m1o
    else
        out := open_at_ts_bucket_from_1s(ts, bucketMs)
    out

run_fixed_cycle(
    int curStart,
    int parentLenMs,
    int quarterLenMs,
    bool snapQuarters,
    int alignMs,
    int openSrc,
    int openBucketMs,
    int keepEff,
    int storeMax,
    int[] starts,
    vset v,
    hset hQ1,
    hset hQ2,
    line projQ2,
    line projQ3,
    line projQ4,
    line projEnd
) =>
    // Record current printed cycle start (one entry per printed cycle)
    f_push_unique_int(starts, curStart, storeMax)

    int nAvail = array.size(starts)
    int nUse   = math.min(keepEff, nAvail)
    int first  = nAvail - nUse

    int cutoff = curStart
    if nUse > 0
        cutoff := array.get(starts, first)

    // Trim drawings to cutoff window
    vset_trim_since(v, cutoff)

    if showOpens
        hset_trim_since(hQ1, cutoff)
        hset_trim_since(hQ2, cutoff)
    else
        if hQ1.ln.size() > 0
            hset_clear(hQ1)
        if hQ2.ln.size() > 0
            hset_clear(hQ2)

    // Backfill dividers + opens for visible history.
    int i = first
    while i < nAvail
        int bStart = array.get(starts, i)
        int bEnd   = bStart + parentLenMs

        int q1 = bStart
        int q2 = snapQuarters ? f_snap_up(bStart + 1 * quarterLenMs, alignMs) : (bStart + 1 * quarterLenMs)
        int q3 = snapQuarters ? f_snap_up(bStart + 2 * quarterLenMs, alignMs) : (bStart + 2 * quarterLenMs)
        int q4 = snapQuarters ? f_snap_up(bStart + 3 * quarterLenMs, alignMs) : (bStart + 3 * quarterLenMs)

        if time_close > q1
            vset_add(v, q1, COL_Q1)
        if time_close > q2
            vset_add(v, q2, COL_Q2)
        if time_close > q3
            vset_add(v, q3, COL_Q3)
        if time_close > q4
            vset_add(v, q4, COL_Q4)

        if showOpens
            if time_close > q1
                float p1 = f_open_at_ts(q1, openSrc, openBucketMs)
                if not na(p1)
                    hset_add(hQ1, q1, bEnd, p1, q1OpenCol, q1OpenStyleStr)

            if time_close > q2
                float p2 = f_open_at_ts(q2, openSrc, openBucketMs)
                if not na(p2)
                    hset_add(hQ2, q2, bEnd, p2, trueOpenCol, trueOpenStyleStr)

        i += 1

    if showOpens
        hset_sync(hQ1,  q1OpenCol,   q1OpenStyleStr)
        hset_sync(hQ2,  trueOpenCol, trueOpenStyleStr)

    // Projections for the currently-active printed cycle.
    int curEnd = curStart + parentLenMs
    int curQ2  = snapQuarters ? f_snap_up(curStart + 1 * quarterLenMs, alignMs) : (curStart + 1 * quarterLenMs)
    int curQ3  = snapQuarters ? f_snap_up(curStart + 2 * quarterLenMs, alignMs) : (curStart + 2 * quarterLenMs)
    int curQ4  = snapQuarters ? f_snap_up(curStart + 3 * quarterLenMs, alignMs) : (curStart + 3 * quarterLenMs)

    line q2L = projQ2
    line q3L = projQ3
    line q4L = projQ4
    line eL  = projEnd

    if time_close > curQ2
        q2L := f_kill(q2L)
    else
        q2L := f_set_or_make_vline(q2L, curQ2, COL_Q2)

    if time_close > curQ3
        q3L := f_kill(q3L)
    else
        q3L := f_set_or_make_vline(q3L, curQ3, COL_Q3)

    if time_close > curQ4
        q4L := f_kill(q4L)
    else
        q4L := f_set_or_make_vline(q4L, curQ4, COL_Q4)

    eL := f_set_or_make_vline(eL, curEnd, COL_Q1)

    line[] out = array.new_line()
    array.push(out, q2L)
    array.push(out, q3L)
    array.push(out, q4L)
    array.push(out, eL)
    out


// ============================================================================
// CYCLE CONTAINER INTERFACE (prep for SSMT integration)
//
// Goal: tiny helper pattern (no refactor) that answers:
//   - What is the current quarter start/end?
//   - What was the previous quarter start/end?
//
// This is array-driven so it works for printed-structure cycles (e.g., Weekly),
// but it can be reused anywhere you have a sorted list of quarter starts.
// All timestamps are ms (bar_time).
// ============================================================================

f_last_int_lt(int[] a, int x) =>
    int out = int(na)
    int n = array.size(a)
    if n > 0
        for i = 0 to n - 1
            int v = array.get(a, i)
            if v < x
                out := v
    out

// Returns [curStart, curEnd, prevStart, prevEnd]
// - `qStarts` must be sorted ascending.
// - `windowEnd` is the inclusive/real end of the container window (e.g., weekEnd).
// - `prevStartFallback` is used when the current quarter is the first in the window.
f_qbounds_from_starts(int t, int windowEnd, int[] qStarts, int prevStartFallback) =>
    int curS  = int(na)
    int curE  = int(na)
    int prevS = int(na)
    int prevE = int(na)

    int n = array.size(qStarts)
    if n > 0
        int idx = -1
        for i = 0 to n - 1
            int s = array.get(qStarts, i)
            if s <= t
                idx := i

        if idx >= 0
            curS := array.get(qStarts, idx)
            curE := idx < (n - 1) ? array.get(qStarts, idx + 1) : windowEnd

            prevE := curS
            if idx > 0
                prevS := array.get(qStarts, idx - 1)
            else
                prevS := prevStartFallback

    [curS, curE, prevS, prevE]

// ============================================================================
// RUNNER B: WEEKLY PRINTED-WINDOW CYCLE (wkStarts/wkEnds)
// - Dividers: wkStart, QT-day boundaries inside week (Q2-Q5), wkEnd (only after week completes)
// - Opens: W.O (official weekly open) and T.W.O (first printed minute on/after Q2 boundary)
// - Projections (active week): Q2-Q5 + week end
// ============================================================================

run_week_cycle(
    int[]   wkStarts,
    int[]   wkEnds,
    float[] wkWo,
    float[] wkTwo,
    int     wEndProj,
    int     keepWeeks,
    vset    v,
    hset    hWO,
    hset    hTWO,
    line    projQ2,
    line    projQ3,
    line    projQ4,
    line    projQ5,
    line    projEnd
) =>
    line p2  = projQ2
    line p3  = projQ3
    line p4  = projQ4
    line p5  = projQ5
    line pE  = projEnd

    int nS = wkStarts.size()
    int nE = wkEnds.size()
    int nW = wkWo.size()
    int nT = wkTwo.size()
    int n0 = nS < nE ? nS : nE
    int n1 = nW < nT ? nW : nT
    int n  = n0 < n1 ? n0 : n1

    // Hard guard
    if n <= 0
        p2 := f_kill(p2)
        p3 := f_kill(p3)
        p4 := f_kill(p4)
        p5 := f_kill(p5)
        pE := f_kill(pE)
        line[] out0 = array.new_line()
        array.push(out0, p2)
        array.push(out0, p3)
        array.push(out0, p4)
        array.push(out0, p5)
        array.push(out0, pE)
        out0
    else
        int first = math.max(0, n - keepWeeks)
        int cut   = wkStarts.get(first)

        // Trim drawings
        vset_trim_since(v, cut)
        if showOpens
            hset_trim_since(hWO, cut)
            hset_trim_since(hTWO, cut)

        // Backfill / maintain dividers + opens for all retained weeks
        int i = first
        while i < n
            int wS = wkStarts.get(i)
            int wEStored = wkEnds.get(i)
            int wE = na(wEStored) ? wEndProj : wEStored

            // Week start divider (Q1)
            if wS >= cut and time_close > wS
                vset_add(v, wS, COL_Q1)

            // QT-day boundaries inside the week (Q2-Q5)
            int q2 = f_next_ds_after(wS)
            int q3 = q2 + LEN_24H
            int q4 = q3 + LEN_24H
            int q5 = q4 + LEN_24H

            if not na(q2) and q2 >= cut and q2 < wE and time_close > q2
                vset_add(v, q2, COL_Q2)
            if not na(q3) and q3 >= cut and q3 < wE and time_close > q3
                vset_add(v, q3, COL_Q3)
            if not na(q4) and q4 >= cut and q4 < wE and time_close > q4
                vset_add(v, q4, COL_Q4)
            if not na(q5) and q5 >= cut and q5 < wE and time_close > q5
                vset_add(v, q5, COL_Q5)

            // Week end divider (only after the week is complete)
            if not na(wEStored) and wEStored >= cut and time_close > wEStored
                vset_add(v, wEStored, COL_Q1)

            // Opens
            if showOpens
                float wo = wkWo.get(i)
                if not na(wo) and time_close > wS
                    hset_add(hWO, wS, wE, wo, q1OpenCol, q1OpenStyleStr)

                float twoO = wkTwo.get(i)
                if not na(twoO) and time_close > q2
                    hset_add(hTWO, q2, wE, twoO, trueOpenCol, trueOpenStyleStr)

            i += 1

        if showOpens
            hset_sync(hWO, q1OpenCol, q1OpenStyleStr)
            hset_sync(hTWO, trueOpenCol, trueOpenStyleStr)

        // ACTIVE week projections (only the most recent printed week)
        int curWs = wkStarts.get(n - 1)
        int curQ2 = f_next_ds_after(curWs)
        int curQ3 = curQ2 + LEN_24H
        int curQ4 = curQ3 + LEN_24H
        int curQ5 = curQ4 + LEN_24H

        // Project future boundaries; kill once passed
        if not na(curQ2) and time_close <= curQ2
            p2 := f_set_or_make_vline(p2, curQ2, COL_Q2)
        else
            p2 := f_kill(p2)

        if not na(curQ3) and time_close <= curQ3
            p3 := f_set_or_make_vline(p3, curQ3, COL_Q3)
        else
            p3 := f_kill(p3)

        if not na(curQ4) and time_close <= curQ4
            p4 := f_set_or_make_vline(p4, curQ4, COL_Q4)
        else
            p4 := f_kill(p4)

        if not na(curQ5) and time_close <= curQ5
            p5 := f_set_or_make_vline(p5, curQ5, COL_Q5)
        else
            p5 := f_kill(p5)

        // Week end projection stays up for the active week
        pE := f_set_or_make_vline(pE, wEndProj, COL_Q1)

        line[] out = array.new_line()
        array.push(out, p2)
        array.push(out, p3)
        array.push(out, p4)
        array.push(out, p5)
        array.push(out, pE)
        out

// ============================================================================
// TIMEFRAME GATING (AUTO) + TOGGLES
// ============================================================================
bool tf_m15 = timeframe.isminutes and timeframe.multiplier == 15
bool tf_m30 = timeframe.isminutes and timeframe.multiplier == 30
bool tf_m90 = timeframe.isminutes and timeframe.multiplier == 90
bool tf_h1  = timeframe.isminutes and timeframe.multiplier == 60  // 1H == 60m
bool tf_h2  = timeframe.isminutes and timeframe.multiplier == 120 // 2H
bool tf_h3  = timeframe.isminutes and timeframe.multiplier == 180 // 3H
bool tf_h4  = timeframe.isminutes and timeframe.multiplier == 240 // 4H

bool dailyLive = useDaily and timeframe.isintraday and (tf_m15 or tf_m30)
bool m90Live   = useM90   and timeframe.isminutes and timeframe.multiplier == 5

bool microLive = useMicro and timeframe.isintraday and (
     (timeframe.isseconds and timeframe.multiplier >= 30 and timeframe.multiplier < 60) or
     (timeframe.isminutes and timeframe.multiplier >= 1  and timeframe.multiplier <= 3)
)

bool nanoLive  = useNano and timeframe.isseconds and timeframe.multiplier >= 5 and timeframe.multiplier <= 29
bool weeklyLive = useWeekly and timeframe.isintraday and (tf_h1 or tf_h2 or tf_h3 or tf_h4)

// ============================================================================
// OPEN SOURCES (ms only now; tf strings not needed)
// - Daily + m90 => m1 (request.security only)
// - Micro => 30s bucket (from 1S lower_tf)
// - Nano  => 5s  bucket (from 1S lower_tf)
// ============================================================================
var int MS_MICRO_ALIGNED = 30 * MS_SEC
var int MS_NANO_ALIGNED  = 5  * MS_SEC

// ============================================================================
// SESSION START (CME "day" at 18:00 NY via TradingView daily session bar)
// ============================================================================
// SESSION START (CME "day" at 18:00 NY)
// NOTE: TradingView's built-in daily session can occasionally merge holiday sessions into a single "D" bar,
// which would freeze `ds` and cause Daily/m90 structures to appear to skip.
// We keep the TV daily value when it agrees with the calendar-anchored 18:00 NY start,
// otherwise fall back to the calendar-anchored start.
int ds_raw = request.security(syminfo.tickerid, "D", time, lookahead=barmerge.lookahead_on)
int ds_cal = f_qt_day_start(time)
int ds_diff = na(ds_raw) ? na : (ds_raw > ds_cal ? ds_raw - ds_cal : ds_cal - ds_raw)
int ds = na(ds_raw) ? ds_cal : (ds_diff > (12 * MS_HR) ? ds_cal : ds_raw)

// ============================================================================

// ============================================================================
// m90 CYCLE (6H parent with 4x 90m quarters) - visible m5
// "# of Cycles" counts PRINTED 6H cycles (cycles that actually have bars)
// Opens from m1 (pure request.security helper)
// ============================================================================
var vset m90V    = vset_new()
var hset m90HQ1  = hset_new()
var hset m90HTru = hset_new()

var line m90ProjQ2  = na
var line m90ProjQ3  = na
var line m90ProjQ4  = na
var line m90ProjEnd = na

// Keep a rolling list of realized 6H cycle-starts (one entry per printed cycle)
var int[] m90Starts = array.new_int()
var int   M90_STORE_MAX = 600

// Effective keep cap to avoid line-limit explosions (m90 is the heaviest)
int m90KeepEff = keepCycles
m90KeepEff := showOpens ? f_clamp_int(m90KeepEff, 1, 70) : f_clamp_int(m90KeepEff, 1, 110)

if not m90Live
    if m90V.ln.size() > 0
        vset_clear(m90V)
    if m90HQ1.ln.size() > 0
        hset_clear(m90HQ1)
    if m90HTru.ln.size() > 0
        hset_clear(m90HTru)

    m90ProjQ2  := f_kill(m90ProjQ2)
    m90ProjQ3  := f_kill(m90ProjQ3)
    m90ProjQ4  := f_kill(m90ProjQ4)
    m90ProjEnd := f_kill(m90ProjEnd)
else
    // Current printed 6H cycle start inside the QT day container.
    int dtNow  = time - ds
    int tNow   = dtNow > 0 ? dtNow : 0
    int idxNow = f_clamp_int(int(math.floor(float(tNow) / float(LEN_6H))), 0, 3)
    int curSt  = ds + idxNow * LEN_6H

    line[] projs = run_fixed_cycle(
        curSt,
        LEN_6H,
        LEN_90M,
        false,
        0,
        OPEN_SRC_M1,
        0,
        m90KeepEff,
        M90_STORE_MAX,
        m90Starts,
        m90V,
        m90HQ1,
        m90HTru,
        m90ProjQ2,
        m90ProjQ3,
        m90ProjQ4,
        m90ProjEnd
    )

    m90ProjQ2  := array.get(projs, 0)
    m90ProjQ3  := array.get(projs, 1)
    m90ProjQ4  := array.get(projs, 2)
    m90ProjEnd := array.get(projs, 3)

// ============================================================================

// ============================================================================
// WEEKLY CYCLE (printed window) - visible m15/m30/H1-H4 (see gating)
// "# of Cycles" counts PRINTED weeks (weeks that actually have bars)
// Dividers: wkStart + QT-day boundaries inside the week + wkEnd
// Opens: W.O (weekly open) + T.W.O (first printed minute on/after Q2 boundary)
// Projections: to week end
// ============================================================================
var vset weekV     = vset_new()
var hset weekHWO   = hset_new()
var hset weekHTWO  = hset_new()

var line weekProjQ2  = na
var line weekProjQ3  = na
var line weekProjQ4  = na
var line weekProjQ5  = na
var line weekProjEnd = na

var int[]   wkStarts = array.new_int()
var int[]   wkEnds   = array.new_int()
var float[] wkWo     = array.new_float()
var float[] wkTwo    = array.new_float()
var int     WK_STORE_MAX = 400

// Weekly "official" series (projected; does not repaint for open, and provides week-end projection)
int   wkKey    = request.security(syminfo.tickerid, "W", time,      lookahead=barmerge.lookahead_on)
int   wkEndPrj = request.security(syminfo.tickerid, "W", time_close, lookahead=barmerge.lookahead_on)
float wkOpen   = request.security(syminfo.tickerid, "W", open,      lookahead=barmerge.lookahead_on)
bool  newWk    = ta.change(wkKey) != 0

// Maintain printed week windows + store WO/TWO values once per printed week.
// This runs whenever weekly is enabled so a later TF switch doesn't "miss" stored values.
if useWeekly
    if wkStarts.size() == 0
        wkStarts.push(time)
        wkEnds.push(na)
        wkWo.push(wkOpen)
        wkTwo.push(na)
    else
        if newWk
            // finalize prior printed week end using the last printed bar of the previous week
            if bar_index > 0 and wkEnds.size() > 0
                wkEnds.set(wkEnds.size() - 1, time_close[1])

            wkStarts.push(time)
            wkEnds.push(na)
            wkWo.push(wkOpen)
            wkTwo.push(na)

            while wkStarts.size() > WK_STORE_MAX
                wkStarts.shift()
                wkEnds.shift()
                wkWo.shift()
                wkTwo.shift()
        else
            // keep active-week WO synced
            if wkWo.size() > 0
                wkWo.set(wkWo.size() - 1, wkOpen)

    // Capture active-week T.W.O open once available (first printed m1 after Q2 boundary).
    int nW0 = wkStarts.size()
    int nW1 = wkEnds.size()
    int nW2 = wkWo.size()
    int nW3 = wkTwo.size()
    int nWm = (nW0 < nW1 ? nW0 : nW1)
    int nWn = (nW2 < nW3 ? nW2 : nW3)
    int nW  = (nWm < nWn ? nWm : nWn)

    if nW > 0
        int curWs = wkStarts.get(nW - 1)
        int curQ2 = f_next_ds_after(curWs)
        float curTwo = wkTwo.get(nW - 1)
        if na(curTwo) and time_close > curQ2
            float twoO = open_m1_first_on_or_after(curQ2)
            if not na(twoO)
                wkTwo.set(nW - 1, twoO)

if not weeklyLive
    if weekV.ln.size() > 0
        vset_clear(weekV)
    if weekHWO.ln.size() > 0
        hset_clear(weekHWO)
    if weekHTWO.ln.size() > 0
        hset_clear(weekHTWO)

    weekProjQ2  := f_kill(weekProjQ2)
    weekProjQ3  := f_kill(weekProjQ3)
    weekProjQ4  := f_kill(weekProjQ4)
    weekProjQ5  := f_kill(weekProjQ5)
    weekProjEnd := f_kill(weekProjEnd)
else
    line[] wprojs = run_week_cycle(
        wkStarts,
        wkEnds,
        wkWo,
        wkTwo,
        wkEndPrj,
        keepCycles,
        weekV,
        weekHWO,
        weekHTWO,
        weekProjQ2,
        weekProjQ3,
        weekProjQ4,
        weekProjQ5,
        weekProjEnd
    )

    weekProjQ2  := array.get(wprojs, 0)
    weekProjQ3  := array.get(wprojs, 1)
    weekProjQ4  := array.get(wprojs, 2)
    weekProjQ5  := array.get(wprojs, 3)
    weekProjEnd := array.get(wprojs, 4)

// ============================================================================
// DAILY CYCLE (24H parent with 4x 6H quarters) - visible m15/m30
// "# of Cycles" counts PRINTED 24H QT cycles (cycles that actually have bars)
// Opens from m1 (pure request.security helper)
// ============================================================================
var vset dV    = vset_new()
var hset dHQ1  = hset_new()
var hset dHTru = hset_new()

var line dProjQ2  = na
var line dProjQ3  = na
var line dProjQ4  = na
var line dProjEnd = na

// Keep a rolling list of realized QT day-starts (one entry per printed daily cycle)
var int[] dStarts = array.new_int()
var int   D_STORE_MAX = 800

if not dailyLive
    if dV.ln.size() > 0
        vset_clear(dV)
    if dHQ1.ln.size() > 0
        hset_clear(dHQ1)
    if dHTru.ln.size() > 0
        hset_clear(dHTru)

    dProjQ2  := f_kill(dProjQ2)
    dProjQ3  := f_kill(dProjQ3)
    dProjQ4  := f_kill(dProjQ4)
    dProjEnd := f_kill(dProjEnd)
else
    int curDay = ds

    line[] projs = run_fixed_cycle(
        curDay,
        LEN_24H,
        LEN_6H,
        false,
        0,
        OPEN_SRC_M1,
        0,
        keepCycles,
        D_STORE_MAX,
        dStarts,
        dV,
        dHQ1,
        dHTru,
        dProjQ2,
        dProjQ3,
        dProjQ4,
        dProjEnd
    )

    dProjQ2  := array.get(projs, 0)
    dProjQ3  := array.get(projs, 1)
    dProjQ4  := array.get(projs, 2)
    dProjEnd := array.get(projs, 3)

// ============================================================================

// ============================================================================
// MICRO (inside each 90m block: 4x 22.5m) - visible 30s-m3
// "# of Cycles" counts PRINTED 90m blocks (blocks that actually have bars)
// Opens from 30s bucket (derived from 1S lower_tf)
// ============================================================================
var vset microV    = vset_new()
var hset microHQ1  = hset_new()
var hset microHTru = hset_new()

var line microProjQ2  = na
var line microProjQ3  = na
var line microProjQ4  = na
var line microProjEnd = na

// Keep a rolling list of realized 90m cycle-starts (one entry per printed 90m)
var int[] microStarts = array.new_int()
var int   MICRO_STORE_MAX = 2400

int microKeepEff = keepCycles
microKeepEff := showOpens ? f_clamp_int(microKeepEff, 1, 60) : f_clamp_int(microKeepEff, 1, 90)

if not microLive
    if microV.ln.size() > 0
        vset_clear(microV)
    if microHQ1.ln.size() > 0
        hset_clear(microHQ1)
    if microHTru.ln.size() > 0
        hset_clear(microHTru)

    microProjQ2  := f_kill(microProjQ2)
    microProjQ3  := f_kill(microProjQ3)
    microProjQ4  := f_kill(microProjQ4)
    microProjEnd := f_kill(microProjEnd)
else
    // Current printed 90m block start inside the QT day container.
    int dtNowM   = time - ds
    int tNowM    = dtNowM > 0 ? dtNowM : 0
    int idx90Now = int(math.floor(float(tNowM) / float(LEN_90M)))
    int cur90St  = ds + idx90Now * LEN_90M

    line[] projs = run_fixed_cycle(
        cur90St,
        LEN_90M,
        LEN_22_5,
        false,
        0,
        OPEN_SRC_BUCKET_1S,
        MS_MICRO_ALIGNED,
        microKeepEff,
        MICRO_STORE_MAX,
        microStarts,
        microV,
        microHQ1,
        microHTru,
        microProjQ2,
        microProjQ3,
        microProjQ4,
        microProjEnd
    )

    microProjQ2  := array.get(projs, 0)
    microProjQ3  := array.get(projs, 1)
    microProjQ4  := array.get(projs, 2)
    microProjEnd := array.get(projs, 3)

// ============================================================================

// ============================================================================
// NANO (Micro / 4 inside each 22.5m micro-quarter) - visible 5s-29s
// NOTE: "# of Cycles" counts PRINTED micro blocks (22.5m) to keep (not 90m blocks).
// Opens from 5s bucket (derived from 1S lower_tf).
// ============================================================================
var vset nanoV    = vset_new()
var hset nanoHQ1  = hset_new()
var hset nanoHTru = hset_new()

var line nanoProjQ2  = na
var line nanoProjQ3  = na
var line nanoProjQ4  = na
var line nanoProjEnd = na

// Keep a rolling list of realized micro-block starts (one entry per printed 22.5m)
var int[] nanoStarts = array.new_int()
var int   NANO_STORE_MAX = 2400

if not nanoLive
    if nanoV.ln.size() > 0
        vset_clear(nanoV)
    if nanoHQ1.ln.size() > 0
        hset_clear(nanoHQ1)
    if nanoHTru.ln.size() > 0
        hset_clear(nanoHTru)

    array.clear(nanoStarts)

    nanoProjQ2  := f_kill(nanoProjQ2)
    nanoProjQ3  := f_kill(nanoProjQ3)
    nanoProjQ4  := f_kill(nanoProjQ4)
    nanoProjEnd := f_kill(nanoProjEnd)
else
    // Current printed micro-block start inside the QT day container.
    int idx90Now     = int(math.floor((time - ds) / LEN_90M))
    int cur90St      = ds + idx90Now * LEN_90M
    int idxMicroNow  = f_clamp_int(int(math.floor(float(time - cur90St) / float(LEN_22_5))), 0, 3)
    int curMicroSt   = cur90St + idxMicroNow * LEN_22_5

    line[] projs = run_fixed_cycle(
        curMicroSt,
        LEN_22_5,
        LEN_NANO,
        true,
        MS_NANO_ALIGNED,
        OPEN_SRC_BUCKET_1S,
        MS_NANO_ALIGNED,
        keepCycles,
        NANO_STORE_MAX,
        nanoStarts,
        nanoV,
        nanoHQ1,
        nanoHTru,
        nanoProjQ2,
        nanoProjQ3,
        nanoProjQ4,
        nanoProjEnd
    )

    nanoProjQ2  := array.get(projs, 0)
    nanoProjQ3  := array.get(projs, 1)
    nanoProjQ4  := array.get(projs, 2)
    nanoProjEnd := array.get(projs, 3)

