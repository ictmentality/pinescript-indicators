//@version=6
indicator("Opening Price Lines [JAW]", overlay=true, max_lines_count=500, max_labels_count=500)

// ============================================================================
// SETTINGS / LIMITS (GROUPED)
// ============================================================================
var string TZ      = "America/New_York"
var int    L_WIDTH = 1
var        TEXT_SZ = size.tiny
var int    DAY_MS  = 24 * 60 * 60 * 1000

groupIntra = "Intraday"
groupWeek  = "Week"

// Limits
keepIntradayDays = input.int(2, "Intraday", minval=0, maxval=50, group=groupIntra)
keepWeeks        = input.int(2, "Weeks",    minval=0, maxval=52, group=groupWeek)

// ============================================================================
// HELPERS
// ============================================================================
lineStyleFrom(string s) =>
    switch s
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        =>          line.style_dotted

calc_end_ts(int startH, int startM, int endH, int endM, int refTime) =>
    int yy = year(refTime, TZ)
    int mm = month(refTime, TZ)
    int dd = dayofmonth(refTime, TZ)
    bool crossesMidnight = (endH * 60 + endM) <= (startH * 60 + startM)
    int  baseEnd         = timestamp(TZ, yy, mm, dd, endH, endM)
    crossesMidnight ? (baseEnd + DAY_MS) : baseEnd

crosses_ts(int ts) =>
    bool havePrev = bar_index > 0 and not na(time[1])
    bool overlap  = (time <= ts) and (time_close > ts)
    bool gapCross = havePrev and (time >= ts) and (time[1] < ts)
    overlap or gapCross

// Exact open at `ts` (millis) using the smallest safe data source:
// - Chart TF > 1m: pull 1m sub-bars via request.security_lower_tf("1", ...)
// - Chart TF < 1m: pull 1-second sub-bars via request.security_lower_tf("1S", ...) to avoid runtime errors
// - Chart TF = 1m: just use the bar open when time == ts
open_at_ts_ltf(int ts) =>
    float out = na

    float tfSec = timeframe.in_seconds()
    bool  isIntr = timeframe.isintraday
    bool  subMinute = isIntr and not na(tfSec) and tfSec < 60
    bool  aboveMinute = isIntr and not na(tfSec) and tfSec > 60

    // Only use lower_tf when it actually adds information (sub-minute or >1m), or on non-intraday charts.
    bool useLower = subMinute or aboveMinute or not isIntr
    string ltf = subMinute ? "1S" : "1"

    if useLower
        int[]   tArr = request.security_lower_tf(syminfo.tickerid, ltf, time)
        float[] oArr = request.security_lower_tf(syminfo.tickerid, ltf, open)

        int n = array.size(tArr)
        if n > 0
            int  i     = 0
            bool found = false
            while i < n and not found
                if array.get(tArr, i) == ts
                    out   := array.get(oArr, i)
                    found := true
                i += 1
    else
        // 1-minute chart: start timestamps align to bar opens.
        if time == ts
            out := open

    // Last-resort fallback.
    if na(out) and time == ts
        out := open

    out

hm_hour(string t) => int(str.tonumber(str.substring(t, 0, 2)))
hm_min(string t)  => int(str.tonumber(str.substring(t, 3, 5)))

modPos(int a, int m) =>
    ((a % m) + m) % m

dowFromStr(string s) =>
    switch s
        "Sun" => int(dayofweek.sunday)
        "Mon" => int(dayofweek.monday)
        "Tue" => int(dayofweek.tuesday)
        "Wed" => int(dayofweek.wednesday)
        "Thu" => int(dayofweek.thursday)
        "Fri" => int(dayofweek.friday)
        =>        int(dayofweek.saturday)

// ============================================================================
// SPAN TYPE + OPS
// ============================================================================
type span
    line[]  ln
    label[] lb
    int[]   stTs
    int[]   endTs

span_new() =>
    span.new(array.new_line(), array.new_label(), array.new_int(), array.new_int())

clear_span(span s) =>
    int nL = array.size(s.ln)
    if nL > 0
        for i = 0 to nL - 1
            line li = array.get(s.ln, i)
            if not na(li)
                li.delete()

    int nB = array.size(s.lb)
    if nB > 0
        for i = 0 to nB - 1
            label b = array.get(s.lb, i)
            if not na(b)
                b.delete()

    array.clear(s.ln)
    array.clear(s.lb)
    array.clear(s.stTs)
    array.clear(s.endTs)
    0

span_pop_oldest(span s) =>
    int n = array.size(s.ln)
    if n > 0
        line li = array.get(s.ln, n - 1)
        if not na(li)
            li.delete()

        label b = array.get(s.lb, n - 1)
        if not na(b)
            b.delete()

        array.pop(s.ln)
        array.pop(s.lb)
        array.pop(s.stTs)
        array.pop(s.endTs)
    0

span_trim_to(span s, int maxCount) =>
    while array.size(s.ln) > maxCount
        span_pop_oldest(s)
    0

// delete entries where stTs < cutoff
span_trim_since(span s, int cutoff) =>
    int i = array.size(s.stTs) - 1
    while i >= 0
        if array.get(s.stTs, i) < cutoff
            line  li = array.get(s.ln, i)
            label lb = array.get(s.lb, i)
            if not na(li)
                li.delete()
            if not na(lb)
                lb.delete()
            array.remove(s.ln, i)
            array.remove(s.lb, i)
            array.remove(s.stTs, i)
            array.remove(s.endTs, i)
        i -= 1
    0

span_add_fixed(span s, int x1Draw, int stStore, float y, int et, string txt, bool makeLabel, color labCol, string styleStr, color lnCol) =>
    array.unshift(s.ln, line.new(
        x1Draw, y, et, y,
        xloc   = xloc.bar_time,
        extend = extend.none,
        style  = lineStyleFrom(styleStr),
        width  = L_WIDTH,
        color  = lnCol
    ))

    label newLb = na
    if makeLabel and str.length(txt) > 0
        newLb := label.new(
            et, y, txt,
            xloc      = xloc.bar_time,
            yloc      = yloc.price,
            style     = label.style_none,
            textcolor = labCol,
            size      = TEXT_SZ,
            textalign = text.align_left
        )
    array.unshift(s.lb, newLb)

    array.unshift(s.stTs, stStore)
    array.unshift(s.endTs, et)
    0

span_sync_styles(span s, color labCol, string styleStr, color lnCol) =>
    int nL = array.size(s.ln)
    if nL > 0
        for i = 0 to nL - 1
            line li = array.get(s.ln, i)
            if not na(li)
                li.set_style(lineStyleFrom(styleStr))
                li.set_color(lnCol)
                li.set_width(L_WIDTH)

    int nB = array.size(s.lb)
    if nB > 0
        for i = 0 to nB - 1
            label bi = array.get(s.lb, i)
            if not na(bi)
                bi.set_textcolor(labCol)
                bi.set_size(TEXT_SZ)
    0

span_remove_start(span s, int st) =>
    int i = 0
    while i < array.size(s.stTs)
        if array.get(s.stTs, i) == st
            line  li = array.get(s.ln, i)
            label lb = array.get(s.lb, i)
            if not na(li)
                li.delete()
            if not na(lb)
                lb.delete()
            array.remove(s.ln, i)
            array.remove(s.lb, i)
            array.remove(s.stTs, i)
            array.remove(s.endTs, i)
        else
            i += 1
    0

span_remove_by_blockers(span target, span blockers) =>
    int n = array.size(blockers.stTs)
    if n > 0
        for i = 0 to n - 1
            int st = array.get(blockers.stTs, i)
            span_remove_start(target, st)
    0

// ============================================================================
// INTRADAY ENGINE (session-based retention via cutoffTs)
// ============================================================================
span_run_intraday_fixed(
    bool   enabled,
    int    startH, int startM,
    int    endH,   int endM,
    span   s,
    string txt,
    bool   makeLabel,
    color  labCol,
    string styleStr,
    color  lnCol,
    int    keepDays,
    int    cutoffTs,
    int    blockStartTs,
    bool   exactStartX1
) =>
    bool enabledEff = enabled and timeframe.isintraday and (keepDays > 0)

    if not enabledEff
        if array.size(s.ln) > 0 or array.size(s.lb) > 0
            clear_span(s)
    else
        if not na(cutoffTs)
            span_trim_since(s, cutoffTs)

        int tEnd = time_close - 1

        int yy0 = year(time, TZ)
        int mo0 = month(time, TZ)
        int dd0 = dayofmonth(time, TZ)

        int yy1 = year(tEnd, TZ)
        int mo1 = month(tEnd, TZ)
        int dd1 = dayofmonth(tEnd, TZ)

        int st0 = timestamp(TZ, yy0, mo0, dd0, startH, startM)
        int st1 = timestamp(TZ, yy1, mo1, dd1, startH, startM)

        bool cross0 = crosses_ts(st0)
        bool cross1 = crosses_ts(st1)

        int st = na
        if cross0
            st := st0
        if not cross0 and cross1
            st := st1

        bool trig      = not na(st)
        bool hasBlock  = not na(blockStartTs)
        bool isBlock   = trig and hasBlock and (st == blockStartTs)
        bool isDup     = trig and (array.size(s.stTs) > 0) and (array.get(s.stTs, 0) == st)

        if hasBlock
            span_remove_start(s, blockStartTs)

        if trig and not isDup and not isBlock
            int   et = calc_end_ts(startH, startM, endH, endM, st)
            float y  = open_at_ts_ltf(st)
            int   x1 = exactStartX1 ? st : time
            if not na(y)
                span_add_fixed(s, x1, st, y, et, txt, makeLabel, labCol, styleStr, lnCol)

        if barstate.islast
            span_sync_styles(s, labCol, styleStr, lnCol)
            if not na(cutoffTs)
                span_trim_since(s, cutoffTs)
            span_trim_to(s, keepDays)
    0

// ============================================================================
// WEEK CUSTOM LINE ENGINE (one line per week; user-defined start/end inside week)
// ============================================================================
span_run_week_custom(
    bool   enabled,
    span   s,
    string txt,
    bool   makeLabel,
    color  labCol,
    string styleStr,
    color  lnCol,
    int    keepW,
    int    ws,
    int    we,
    int    startDow, int startH, int startM,
    int    endDow,   int endH,   int endM
) =>
    bool enabledEff = enabled and (keepW > 0) and (timeframe.isintraday or timeframe.isdaily)

    if not enabledEff
        if array.size(s.ln) > 0 or array.size(s.lb) > 0
            clear_span(s)
    else
        if keepW == 1 and not na(ws)
            span_trim_since(s, ws)

        int yy = year(ws, TZ)
        int mm = month(ws, TZ)
        int dd = dayofmonth(ws, TZ)

        int wsDow = dayofweek(ws, TZ)

        int dS = modPos(startDow - wsDow, 7)
        int dE = modPos(endDow   - wsDow, 7)

        int st = timestamp(TZ, yy, mm, dd + dS, startH, startM)

        bool endWrap = (dE < dS) or (dE == dS and (endH * 60 + endM) <= (startH * 60 + startM))
        int  etRaw   = timestamp(TZ, yy, mm, dd + dE + (endWrap ? 7 : 0), endH, endM)

        int et = na(we) ? etRaw : math.min(etRaw, we)

        bool stInWeek = na(we) ? true : (st >= ws and st < we)
        bool trig     = stInWeek and crosses_ts(st)
        bool isDup    = trig and (array.size(s.stTs) > 0) and (array.get(s.stTs, 0) == st)

        if trig and not isDup
            float y = open_at_ts_ltf(st)
            if not na(y)
                span_add_fixed(s, st, st, y, et, txt, makeLabel, labCol, styleStr, lnCol)
                span_trim_to(s, keepW)

        if barstate.islast
            span_sync_styles(s, labCol, styleStr, lnCol)
            span_trim_to(s, keepW)
    0

// ============================================================================
// INPUTS — INTRADAY (Everything Else)
// ============================================================================
show_0600 = input.bool(true,  "06:00 Session Open", group=groupIntra, inline="D01")
lab_0600  = input.color(color.new(color.rgb(0, 0, 0), 100), "", group=groupIntra, inline="D01")
sty_0600  = input.string("Dotted", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D01")
col_0600  = input.color(color.green, "", group=groupIntra, inline="D01")

show_0730 = input.bool(true,  "07:30 True Session Open", group=groupIntra, inline="D02")
lab_0730  = input.color(color.new(color.rgb(0, 0, 0), 100), "", group=groupIntra, inline="D02")
sty_0730  = input.string("Dotted", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D02")
col_0730  = input.color(color.rgb(163, 24, 36), "", group=groupIntra, inline="D02")

show_0830 = input.bool(false, "08:30 Open", group=groupIntra, inline="D03")
lab_0830  = input.color(color.rgb(242, 54, 69), "", group=groupIntra, inline="D03")
sty_0830  = input.string("Solid", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D03")
col_0830  = input.color(color.rgb(128, 128, 128), "", group=groupIntra, inline="D03")

show_0930 = input.bool(true,  "09:30 NYSE Open", group=groupIntra, inline="D04")
lab_0930  = input.color(color.new(color.rgb(0, 0, 0), 100), "", group=groupIntra, inline="D04")
sty_0930  = input.string("Solid", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D04")
col_0930  = input.color(color.orange, "", group=groupIntra, inline="D04")

show_1000 = input.bool(true,  "10:00 Open", group=groupIntra, inline="D05")
lab_1000  = input.color(color.new(color.rgb(242, 54, 69), 100), "", group=groupIntra, inline="D05")
sty_1000  = input.string("Solid", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D05")
col_1000  = input.color(color.rgb(103, 58, 183), "", group=groupIntra, inline="D05")

show_1800 = input.bool(true,  "18:00 Open", group=groupIntra, inline="D06")
lab_1800  = input.color(color.rgb(0, 0, 0), "", group=groupIntra, inline="D06")
sty_1800  = input.string("Solid", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D06")
col_1800  = input.color(color.rgb(128, 128, 128), "", group=groupIntra, inline="D06")

show_0000 = input.bool(true,  "00:00 Midnight Open", group=groupIntra, inline="D07")
lab_0000  = input.color(color.new(color.rgb(0, 0, 0), 100), "", group=groupIntra, inline="D07")
sty_0000  = input.string("Dotted", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D07")
col_0000  = input.color(color.rgb(0, 0, 0), "", group=groupIntra, inline="D07")

// Custom Intraday (label optional; blank = no label)
show_VAR = input.bool(false, "Custom Intraday", group=groupIntra, inline="D10")
lab_VAR  = input.color(color.new(color.rgb(0, 0, 0), 100), "", group=groupIntra, inline="D10")
sty_VAR  = input.string("Dotted", "", options=["Solid","Dashed","Dotted"], group=groupIntra, inline="D10")
col_VAR  = input.color(color.rgb(0, 150, 136), "", group=groupIntra, inline="D10")

// NOTE: `options` must be a literal list of const strings (cannot use a variable)
varStartStr = input.string("09:30", "Custom Start", group=groupIntra, options=[
 "00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45",
 "04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45",
 "08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45",
 "12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45",
 "16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45",
 "20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"
])

varEndStr = input.string("16:00", "Custom End", group=groupIntra, options=[
 "00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45",
 "04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45",
 "08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45",
 "12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45",
 "16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45",
 "20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"
])

varLabelStr  = input.string("", "Custom Label", group=groupIntra)

int  varSH       = hm_hour(varStartStr)
int  varSM       = hm_min(varStartStr)
int  varEH       = hm_hour(varEndStr)
int  varEM       = hm_min(varEndStr)
bool varMakeLabel = str.length(varLabelStr) > 0

// ============================================================================
// INPUTS — WEEK (Limits + Week Open lines + Custom Week)
// ============================================================================
show_WO = input.bool(true, "Week Open", group=groupWeek, inline="W01")
lab_WO  = input.color(color.rgb(0, 0, 0), "", group=groupWeek, inline="W01")
sty_WO  = input.string("Dashed", "", options=["Solid","Dashed","Dotted"], group=groupWeek, inline="W01")
col_WO  = input.color(color.orange, "", group=groupWeek, inline="W01")

show_TWO = input.bool(true, "True Week Open", group=groupWeek, inline="W02")
lab_TWO  = input.color(color.rgb(0, 0, 0), "", group=groupWeek, inline="W02")
sty_TWO  = input.string("Dashed", "", options=["Solid","Dashed","Dotted"], group=groupWeek, inline="W02")
col_TWO  = input.color(color.rgb(0, 0, 0), "", group=groupWeek, inline="W02")

// Custom Week (copy of custom intraday, but scoped to week retention)
show_WC = input.bool(false, "Custom Week", group=groupWeek, inline="W10")
lab_WC  = input.color(color.new(color.rgb(0, 0, 0), 100), "", group=groupWeek, inline="W10")
sty_WC  = input.string("Dashed", "", options=["Solid","Dashed","Dotted"], group=groupWeek, inline="W10")
col_WC  = input.color(color.rgb(156, 39, 176), "", group=groupWeek, inline="W10")

cwStartDayStr  = input.string("Mon", "Week Start Day", group=groupWeek, options=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"])
cwStartTimeStr = input.string("09:30", "Week Start Time", group=groupWeek, options=[
 "00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45",
 "04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45",
 "08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45",
 "12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45",
 "16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45",
 "20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"
])

cwEndDayStr    = input.string("Fri", "Week End Day", group=groupWeek, options=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"])
cwEndTimeStr   = input.string("16:00", "Week End Time", group=groupWeek, options=[
 "00:00","00:15","00:30","00:45","01:00","01:15","01:30","01:45","02:00","02:15","02:30","02:45","03:00","03:15","03:30","03:45",
 "04:00","04:15","04:30","04:45","05:00","05:15","05:30","05:45","06:00","06:15","06:30","06:45","07:00","07:15","07:30","07:45",
 "08:00","08:15","08:30","08:45","09:00","09:15","09:30","09:45","10:00","10:15","10:30","10:45","11:00","11:15","11:30","11:45",
 "12:00","12:15","12:30","12:45","13:00","13:15","13:30","13:45","14:00","14:15","14:30","14:45","15:00","15:15","15:30","15:45",
 "16:00","16:15","16:30","16:45","17:00","17:15","17:30","17:45","18:00","18:15","18:30","18:45","19:00","19:15","19:30","19:45",
 "20:00","20:15","20:30","20:45","21:00","21:15","21:30","21:45","22:00","22:15","22:30","22:45","23:00","23:15","23:30","23:45"
])

cwLabelStr     = input.string("", "Week Label", group=groupWeek)

int  cwSDow      = dowFromStr(cwStartDayStr)
int  cwEDow      = dowFromStr(cwEndDayStr)
int  cwSH        = hm_hour(cwStartTimeStr)
int  cwSM        = hm_min(cwStartTimeStr)
int  cwEH        = hm_hour(cwEndTimeStr)
int  cwEM        = hm_min(cwEndTimeStr)
bool cwMakeLabel = str.length(cwLabelStr) > 0

// ============================================================================
// STATE
// ============================================================================
var span s_0600 = span_new()
var span s_0730 = span_new()
var span s_0830 = span_new()
var span s_0930 = span_new()
var span s_1000 = span_new()
var span s_1800 = span_new()
var span s_0000 = span_new()
var span s_VAR  = span_new()

var span s_WO  = span_new()
var span s_TWO = span_new()
var span s_WC  = span_new()

// ============================================================================
// SERIES (DAILY + WEEKLY) — keep tuple destructuring on ONE LINE
// ============================================================================
[ds, dOpen, dsD1, dO1, dsD2, dO2, dsD3, dO3, dsD4, dO4, dsD5, dO5, dsD6, dO6, dsD7] = request.security(
        syminfo.tickerid,
        "D",
        [time, open,
         time[1], open[1],
         time[2], open[2],
         time[3], open[3],
         time[4], open[4],
         time[5], open[5],
         time[6], open[6],
         time[7]],
        lookahead=barmerge.lookahead_on
    )

[ws, we, wo] = request.security(
        syminfo.tickerid,
        "W",
        [time, time_close, open],
        lookahead=barmerge.lookahead_on
    )

bool showOnTF     = timeframe.isintraday or timeframe.isdaily
bool weeksEnabled = keepWeeks > 0

// ============================================================================
// INTRADAY CUTOFF (Fix: Intraday=0 must never produce time[-1])
// ============================================================================
int intradayCutoff = na
if keepIntradayDays > 0
    intradayCutoff := ds - (keepIntradayDays - 1) * DAY_MS

// ============================================================================
// TRUE WEEK OPEN (T.W.O) BOOTSTRAP
// - Find the daily session start immediately AFTER ws, even if script loads mid-week
// ============================================================================
int   twoStart = na
float twoOpen  = na

if not na(ws)
    if dsD1 == ws
        twoStart := ds
        twoOpen  := dOpen
    else if dsD2 == ws
        twoStart := dsD1
        twoOpen  := dO1
    else if dsD3 == ws
        twoStart := dsD2
        twoOpen  := dO2
    else if dsD4 == ws
        twoStart := dsD3
        twoOpen  := dO3
    else if dsD5 == ws
        twoStart := dsD4
        twoOpen  := dO4
    else if dsD6 == ws
        twoStart := dsD5
        twoOpen  := dO5
    else if dsD7 == ws
        twoStart := dsD6
        twoOpen  := dO6

// Block 18:00 intraday open ONLY when WO/TWO would overlap
int block1800StartTs = na
if weeksEnabled and showOnTF and show_WO and not na(ws)
    block1800StartTs := ws
if weeksEnabled and showOnTF and show_TWO and not na(twoStart) and (twoStart == ds)
    block1800StartTs := twoStart

// ============================================================================
// RUN INTRADAY SPANS
// ============================================================================
span_run_intraday_fixed(show_0600,  6,  0, 12,  0, s_0600, "06:00", true,  lab_0600, sty_0600, col_0600, keepIntradayDays, intradayCutoff, na,              false)
span_run_intraday_fixed(show_0730,  7, 30, 12,  0, s_0730, "07:30", true,  lab_0730, sty_0730, col_0730, keepIntradayDays, intradayCutoff, na,              false)
span_run_intraday_fixed(show_0830,  8, 30, 12,  0, s_0830, "08:30", true,  lab_0830, sty_0830, col_0830, keepIntradayDays, intradayCutoff, na,              false)
span_run_intraday_fixed(show_0930,  9, 30, 12,  0, s_0930, "09:30", true,  lab_0930, sty_0930, col_0930, keepIntradayDays, intradayCutoff, na,              false)
span_run_intraday_fixed(show_1000, 10,  0, 14,  0, s_1000, "10:00", true,  lab_1000, sty_1000, col_1000, keepIntradayDays, intradayCutoff, na,              false)

span_run_intraday_fixed(show_1800, 18,  0, 18,  0, s_1800, "18:00", true,  lab_1800, sty_1800, col_1800, keepIntradayDays, intradayCutoff, block1800StartTs, false)
span_run_intraday_fixed(show_0000,  0,  0, 18,  0, s_0000, "00:00", true,  lab_0000, sty_0000, col_0000, keepIntradayDays, intradayCutoff, na,              false)

// Custom intraday (label optional; blank => no label)
span_run_intraday_fixed(show_VAR, varSH, varSM, varEH, varEM, s_VAR, varLabelStr, varMakeLabel, lab_VAR, sty_VAR, col_VAR, keepIntradayDays, intradayCutoff, na, true)

// ============================================================================
// WEEK OPEN (W.O) + TRUE WEEK OPEN (T.W.O)
// - Weeks=1 shows ONLY current week (no carryover)
// - Also draws mid-week even if script loads after the week starts
// ============================================================================
if not (weeksEnabled and show_WO and showOnTF)
    if array.size(s_WO.ln) > 0 or array.size(s_WO.lb) > 0
        clear_span(s_WO)
else
    if keepWeeks == 1 and not na(ws)
        span_trim_since(s_WO, ws)

    bool needWO = not na(ws) and not na(we) and not na(wo) and (array.size(s_WO.stTs) == 0 or array.get(s_WO.stTs, 0) != ws)
    if needWO
        array.unshift(s_WO.ln, line.new(ws, wo, we, wo, xloc=xloc.bar_time, extend=extend.none, style=lineStyleFrom(sty_WO), width=L_WIDTH, color=col_WO))
        array.unshift(s_WO.lb, label.new(we, wo, "W.O", xloc=xloc.bar_time, yloc=yloc.price, style=label.style_none, textcolor=lab_WO, size=TEXT_SZ, textalign=text.align_left))
        array.unshift(s_WO.stTs, ws)
        array.unshift(s_WO.endTs, we)
        span_trim_to(s_WO, keepWeeks)

    if barstate.islast
        span_sync_styles(s_WO, lab_WO, sty_WO, col_WO)
        span_trim_to(s_WO, keepWeeks)

if not (weeksEnabled and show_TWO and showOnTF)
    if array.size(s_TWO.ln) > 0 or array.size(s_TWO.lb) > 0
        clear_span(s_TWO)
else
    if keepWeeks == 1 and not na(ws)
        span_trim_since(s_TWO, ws)

    bool needTWO = not na(twoStart) and not na(twoOpen) and not na(we) and (array.size(s_TWO.stTs) == 0 or array.get(s_TWO.stTs, 0) != twoStart)
    if needTWO
        array.unshift(s_TWO.ln, line.new(twoStart, twoOpen, we, twoOpen, xloc=xloc.bar_time, extend=extend.none, style=lineStyleFrom(sty_TWO), width=L_WIDTH, color=col_TWO))
        array.unshift(s_TWO.lb, label.new(we, twoOpen, "T.W.O", xloc=xloc.bar_time, yloc=yloc.price, style=label.style_none, textcolor=lab_TWO, size=TEXT_SZ, textalign=text.align_left))
        array.unshift(s_TWO.stTs, twoStart)
        array.unshift(s_TWO.endTs, we)
        span_trim_to(s_TWO, keepWeeks)

    if barstate.islast
        span_sync_styles(s_TWO, lab_TWO, sty_TWO, col_TWO)
        span_trim_to(s_TWO, keepWeeks)

// ============================================================================
// CUSTOM WEEK
// ============================================================================
if weeksEnabled and show_WC and showOnTF
    span_run_week_custom(show_WC, s_WC, cwLabelStr, cwMakeLabel, lab_WC, sty_WC, col_WC, keepWeeks, ws, we, cwSDow, cwSH, cwSM, cwEDow, cwEH, cwEM)
else
    if array.size(s_WC.ln) > 0 or array.size(s_WC.lb) > 0
        clear_span(s_WC)

// ============================================================================
// Final cleanup: remove 18:00 intraday lines where W.O/T.W.O exists (weeks enabled)
// ============================================================================
if barstate.islast and timeframe.isintraday and showOnTF and show_1800 and weeksEnabled
    if show_WO
        span_remove_by_blockers(s_1800, s_WO)
    if show_TWO
        span_remove_by_blockers(s_1800, s_TWO)
