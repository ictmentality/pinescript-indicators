//@version=6
indicator("QTEngine Test", overlay=true, max_lines_count=500, max_labels_count=500)

import Jaw1312/QTEngine/16 as qt

// -----------------------------------------------------------------------------
// Inputs
// -----------------------------------------------------------------------------
groupCycles = "TIME CYCLES"
showDaily = input.bool(true, "Daily (24h cycle; q=6h)", group=groupCycles)
show90m  = input.bool(true, "90m (6h cycle; q=90m)", group=groupCycles)
showMicro = input.bool(true, "Micro (90m cycle; q=22m30s)", group=groupCycles)
showNano  = input.bool(true, "Nano (22m30s cycle; q=5m37.5s)", group=groupCycles)
showWeekly = input.bool(true, "Weekly (Sun 18:00; q=1d x5)", group=groupCycles)

groupAll = "CYCLE SETTINGS"
showOpens = input.bool(true, "Show Opens", group=groupAll)
keepCycles = input.int(4, "# of Cycles", minval=1, maxval=200, group=groupAll)

q1OpenCol = input.color(color.new(color.rgb(99, 99, 99), 70), "Q1 Open Color", group=groupAll)
q2OpenCol = input.color(color.new(color.rgb(242, 54, 69), 70), "Q2 Open / True Open Color", group=groupAll)
q3OpenCol = input.color(color.new(color.rgb(76, 175, 80), 70), "Q3 Open Color", group=groupAll)
q4OpenCol = input.color(color.new(color.rgb(41, 98, 255), 70), "Q4 Open Color", group=groupAll)

q1OpenStyleStr = input.string("Dashed", "Q1 Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)
q2OpenStyleStr = input.string("Dashed", "Q2 Open / True Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)
q3OpenStyleStr = input.string("Dashed", "Q3 Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)
q4OpenStyleStr = input.string("Dashed", "Q4 Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)

groupDW      = "DATA WINDOW"
dw90mStep1  = input.bool(true, "Step 1 — 90m boundaryTs checks", group=groupDW)
dwMicroStep1 = input.bool(true, "Step 1 — Micro boundaryTs checks", group=groupDW)
dwMicroStep2 = input.bool(true, "Step 2 — Micro QuarterRecord (q1–q4) — minimal", group=groupDW)
dwNanoStep1  = input.bool(true, "Step 1 — Nano boundaryTs checks", group=groupDW)
dwNanoStep2  = input.bool(true, "Step 2 — Nano QuarterRecord (q1–q4) — minimal", group=groupDW)
dwWeekly     = input.bool(false, "Weekly — intent/eff + q1–q5 (minimal)", group=groupDW)

groupDbg = "ALIGNED TF DEBUG"
showAlignedOhlc = input.bool(false, "Show aligned TF OHLC table", group=groupDbg)

groupSSMT = "SSMT TEST (Daily/Weekly ES/NQ)"
showDailyBearSSMT = input.bool(false, "Show Bearish Daily SSMT (Dyad)", group=groupSSMT)
showDailyBullSSMT = input.bool(false, "Show Bullish Daily SSMT (Dyad)", group=groupSSMT)
showWeeklyBearSSMT = input.bool(false, "Show Bearish Weekly SSMT (Dyad)", group=groupSSMT)
showWeeklyBullSSMT = input.bool(false, "Show Bullish Weekly SSMT (Dyad)", group=groupSSMT)
show90mBearSSMT = input.bool(false, "Show Bearish m90 SSMT (Dyad)", group=groupSSMT)
show90mBullSSMT = input.bool(false, "Show Bullish m90 SSMT (Dyad)", group=groupSSMT)
ssmtSymES = input.symbol("MESH2026", "ES / MES", group=groupSSMT)
ssmtSymNQ = input.symbol("MNQH2026", "NQ / MNQ", group=groupSSMT)
ssmtBearLineCol = input.color(color.rgb(242, 54, 69), "Bearish SSMT Color", group=groupSSMT)  // #F23645
ssmtBullLineCol = input.color(color.rgb(41, 98, 255), "Bullish SSMT Color", group=groupSSMT)  // #2962FF
ssmtLineWidth = input.int(1, "SSMT Line Width", minval=1, maxval=4, group=groupSSMT)
ssmtKeep = input.int(5, "SSMT History", minval=0, maxval=50, group=groupSSMT)
ssmtDebug = input.bool(false, "Debug SSMT values", group=groupSSMT)

// -----------------------------------------------------------------------------
// Color palette (Old QT Indicator) + divider opacity rule
// -----------------------------------------------------------------------------
var color COL_Q1 = color.rgb(99, 99, 99)      // #636363
var color COL_Q2 = color.rgb(242, 54, 69)     // #f23645
var color COL_Q3 = color.rgb(76, 175, 80)     // #4caf50
var color COL_Q4 = color.rgb(41, 98, 255)     // #2962ff
var color COL_Q5 = color.rgb(12, 50, 153)     // #0c3299 (weekly Q5)
var int V_TRANSP = 70
f_vcol(color c) =>
    color.new(c, V_TRANSP)

// -----------------------------------------------------------------------------
// Helpers (display-only)
// -----------------------------------------------------------------------------
f_hhmmss(int ts, string tz) =>
    int hh = hour(ts, tz)
    int mm = minute(ts, tz)
    int ss = second(ts, tz)
    float(hh * 10000 + mm * 100 + ss)

f_fmt(float v) =>
    na(v) ? "-" : str.tostring(v)

f_fmt_time(int ts, string tz) =>
    na(ts) ? "-" : str.tostring(f_hhmmss(ts, tz))

f_fmt_ts(int ts, string tz) =>
    na(ts) ? "-" : str.format_time(ts, "yyyy-MM-dd HH:mm", tz)

f_ceil_5s(int ts) =>
    int step = 5 * 1000
    int rem = ts % step
    rem == 0 ? ts : ts + (step - rem)

// -----------------------------------------------------------------------------
// Visibility Alignments (hardcoded)
// Nano  = 5s - 15s
// Micro = 30s - 4m
// 90m   = 5m - 14m
// Daily = 15m - 30m
// -----------------------------------------------------------------------------
int tfSec = timeframe.in_seconds(timeframe.period)
bool visNanoTf = not na(tfSec) and tfSec >= 5 and tfSec <= 15
bool visMicroTf = not na(tfSec) and tfSec >= 30 and tfSec <= 240
bool vis90mTf = not na(tfSec) and tfSec >= 300 and tfSec <= 840
bool visDailyTf = not na(tfSec) and tfSec >= 900 and tfSec <= 1800
bool visWeeklyTf = timeframe.isminutes and timeframe.multiplier >= 60 and timeframe.multiplier <= 180
bool showNanoTf = showNano and visNanoTf
bool showMicroTf = showMicro and visMicroTf
bool show90mTf = show90m and vis90mTf
bool showDailyTf = showDaily and visDailyTf
bool showWeeklyTf = showWeekly and visWeeklyTf

// QTIndicator mapping (string → TradingView style)
lineStyleFrom(string s) =>
    switch s
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        =>          line.style_dotted

f_clamp_int(int v, int lo, int hi) =>
    v < lo ? lo : v > hi ? hi : v

f_pick_qr(int idx, qt.QuarterRecord q1, qt.QuarterRecord q2, qt.QuarterRecord q3, qt.QuarterRecord q4) =>
    qt.QuarterRecord out = q1
    if idx == 2
        out := q2
    else if idx == 3
        out := q3
    else if idx == 4
        out := q4
    out

f_qr_ready(qt.QuarterRecord q) =>
    q.has and not q.isEmpty and not na(q.h) and not na(q.hTs) and not na(q.boundaryTs) and q.hTs >= q.boundaryTs

f_qr_ready_low(qt.QuarterRecord q) =>
    q.has and not q.isEmpty and not na(q.l) and not na(q.lTs) and not na(q.boundaryTs) and q.lTs >= q.boundaryTs

f_ssmt_daily_highs() =>
    var qt.QTConfig cfg = qt.qt_config_default()
    var qt.CycleState st = qt.qt_state_new()
    int t = time
    int tc = time_close
    [st0, d] = qt.qt_daily_update(st, cfg, t, tc)
    st := st0

    qt.QuarterRecord qcur = f_pick_qr(d.curQuarterIndex, d.q1, d.q2, d.q3, d.q4)
    qt.QuarterRecord qprev = d.curQuarterIndex == 1 ? st.daily.prev1 : d.curQuarterIndex == 2 ? d.q1 : d.curQuarterIndex == 3 ? d.q2 : d.q3
    float hcur = f_qr_ready(qcur) ? qcur.h : na
    int   hcurTs = f_qr_ready(qcur) ? qcur.hTs : na
    float hprev = f_qr_ready(qprev) ? qprev.h : na
    int   hprevTs = f_qr_ready(qprev) ? qprev.hTs : na

    int qcurTs = d.q1Ts
    if d.curQuarterIndex == 2
        qcurTs := d.q2Ts
    else if d.curQuarterIndex == 3
        qcurTs := d.q3Ts
    else if d.curQuarterIndex == 4
        qcurTs := d.q4Ts

    [hcur, hcurTs, hprev, hprevTs, d.curQuarterIndex, qcurTs]

f_ssmt_daily_lows() =>
    var qt.QTConfig cfg = qt.qt_config_default()
    var qt.CycleState st = qt.qt_state_new()
    int t = time
    int tc = time_close
    [st0, d] = qt.qt_daily_update(st, cfg, t, tc)
    st := st0

    qt.QuarterRecord qcur = f_pick_qr(d.curQuarterIndex, d.q1, d.q2, d.q3, d.q4)
    qt.QuarterRecord qprev = d.curQuarterIndex == 1 ? st.daily.prev1 : d.curQuarterIndex == 2 ? d.q1 : d.curQuarterIndex == 3 ? d.q2 : d.q3
    float lcur = f_qr_ready_low(qcur) ? qcur.l : na
    int   lcurTs = f_qr_ready_low(qcur) ? qcur.lTs : na
    float lprev = f_qr_ready_low(qprev) ? qprev.l : na
    int   lprevTs = f_qr_ready_low(qprev) ? qprev.lTs : na

    int qcurTs = d.q1Ts
    if d.curQuarterIndex == 2
        qcurTs := d.q2Ts
    else if d.curQuarterIndex == 3
        qcurTs := d.q3Ts
    else if d.curQuarterIndex == 4
        qcurTs := d.q4Ts

    [lcur, lcurTs, lprev, lprevTs, d.curQuarterIndex, qcurTs]


f_ssmt_m90_highs() =>
    var qt.QTConfig cfg = qt.qt_config_default()
    var qt.CycleState st = qt.qt_state_new()
    int t = time
    int tc = time_close
    [st0, m90] = qt.qt_m90_update(st, cfg, t, tc)
    st := st0

    qt.QuarterRecord qcur = f_pick_qr(m90.curQuarterIndex, m90.q1, m90.q2, m90.q3, m90.q4)
    qt.QuarterRecord qprev = m90.curQuarterIndex == 1 ? st.m90.prev1 : m90.curQuarterIndex == 2 ? m90.q1 : m90.curQuarterIndex == 3 ? m90.q2 : m90.q3
    float hcur = f_qr_ready(qcur) ? qcur.h : na
    int   hcurTs = f_qr_ready(qcur) ? qcur.hTs : na
    float hprev = f_qr_ready(qprev) ? qprev.h : na
    int   hprevTs = f_qr_ready(qprev) ? qprev.hTs : na

    int qcurTs = m90.q1Ts
    if m90.curQuarterIndex == 2
        qcurTs := m90.q2Ts
    else if m90.curQuarterIndex == 3
        qcurTs := m90.q3Ts
    else if m90.curQuarterIndex == 4
        qcurTs := m90.q4Ts

    [hcur, hcurTs, hprev, hprevTs, m90.curQuarterIndex, qcurTs]

f_ssmt_m90_lows() =>
    var qt.QTConfig cfg = qt.qt_config_default()
    var qt.CycleState st = qt.qt_state_new()
    int t = time
    int tc = time_close
    [st0, m90] = qt.qt_m90_update(st, cfg, t, tc)
    st := st0

    qt.QuarterRecord qcur = f_pick_qr(m90.curQuarterIndex, m90.q1, m90.q2, m90.q3, m90.q4)
    qt.QuarterRecord qprev = m90.curQuarterIndex == 1 ? st.m90.prev1 : m90.curQuarterIndex == 2 ? m90.q1 : m90.curQuarterIndex == 3 ? m90.q2 : m90.q3
    float lcur = f_qr_ready_low(qcur) ? qcur.l : na
    int   lcurTs = f_qr_ready_low(qcur) ? qcur.lTs : na
    float lprev = f_qr_ready_low(qprev) ? qprev.l : na
    int   lprevTs = f_qr_ready_low(qprev) ? qprev.lTs : na

    int qcurTs = m90.q1Ts
    if m90.curQuarterIndex == 2
        qcurTs := m90.q2Ts
    else if m90.curQuarterIndex == 3
        qcurTs := m90.q3Ts
    else if m90.curQuarterIndex == 4
        qcurTs := m90.q4Ts

    [lcur, lcurTs, lprev, lprevTs, m90.curQuarterIndex, qcurTs]

f_ssmt_weekly_highs() =>
    var qt.QTConfig cfg = qt.qt_config_default()
    var qt.CycleState st = qt.qt_state_new()

    // Local running High tracking for Weekly quarters (q=1d x5), per-symbol inside request.security()
    var int   wLastQStart = na
    var float wCurH = na
    var int   wCurHTs = na
    var float wPrevH = na
    var int   wPrevHTs = na

    int t = time
    int tc = time_close
    [st0, w] = qt.qt_weekly_update(st, cfg, t, tc)
    st := st0

    // Determine the active Weekly quarter by startIntent thresholds (use time_close for boundary attribution)
    int qi = na
    int qts = na
    if not na(w.q1.startIntent) and tc >= w.q1.startIntent
        qi := 1
        qts := w.q1.startIntent
    if not na(w.q2.startIntent) and tc >= w.q2.startIntent
        qi := 2
        qts := w.q2.startIntent
    if not na(w.q3.startIntent) and tc >= w.q3.startIntent
        qi := 3
        qts := w.q3.startIntent
    if not na(w.q4.startIntent) and tc >= w.q4.startIntent
        qi := 4
        qts := w.q4.startIntent
    if not na(w.q5.startIntent) and tc >= w.q5.startIntent
        qi := 5
        qts := w.q5.startIntent

    bool inQ = not na(qi) and not na(qts)
    if inQ
        bool qChanged = na(wLastQStart) or qts != wLastQStart
        if qChanged
            wPrevH := wCurH
            wPrevHTs := wCurHTs
            wCurH := high
            wCurHTs := time
            wLastQStart := qts
        else
            if na(wCurH) or high > wCurH
                wCurH := high
                wCurHTs := time

    [wCurH, wCurHTs, wPrevH, wPrevHTs, qi, qts]


f_ssmt_weekly_lows() =>
    var qt.QTConfig cfg = qt.qt_config_default()
    var qt.CycleState st = qt.qt_state_new()

    // Local running Low tracking for Weekly quarters (q=1d x5), per-symbol inside request.security()
    var int   wLastQStart = na
    var float wCurL = na
    var int   wCurLTs = na
    var float wPrevL = na
    var int   wPrevLTs = na

    int t = time
    int tc = time_close
    [st0, w] = qt.qt_weekly_update(st, cfg, t, tc)
    st := st0

    // Determine the active Weekly quarter by startIntent thresholds (use time_close for boundary attribution)
    int qi = na
    int qts = na
    if not na(w.q1.startIntent) and tc >= w.q1.startIntent
        qi := 1
        qts := w.q1.startIntent
    if not na(w.q2.startIntent) and tc >= w.q2.startIntent
        qi := 2
        qts := w.q2.startIntent
    if not na(w.q3.startIntent) and tc >= w.q3.startIntent
        qi := 3
        qts := w.q3.startIntent
    if not na(w.q4.startIntent) and tc >= w.q4.startIntent
        qi := 4
        qts := w.q4.startIntent
    if not na(w.q5.startIntent) and tc >= w.q5.startIntent
        qi := 5
        qts := w.q5.startIntent

    bool inQ = not na(qi) and not na(qts)
    if inQ
        bool qChanged = na(wLastQStart) or qts != wLastQStart
        if qChanged
            wPrevL := wCurL
            wPrevLTs := wCurLTs
            wCurL := na
            wCurLTs := na
            wLastQStart := qts

        if na(wCurL) or low < wCurL
            wCurL := low
            wCurLTs := time

    [wCurL, wCurLTs, wPrevL, wPrevLTs, qi, qts]

f_ssmt_sym_ticker(string sym) =>
    string s = str.upper(sym)
    string[] parts = str.split(s, ":")
    array.size(parts) > 1 ? array.get(parts, array.size(parts) - 1) : s

f_ssmt_norm_sym(string sym) =>
    syminfo.type == "futures" ? ticker.modify(sym, session=syminfo.session) : sym

f_ssmt_tag(string sym) =>
    string s = f_ssmt_sym_ticker(sym)
    string tag = s
    if str.contains(s, "MES")
        tag := "ES"
    else if str.contains(s, "MNQ")
        tag := "NQ"
    else if str.contains(s, "MYM")
        tag := "YM"
    else if str.contains(s, "ES")
        tag := "ES"
    else if str.contains(s, "NQ")
        tag := "NQ"
    else if str.contains(s, "YM")
        tag := "YM"
    tag

f_ssmt_hist_push(line ln, label lb, line[] lines, label[] labels, int maxN) =>
    if not na(ln) or not na(lb)
        if maxN <= 0
            if not na(ln)
                line.delete(ln)
            if not na(lb)
                label.delete(lb)
        else
            array.push(lines, ln)
            array.push(labels, lb)
            while array.size(lines) > maxN
                line oldLn = array.shift(lines)
                if not na(oldLn)
                    line.delete(oldLn)
                label oldLb = array.shift(labels)
                if not na(oldLb)
                    label.delete(oldLb)
    0

f_ssmt_hist_trim(line[] lines, label[] labels, int maxN) =>
    while array.size(lines) > maxN
        line oldLn = array.shift(lines)
        if not na(oldLn)
            line.delete(oldLn)
        label oldLb = array.shift(labels)
        if not na(oldLb)
            label.delete(oldLb)
    while array.size(labels) > maxN
        label oldLb = array.shift(labels)
        if not na(oldLb)
            label.delete(oldLb)
    0

f_ssmt_hist_clear(line[] lines, label[] labels) =>
    while array.size(lines) > 0
        line oldLn = array.shift(lines)
        if not na(oldLn)
            line.delete(oldLn)
    while array.size(labels) > 0
        label oldLb = array.shift(labels)
        if not na(oldLb)
            label.delete(oldLb)
    0

// -----------------------------------------------------------------------------
// Array helpers
// -----------------------------------------------------------------------------
f_find_int(int[] arr, int v) =>
    int idx = -1
    int i = array.size(arr) - 1
    while i >= 0 and idx == -1
        if array.get(arr, i) == v
            idx := i
        i -= 1
    idx

f_push_unique_int(int[] arr, int v, int maxN) =>
    if f_find_int(arr, v) == -1
        array.push(arr, v)
        while array.size(arr) > maxN
            array.shift(arr)
    0

// -----------------------------------------------------------------------------
// Old-QT vertical divider line storage helpers
// -----------------------------------------------------------------------------
type vset
    line[] ln
    int[]  ts

vset_new() =>
    vset.new(array.new_line(), array.new_int())

vset_clear(vset s) =>
    int i = array.size(s.ln) - 1
    while i >= 0
        line.delete(array.get(s.ln, i))
        i -= 1
    array.clear(s.ln)
    array.clear(s.ts)
    0

vset_has(vset s, int ts) =>
    bool found = false
    int i = array.size(s.ts) - 1
    while i >= 0 and not found
        found := array.get(s.ts, i) == ts
        i -= 1
    found

vset_add(vset s, int ts, color c) =>
    if not vset_has(s, ts)
        array.push(s.ln, line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c)))
        array.push(s.ts, ts)
    0

vset_trim_since(vset s, int cutoffTs) =>
    int i = array.size(s.ts) - 1
    while i >= 0
        int t = array.get(s.ts, i)
        if t < cutoffTs
            line ln = array.remove(s.ln, i)
            line.delete(ln)
            array.remove(s.ts, i)
        i -= 1
    0

f_set_or_make_vline(line ln, int ts, color c) =>
    line out = ln
    if na(out)
        out := line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c))
    else
        line.set_xy1(out, ts, low)
        line.set_xy2(out, ts, high)
        line.set_style(out, line.style_solid)
        line.set_width(out, 1)
        line.set_color(out, f_vcol(c))
    out

f_set_or_make_vline_raw(line ln, int ts, color c, int w) =>
    line out = ln
    if na(out)
        out := line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=w, color=c)
    else
        line.set_xy1(out, ts, low)
        line.set_xy2(out, ts, high)
        line.set_extend(out, extend.both)
        line.set_style(out, line.style_solid)
        line.set_width(out, w)
        line.set_color(out, c)
    out

f_set_or_make_line(line ln, int x1, float y1, int x2, float y2, color c, int w) =>
    line out = ln
    if na(out)
        out := line.new(x1, y1, x2, y2, xloc=xloc.bar_time, extend=extend.none, style=line.style_solid, width=w, color=c)
    else
        line.set_xy1(out, x1, y1)
        line.set_xy2(out, x2, y2)
        line.set_extend(out, extend.none)
        line.set_style(out, line.style_solid)
        line.set_width(out, w)
        line.set_color(out, c)
    out

f_set_or_make_hline(line ln, int x1, int x2, float y, color c, sty) =>
    line out = ln
    if na(out)
        out := line.new(x1, y, x2, y, xloc=xloc.bar_time, extend=extend.none, style=sty, width=1, color=c)
    else
        line.set_xy1(out, x1, y)
        line.set_xy2(out, x2, y)
        line.set_extend(out, extend.none)
        line.set_style(out, sty)
        line.set_width(out, 1)
        line.set_color(out, c)
    out

f_set_or_make_hline_w(line ln, int x1, int x2, float y, color c, sty, int w) =>
    line out = ln
    if na(out)
        out := line.new(x1, y, x2, y, xloc=xloc.bar_time, extend=extend.none, style=sty, width=w, color=c)
    else
        line.set_xy1(out, x1, y)
        line.set_xy2(out, x2, y)
        line.set_extend(out, extend.none)
        line.set_style(out, sty)
        line.set_width(out, w)
        line.set_color(out, c)
    out

f_kill(line ln) =>
    line out = na
    if not na(ln)
        line.delete(ln)
    out

// -----------------------------------------------------------------------------
// QT Core update (Daily + 90m + Micro + Nano)
// -----------------------------------------------------------------------------
var qt.QTConfig   cfg = qt.qt_config_default()
var qt.CycleState st  = qt.qt_state_new()

int t  = time
int tc = time_close

[st0, d] = qt.qt_daily_update(st, cfg, t, tc)
[st1, m90] = qt.qt_m90_update(st0, cfg, t, tc)
[st2, m] = qt.qt_micro_update(st1, cfg, t, tc)
[st3, n] = qt.qt_nano_update(st2, cfg, t, tc)
[st4, w] = qt.qt_weekly_update(st3, cfg, t, tc)
st := st4

[m_aq1, m_aq2, m_aq3, m_aq4] = qt.qt_micro_aligned_qr_debug(st)
[n_aq1, n_aq2, n_aq3, n_aq4] = qt.qt_nano_aligned_qr_debug(st)
qt.QuarterRecord m90_q = f_pick_qr(m90.curQuarterIndex, m90.q1, m90.q2, m90.q3, m90.q4)
qt.QuarterRecord m_q = f_pick_qr(m.curQuarterIndex, m.q1, m.q2, m.q3, m.q4)
qt.QuarterRecord n_q = f_pick_qr(n.curQuarterIndex, n.q1, n.q2, n.q3, n.q4)

// -----------------------------------------------------------------------------
// Data Window — Step 1: boundaryTs checks
// -----------------------------------------------------------------------------
plot(show90mTf and dw90mStep1 ? m90.q1Ts : na, "90m q1Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? m90.q2Ts : na, "90m q2Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? m90.q3Ts : na, "90m q3Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? m90.q4Ts : na, "90m q4Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? (m90.q2Realized ? 1.0 : 0.0) : na, "90m q2Realized", display=display.data_window)
plot(show90mTf and dw90mStep1 ? (m90.q3Realized ? 1.0 : 0.0) : na, "90m q3Realized", display=display.data_window)
plot(show90mTf and dw90mStep1 ? (m90.q4Realized ? 1.0 : 0.0) : na, "90m q4Realized", display=display.data_window)

plot(showMicroTf and dwMicroStep1 ? m.q1Ts : na, "Micro q1Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? m.q2Ts : na, "Micro q2Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? m.q3Ts : na, "Micro q3Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? m.q4Ts : na, "Micro q4Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? (m.q2Realized ? 1.0 : 0.0) : na, "Micro q2Realized", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? (m.q3Realized ? 1.0 : 0.0) : na, "Micro q3Realized", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? (m.q4Realized ? 1.0 : 0.0) : na, "Micro q4Realized", display=display.data_window)

plot(showNanoTf and dwNanoStep1 ? n.q1Ts : na, "Nano q1Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? n.q2Ts : na, "Nano q2Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? n.q3Ts : na, "Nano q3Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? n.q4Ts : na, "Nano q4Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? (n.q2Realized ? 1.0 : 0.0) : na, "Nano q2Realized", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? (n.q3Realized ? 1.0 : 0.0) : na, "Nano q3Realized", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? (n.q4Realized ? 1.0 : 0.0) : na, "Nano q4Realized", display=display.data_window)

// -----------------------------------------------------------------------------
// Data Window — Step 2: QuarterRecord (minimal)
// -----------------------------------------------------------------------------
float m_q1_o_hhmmss = f_hhmmss(m.q1.oTs, cfg.tz)
float m_q2_o_hhmmss = f_hhmmss(m.q2.oTs, cfg.tz)
float m_q3_o_hhmmss = f_hhmmss(m.q3.oTs, cfg.tz)
float m_q4_o_hhmmss = f_hhmmss(m.q4.oTs, cfg.tz)

plot(showMicroTf and dwMicroStep2 ? m.q1.o : na, "Micro QR q1.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q1.h : na, "Micro QR q1.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q1.l : na, "Micro QR q1.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q1.c : na, "Micro QR q1.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q1_o_hhmmss : na, "Micro QR q1.oTs (HHMMSS)", display=display.data_window)

plot(showMicroTf and dwMicroStep2 ? m.q2.o : na, "Micro QR q2.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q2.h : na, "Micro QR q2.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q2.l : na, "Micro QR q2.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q2.c : na, "Micro QR q2.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q2_o_hhmmss : na, "Micro QR q2.oTs (HHMMSS)", display=display.data_window)

plot(showMicroTf and dwMicroStep2 ? m.q3.o : na, "Micro QR q3.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q3.h : na, "Micro QR q3.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q3.l : na, "Micro QR q3.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q3.c : na, "Micro QR q3.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q3_o_hhmmss : na, "Micro QR q3.oTs (HHMMSS)", display=display.data_window)

plot(showMicroTf and dwMicroStep2 ? m.q4.o : na, "Micro QR q4.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q4.h : na, "Micro QR q4.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q4.l : na, "Micro QR q4.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q4.c : na, "Micro QR q4.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q4_o_hhmmss : na, "Micro QR q4.oTs (HHMMSS)", display=display.data_window)

float n_q1_o_hhmmss = f_hhmmss(n.q1.oTs, cfg.tz)
float n_q2_o_hhmmss = f_hhmmss(n.q2.oTs, cfg.tz)
float n_q3_o_hhmmss = f_hhmmss(n.q3.oTs, cfg.tz)
float n_q4_o_hhmmss = f_hhmmss(n.q4.oTs, cfg.tz)

[nano_o5, nano_ts5, nano_qi5, nano_qcurts5] = qt.qt_nano_open_debug()
float nano_ts5_hhmmss = f_hhmmss(nano_ts5, cfg.tz)
float nano_qcurts5_hhmmss = f_hhmmss(nano_qcurts5, cfg.tz)
float nano_target_delta = not na(nano_ts5) and not na(nano_qcurts5) ? (nano_ts5 - f_ceil_5s(nano_qcurts5)) / 1000.0 : na

int n_qcurts_engine = n.curQuarterIndex == 1 ? n.q1Ts : n.curQuarterIndex == 2 ? n.q2Ts : n.curQuarterIndex == 3 ? n.q3Ts : n.q4Ts
float n_qcurts_delta = not na(n_qcurts_engine) and not na(nano_qcurts5) ? (nano_qcurts5 - n_qcurts_engine) / 1000.0 : na

int n_q1_target = f_ceil_5s(n.q1Ts)
int n_q2_target = f_ceil_5s(n.q2Ts)
int n_q3_target = f_ceil_5s(n.q3Ts)
int n_q4_target = f_ceil_5s(n.q4Ts)

float n_q1_target_hhmmss = f_hhmmss(n_q1_target, cfg.tz)
float n_q2_target_hhmmss = f_hhmmss(n_q2_target, cfg.tz)
float n_q3_target_hhmmss = f_hhmmss(n_q3_target, cfg.tz)
float n_q4_target_hhmmss = f_hhmmss(n_q4_target, cfg.tz)

float n_q1_open_delta = not na(n.q1.oTs) ? (n.q1.oTs - n_q1_target) / 1000.0 : na
float n_q2_open_delta = not na(n.q2.oTs) ? (n.q2.oTs - n_q2_target) / 1000.0 : na
float n_q3_open_delta = not na(n.q3.oTs) ? (n.q3.oTs - n_q3_target) / 1000.0 : na
float n_q4_open_delta = not na(n.q4.oTs) ? (n.q4.oTs - n_q4_target) / 1000.0 : na

// -----------------------------------------------------------------------------
// Aligned TF OHLC (read-only debug)
// -----------------------------------------------------------------------------
var table aligned_tbl = na
if showAlignedOhlc and barstate.islast
    if na(aligned_tbl)
        aligned_tbl := table.new(position.top_right, 4, 12, border_width=1, border_color=color.gray)
    table.cell(aligned_tbl, 0, 0, "Field", text_color=color.black, bgcolor=color.new(color.black, 60))
    table.cell(aligned_tbl, 1, 0, "90m 5m", text_color=color.black, bgcolor=color.new(color.black, 60))
    table.cell(aligned_tbl, 2, 0, "Micro 30s", text_color=color.black, bgcolor=color.new(color.black, 60))
    table.cell(aligned_tbl, 3, 0, "Nano 5s", text_color=color.black, bgcolor=color.new(color.black, 60))

    [m90_a_o, m90_a_h, m90_a_l, m90_a_c, m90_a_t] = qt.qt_m90_aligned_ohlc_debug()
    [m_a_o, m_a_h, m_a_l, m_a_c, m_a_t] = qt.qt_micro_aligned_ohlc_debug()
    [n_a_o, n_a_h, n_a_l, n_a_c, n_a_t] = qt.qt_nano_aligned_ohlc_debug()

    table.cell(aligned_tbl, 0, 1, "O", text_color=color.black)
    table.cell(aligned_tbl, 1, 1, f_fmt(m90_a_o), text_color=color.black)
    table.cell(aligned_tbl, 2, 1, f_fmt(m_a_o), text_color=color.black)
    table.cell(aligned_tbl, 3, 1, f_fmt(n_a_o), text_color=color.black)

    table.cell(aligned_tbl, 0, 2, "H", text_color=color.black)
    table.cell(aligned_tbl, 1, 2, f_fmt(m90_a_h), text_color=color.black)
    table.cell(aligned_tbl, 2, 2, f_fmt(m_a_h), text_color=color.black)
    table.cell(aligned_tbl, 3, 2, f_fmt(n_a_h), text_color=color.black)

    table.cell(aligned_tbl, 0, 3, "L", text_color=color.black)
    table.cell(aligned_tbl, 1, 3, f_fmt(m90_a_l), text_color=color.black)
    table.cell(aligned_tbl, 2, 3, f_fmt(m_a_l), text_color=color.black)
    table.cell(aligned_tbl, 3, 3, f_fmt(n_a_l), text_color=color.black)

    table.cell(aligned_tbl, 0, 4, "C", text_color=color.black)
    table.cell(aligned_tbl, 1, 4, f_fmt(m90_a_c), text_color=color.black)
    table.cell(aligned_tbl, 2, 4, f_fmt(m_a_c), text_color=color.black)
    table.cell(aligned_tbl, 3, 4, f_fmt(n_a_c), text_color=color.black)

    table.cell(aligned_tbl, 0, 5, "T", text_color=color.black)
    table.cell(aligned_tbl, 1, 5, f_fmt_time(m90_a_t, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 2, 5, f_fmt_time(m_a_t, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 3, 5, f_fmt_time(n_a_t, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 0, 6, "Qi", text_color=color.black)
    table.cell(aligned_tbl, 1, 6, str.tostring(m90.curQuarterIndex), text_color=color.black)
    table.cell(aligned_tbl, 2, 6, str.tostring(m.curQuarterIndex), text_color=color.black)
    table.cell(aligned_tbl, 3, 6, str.tostring(n.curQuarterIndex), text_color=color.black)
    table.cell(aligned_tbl, 0, 7, "QO", text_color=color.black)
    table.cell(aligned_tbl, 1, 7, f_fmt(m90_q.o), text_color=color.black)
    table.cell(aligned_tbl, 2, 7, f_fmt(m_q.o), text_color=color.black)
    table.cell(aligned_tbl, 3, 7, f_fmt(n_q.o), text_color=color.black)
    table.cell(aligned_tbl, 0, 8, "QH", text_color=color.black)
    table.cell(aligned_tbl, 1, 8, f_fmt(m90_q.h), text_color=color.black)
    table.cell(aligned_tbl, 2, 8, f_fmt(m_q.h), text_color=color.black)
    table.cell(aligned_tbl, 3, 8, f_fmt(n_q.h), text_color=color.black)
    table.cell(aligned_tbl, 0, 9, "QL", text_color=color.black)
    table.cell(aligned_tbl, 1, 9, f_fmt(m90_q.l), text_color=color.black)
    table.cell(aligned_tbl, 2, 9, f_fmt(m_q.l), text_color=color.black)
    table.cell(aligned_tbl, 3, 9, f_fmt(n_q.l), text_color=color.black)
    table.cell(aligned_tbl, 0, 10, "QC", text_color=color.black)
    table.cell(aligned_tbl, 1, 10, f_fmt(m90_q.c), text_color=color.black)
    table.cell(aligned_tbl, 2, 10, f_fmt(m_q.c), text_color=color.black)
    table.cell(aligned_tbl, 3, 10, f_fmt(n_q.c), text_color=color.black)
    table.cell(aligned_tbl, 0, 11, "QT", text_color=color.black)
    table.cell(aligned_tbl, 1, 11, f_fmt_time(m90_q.oTs, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 2, 11, f_fmt_time(m_q.oTs, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 3, 11, f_fmt_time(n_q.oTs, cfg.tz), text_color=color.black)
else if not showAlignedOhlc and not na(aligned_tbl)
    table.delete(aligned_tbl)
    aligned_tbl := na

plot(showNanoTf and dwNanoStep2 ? n.q1.o : na, "Nano QR q1.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q1.h : na, "Nano QR q1.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q1.l : na, "Nano QR q1.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q1.c : na, "Nano QR q1.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q1_o_hhmmss : na, "Nano QR q1.oTs (HHMMSS)", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? nano_target_delta : na, "Nano 5s open delta (sec)", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_qcurts_delta : na, "Nano qCurTs mismatch (sec)", display=display.data_window)

plot(showNanoTf and dwNanoStep2 ? n.q2.o : na, "Nano QR q2.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q2.h : na, "Nano QR q2.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q2.l : na, "Nano QR q2.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q2.c : na, "Nano QR q2.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q2_o_hhmmss : na, "Nano QR q2.oTs (HHMMSS)", display=display.data_window)

plot(showNanoTf and dwNanoStep2 ? n.q3.o : na, "Nano QR q3.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q3.h : na, "Nano QR q3.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q3.l : na, "Nano QR q3.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q3.c : na, "Nano QR q3.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q3_o_hhmmss : na, "Nano QR q3.oTs (HHMMSS)", display=display.data_window)

plot(showNanoTf and dwNanoStep2 ? n.q4.o : na, "Nano QR q4.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q4.h : na, "Nano QR q4.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q4.l : na, "Nano QR q4.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q4.c : na, "Nano QR q4.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q4_o_hhmmss : na, "Nano QR q4.oTs (HHMMSS)", display=display.data_window)

// -----------------------------------------------------------------------------
// Weekly debug table (avoids plot limit)
// -----------------------------------------------------------------------------
var table weekly_tbl = na
if dwWeekly and barstate.islast
    if na(weekly_tbl)
        weekly_tbl := table.new(position.top_right, 6, 13, border_width=1, border_color=color.gray)
    table.cell(weekly_tbl, 0, 0, "Field", text_color=color.black, bgcolor=color.new(color.black, 85))
    table.cell(weekly_tbl, 1, 0, "Q1", text_color=color.black, bgcolor=color.new(color.black, 85))
    table.cell(weekly_tbl, 2, 0, "Q2", text_color=color.black, bgcolor=color.new(color.black, 85))
    table.cell(weekly_tbl, 3, 0, "Q3", text_color=color.black, bgcolor=color.new(color.black, 85))
    table.cell(weekly_tbl, 4, 0, "Q4", text_color=color.black, bgcolor=color.new(color.black, 85))
    table.cell(weekly_tbl, 5, 0, "Q5", text_color=color.black, bgcolor=color.new(color.black, 85))

    table.cell(weekly_tbl, 0, 1, "wsIntent", text_color=color.black)
    table.cell(weekly_tbl, 1, 1, f_fmt_ts(w.wsIntent, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 0, 2, "wsEff", text_color=color.black)
    table.cell(weekly_tbl, 1, 2, f_fmt_ts(w.wsEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 0, 3, "wsNextIntent", text_color=color.black)
    table.cell(weekly_tbl, 1, 3, f_fmt_ts(w.wsNextIntent, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 0, 4, "wsNextEff", text_color=color.black)
    table.cell(weekly_tbl, 1, 4, f_fmt_ts(w.wsNextEff, cfg.tz), text_color=color.black)

    table.cell(weekly_tbl, 0, 5, "startIntent", text_color=color.black)
    table.cell(weekly_tbl, 1, 5, f_fmt_ts(w.q1.startIntent, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 2, 5, f_fmt_ts(w.q2.startIntent, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 3, 5, f_fmt_ts(w.q3.startIntent, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 4, 5, f_fmt_ts(w.q4.startIntent, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 5, 5, f_fmt_ts(w.q5.startIntent, cfg.tz), text_color=color.black)

    table.cell(weekly_tbl, 0, 6, "startEff", text_color=color.black)
    table.cell(weekly_tbl, 1, 6, f_fmt_ts(w.q1.startEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 2, 6, f_fmt_ts(w.q2.startEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 3, 6, f_fmt_ts(w.q3.startEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 4, 6, f_fmt_ts(w.q4.startEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 5, 6, f_fmt_ts(w.q5.startEff, cfg.tz), text_color=color.black)

    table.cell(weekly_tbl, 0, 7, "endEff", text_color=color.black)
    table.cell(weekly_tbl, 1, 7, f_fmt_ts(w.q1.endEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 2, 7, f_fmt_ts(w.q2.endEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 3, 7, f_fmt_ts(w.q3.endEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 4, 7, f_fmt_ts(w.q4.endEff, cfg.tz), text_color=color.black)
    table.cell(weekly_tbl, 5, 7, f_fmt_ts(w.q5.endEff, cfg.tz), text_color=color.black)

    table.cell(weekly_tbl, 0, 8, "open", text_color=color.black)
    table.cell(weekly_tbl, 1, 8, f_fmt(w.q1.open), text_color=color.black)
    table.cell(weekly_tbl, 2, 8, f_fmt(w.q2.open), text_color=color.black)
    table.cell(weekly_tbl, 3, 8, f_fmt(w.q3.open), text_color=color.black)
    table.cell(weekly_tbl, 4, 8, f_fmt(w.q4.open), text_color=color.black)
    table.cell(weekly_tbl, 5, 8, f_fmt(w.q5.open), text_color=color.black)

    table.cell(weekly_tbl, 0, 9, "hasData", text_color=color.black)
    table.cell(weekly_tbl, 1, 9, w.q1.hasData ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 2, 9, w.q2.hasData ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 3, 9, w.q3.hasData ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 4, 9, w.q4.hasData ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 5, 9, w.q5.hasData ? "Y" : "N", text_color=color.black)

    table.cell(weekly_tbl, 0, 10, "openDelayed", text_color=color.black)
    table.cell(weekly_tbl, 1, 10, w.q1.openDelayed ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 2, 10, w.q2.openDelayed ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 3, 10, w.q3.openDelayed ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 4, 10, w.q4.openDelayed ? "Y" : "N", text_color=color.black)
    table.cell(weekly_tbl, 5, 10, w.q5.openDelayed ? "Y" : "N", text_color=color.black)
else if not dwWeekly and not na(weekly_tbl)
    table.delete(weekly_tbl)
    weekly_tbl := na

// -----------------------------------------------------------------------------
// Bearish Daily SSMT (ES/NQ) — test-only
// Visibility: Only show on Daily-aligned TFs (m15–m30 per helpers/Alignments.txt)
// -----------------------------------------------------------------------------
var table ssmtDbgTbl = na
var line[] ssmtHistLines = array.new_line()
var label[] ssmtHistLbls = array.new_label()
var line ssmtLine = na
var int  ssmtEventKey = na
var label ssmtLbl = na
var int  ssmtExtendTier = 0
int SSmtQLen = 6 * 60 * 60 * 1000

bool ssmtTfOk = visDailyTf
if showDailyBearSSMT and ssmtTfOk
    string esSym = f_ssmt_norm_sym(ssmtSymES)
    string nqSym = f_ssmt_norm_sym(ssmtSymNQ)

    [esHcur, esHcurTs, esHprev, esHprevTs, esQi, esQts] = request.security(esSym, timeframe.period, f_ssmt_daily_highs(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)
    [nqHcur, nqHcurTs, nqHprev, nqHprevTs, nqQi, nqQts] = request.security(nqSym, timeframe.period, f_ssmt_daily_highs(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)

    string chartTag = f_ssmt_tag(syminfo.tickerid)
    bool isChartES = chartTag == "ES"
    bool isChartNQ = chartTag == "NQ"
    bool isPairChart = isChartES or isChartNQ

    bool ssmtReady = not na(esHcur) and not na(esHprev) and not na(nqHcur) and not na(nqHprev)
    if ssmtDebug and barstate.islast
        if na(ssmtDbgTbl)
            ssmtDbgTbl := table.new(position.top_right, 4, 4, border_width=1, border_color=color.gray)
        table.cell(ssmtDbgTbl, 0, 0, "Sym", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtDbgTbl, 1, 0, "Hprev", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtDbgTbl, 2, 0, "Hcur", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtDbgTbl, 3, 0, "Sweep", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtDbgTbl, 0, 1, f_ssmt_tag(ssmtSymES), text_color=color.black)
        table.cell(ssmtDbgTbl, 1, 1, f_fmt(esHprev), text_color=color.black)
        table.cell(ssmtDbgTbl, 2, 1, f_fmt(esHcur), text_color=color.black)
        table.cell(ssmtDbgTbl, 3, 1, esHcur > esHprev ? "Y" : "N", text_color=color.black)
        table.cell(ssmtDbgTbl, 0, 2, f_ssmt_tag(ssmtSymNQ), text_color=color.black)
        table.cell(ssmtDbgTbl, 1, 2, f_fmt(nqHprev), text_color=color.black)
        table.cell(ssmtDbgTbl, 2, 2, f_fmt(nqHcur), text_color=color.black)
        table.cell(ssmtDbgTbl, 3, 2, nqHcur > nqHprev ? "Y" : "N", text_color=color.black)
        table.cell(ssmtDbgTbl, 0, 3, "QStart", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtDbgTbl, 1, 3, f_fmt_time(esQts, cfg.tz), text_color=color.black)
        table.cell(ssmtDbgTbl, 2, 3, f_fmt_time(nqQts, cfg.tz), text_color=color.black)
        table.cell(ssmtDbgTbl, 3, 3, "", text_color=color.black)
    else if not ssmtDebug and not na(ssmtDbgTbl)
        table.delete(ssmtDbgTbl)
        ssmtDbgTbl := na

    if ssmtReady
        bool esSweep = esHcur > esHprev
        bool nqSweep = nqHcur > nqHprev
        bool split = esSweep != nqSweep

        bool crackedES = split and (not esSweep)
        bool crackedNQ = split and (not nqSweep)
        string cracked = ""
        if crackedES
            cracked := "ES"
        if crackedNQ
            cracked := cracked == "" ? "NQ" : cracked + ",NQ"

        float curH = na
        int   curHTs = na
        float prevH = na
        int   prevHTs = na
        int   curQTs = na
        bool  curSweep = false
        if isChartES
            curH := esHcur
            curHTs := esHcurTs
            prevH := esHprev
            prevHTs := esHprevTs
            curQTs := esQts
            curSweep := esSweep
        else if isChartNQ
            curH := nqHcur
            curHTs := nqHcurTs
            prevH := nqHprev
            prevHTs := nqHprevTs
            curQTs := nqQts
            curSweep := nqSweep

        int eventKey = prevHTs
        bool eventChanged = not na(eventKey) and (na(ssmtEventKey) or eventKey != ssmtEventKey)
        if eventChanged
            f_ssmt_hist_push(ssmtLine, ssmtLbl, ssmtHistLines, ssmtHistLbls, ssmtKeep)
            ssmtLine := na
            ssmtLbl := na
            ssmtExtendTier := 0
            ssmtEventKey := eventKey

        if not split or not isPairChart
            if not na(ssmtLine)
                line.delete(ssmtLine)
                ssmtLine := na
            if not na(ssmtLbl)
                label.delete(ssmtLbl)
                ssmtLbl := na
            ssmtExtendTier := 0
        else
            bool hasPoints = not na(prevH) and not na(prevHTs) and not na(curQTs)
            if hasPoints and curSweep
                int thirdLen = int(SSmtQLen / 3)
                int q1End = curQTs + thirdLen
                int q2End = curQTs + (thirdLen * 2)
                int q3End = curQTs + SSmtQLen

                int sweepTier = 1
                if not na(curHTs)
                    if curHTs >= q2End
                        sweepTier := 3
                    else if curHTs >= q1End
                        sweepTier := 2

                int barTier = 1
                if time_close >= q2End
                    barTier := 3
                else if time_close >= q1End
                    barTier := 2

                ssmtExtendTier := ssmtExtendTier < sweepTier ? sweepTier : ssmtExtendTier
                bool touch = high >= prevH
                if touch
                    ssmtExtendTier := ssmtExtendTier < barTier ? barTier : ssmtExtendTier

                int x2 = q1End
                if ssmtExtendTier >= 3
                    x2 := q3End
                else if ssmtExtendTier == 2
                    x2 := q2End

                ssmtLine := f_set_or_make_hline_w(ssmtLine, prevHTs, x2, prevH, color.new(ssmtBearLineCol, 50), line.style_solid, ssmtLineWidth)
            else if hasPoints and not curSweep and not na(curH) and not na(curHTs)
                ssmtLine := f_set_or_make_line(ssmtLine, prevHTs, prevH, curHTs, curH, color.new(ssmtBearLineCol, 50), ssmtLineWidth)

            bool showLabel = (isChartES and crackedES) or (isChartNQ and crackedNQ)
            if hasPoints and cracked != "" and showLabel
                string lblText = "D " + cracked
                if na(ssmtLbl)
                    ssmtLbl := label.new(prevHTs, prevH, lblText, xloc=xloc.bar_time, style=label.style_label_left, textcolor=color.black, color=color.new(color.black, 100), size=size.tiny)
                else
                    label.set_xy(ssmtLbl, prevHTs, prevH)
                    label.set_text(ssmtLbl, lblText)
                    label.set_textcolor(ssmtLbl, color.black)
                    label.set_color(ssmtLbl, color.new(color.black, 100))
            else if not showLabel and not na(ssmtLbl)
                label.delete(ssmtLbl)
                ssmtLbl := na
    f_ssmt_hist_trim(ssmtHistLines, ssmtHistLbls, ssmtKeep)
else
    if not na(ssmtLine)
        line.delete(ssmtLine)
        ssmtLine := na
    if not na(ssmtLbl)
        label.delete(ssmtLbl)
        ssmtLbl := na
    f_ssmt_hist_clear(ssmtHistLines, ssmtHistLbls)
    if not na(ssmtDbgTbl)
        table.delete(ssmtDbgTbl)
        ssmtDbgTbl := na
    ssmtEventKey := na
    ssmtExtendTier := 0

// -----------------------------------------------------------------------------
// Bullish Daily SSMT (ES/NQ) — test-only
// Visibility: Only show on Daily-aligned TFs (m15–m30 per helpers/Alignments.txt)
// -----------------------------------------------------------------------------
var table ssmtBDbgTbl = na
var line[] ssmtBHistLines = array.new_line()
var label[] ssmtBHistLbls = array.new_label()
var line ssmtBLine = na
var int  ssmtBEventKey = na
var label ssmtBLbl = na
var int  ssmtBExtendTier = 0

bool ssmtBullTfOk = visDailyTf
if showDailyBullSSMT and ssmtBullTfOk
    string esSymB = f_ssmt_norm_sym(ssmtSymES)
    string nqSymB = f_ssmt_norm_sym(ssmtSymNQ)

    [esLcur, esLcurTs, esLprev, esLprevTs, esQiB, esQtsB] = request.security(esSymB, timeframe.period, f_ssmt_daily_lows(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)
    [nqLcur, nqLcurTs, nqLprev, nqLprevTs, nqQiB, nqQtsB] = request.security(nqSymB, timeframe.period, f_ssmt_daily_lows(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)

    string chartTagB = f_ssmt_tag(syminfo.tickerid)
    bool isChartESB = chartTagB == "ES"
    bool isChartNQB = chartTagB == "NQ"
    bool isPairChartB = isChartESB or isChartNQB

    bool ssmtBReady = not na(esLcur) and not na(esLprev) and not na(nqLcur) and not na(nqLprev)
    if ssmtDebug and barstate.islast
        if na(ssmtBDbgTbl)
            ssmtBDbgTbl := table.new(position.bottom_right, 4, 4, border_width=1, border_color=color.gray)
        table.cell(ssmtBDbgTbl, 0, 0, "Sym", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtBDbgTbl, 1, 0, "Lprev", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtBDbgTbl, 2, 0, "Lcur", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtBDbgTbl, 3, 0, "Sweep", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtBDbgTbl, 0, 1, f_ssmt_tag(ssmtSymES), text_color=color.black)
        table.cell(ssmtBDbgTbl, 1, 1, f_fmt(esLprev), text_color=color.black)
        table.cell(ssmtBDbgTbl, 2, 1, f_fmt(esLcur), text_color=color.black)
        table.cell(ssmtBDbgTbl, 3, 1, esLcur < esLprev ? "Y" : "N", text_color=color.black)
        table.cell(ssmtBDbgTbl, 0, 2, f_ssmt_tag(ssmtSymNQ), text_color=color.black)
        table.cell(ssmtBDbgTbl, 1, 2, f_fmt(nqLprev), text_color=color.black)
        table.cell(ssmtBDbgTbl, 2, 2, f_fmt(nqLcur), text_color=color.black)
        table.cell(ssmtBDbgTbl, 3, 2, nqLcur < nqLprev ? "Y" : "N", text_color=color.black)
        table.cell(ssmtBDbgTbl, 0, 3, "QStart", text_color=color.black, bgcolor=color.new(color.black, 85))
        table.cell(ssmtBDbgTbl, 1, 3, f_fmt_time(esQtsB, cfg.tz), text_color=color.black)
        table.cell(ssmtBDbgTbl, 2, 3, f_fmt_time(nqQtsB, cfg.tz), text_color=color.black)
        table.cell(ssmtBDbgTbl, 3, 3, "", text_color=color.black)
    else if not ssmtDebug and not na(ssmtBDbgTbl)
        table.delete(ssmtBDbgTbl)
        ssmtBDbgTbl := na

    if ssmtBReady
        bool esSweepB = esLcur < esLprev
        bool nqSweepB = nqLcur < nqLprev
        bool splitB = esSweepB != nqSweepB

        bool crackedESB = splitB and (not esSweepB)
        bool crackedNQB = splitB and (not nqSweepB)
        string crackedB = ""
        if crackedESB
            crackedB := "ES"
        if crackedNQB
            crackedB := crackedB == "" ? "NQ" : crackedB + ",NQ"

        float curL = na
        int   curLTs = na
        float prevL = na
        int   prevLTs = na
        int   curQTs = na
        bool  curSweep = false
        if isChartESB
            curL := esLcur
            curLTs := esLcurTs
            prevL := esLprev
            prevLTs := esLprevTs
            curQTs := esQtsB
            curSweep := esSweepB
        else if isChartNQB
            curL := nqLcur
            curLTs := nqLcurTs
            prevL := nqLprev
            prevLTs := nqLprevTs
            curQTs := nqQtsB
            curSweep := nqSweepB

        int eventKeyB = prevLTs
        bool eventChangedB = not na(eventKeyB) and (na(ssmtBEventKey) or eventKeyB != ssmtBEventKey)
        if eventChangedB
            f_ssmt_hist_push(ssmtBLine, ssmtBLbl, ssmtBHistLines, ssmtBHistLbls, ssmtKeep)
            ssmtBLine := na
            ssmtBLbl := na
            ssmtBExtendTier := 0
            ssmtBEventKey := eventKeyB

        if not splitB or not isPairChartB
            if not na(ssmtBLine)
                line.delete(ssmtBLine)
                ssmtBLine := na
            if not na(ssmtBLbl)
                label.delete(ssmtBLbl)
                ssmtBLbl := na
            ssmtBExtendTier := 0
        else
            bool hasPointsB = not na(prevL) and not na(prevLTs) and not na(curQTs)
            if hasPointsB and curSweep
                int thirdLenB = int(SSmtQLen / 3)
                int q1EndB = curQTs + thirdLenB
                int q2EndB = curQTs + (thirdLenB * 2)
                int q3EndB = curQTs + SSmtQLen

                int sweepTierB = 1
                if not na(curLTs)
                    if curLTs >= q2EndB
                        sweepTierB := 3
                    else if curLTs >= q1EndB
                        sweepTierB := 2

                int barTierB = 1
                if time_close >= q2EndB
                    barTierB := 3
                else if time_close >= q1EndB
                    barTierB := 2

                ssmtBExtendTier := ssmtBExtendTier < sweepTierB ? sweepTierB : ssmtBExtendTier
                bool touchB = low <= prevL
                if touchB
                    ssmtBExtendTier := ssmtBExtendTier < barTierB ? barTierB : ssmtBExtendTier

                int x2B = q1EndB
                if ssmtBExtendTier >= 3
                    x2B := q3EndB
                else if ssmtBExtendTier == 2
                    x2B := q2EndB

                ssmtBLine := f_set_or_make_hline_w(ssmtBLine, prevLTs, x2B, prevL, color.new(ssmtBullLineCol, 50), line.style_solid, ssmtLineWidth)
            else if hasPointsB and not curSweep and not na(curL) and not na(curLTs)
                ssmtBLine := f_set_or_make_line(ssmtBLine, prevLTs, prevL, curLTs, curL, color.new(ssmtBullLineCol, 50), ssmtLineWidth)

            bool showLabelB = (isChartESB and crackedESB) or (isChartNQB and crackedNQB)
            if hasPointsB and crackedB != "" and showLabelB
                string lblTextB = "D " + crackedB
                if na(ssmtBLbl)
                    ssmtBLbl := label.new(prevLTs, prevL, lblTextB, xloc=xloc.bar_time, style=label.style_label_left, textcolor=color.black, color=color.new(color.black, 100), size=size.tiny)
                else
                    label.set_xy(ssmtBLbl, prevLTs, prevL)
                    label.set_text(ssmtBLbl, lblTextB)
                    label.set_textcolor(ssmtBLbl, color.black)
                    label.set_color(ssmtBLbl, color.new(color.black, 100))
            else if not showLabelB and not na(ssmtBLbl)
                label.delete(ssmtBLbl)
                ssmtBLbl := na
    f_ssmt_hist_trim(ssmtBHistLines, ssmtBHistLbls, ssmtKeep)
else
    if not na(ssmtBLine)
        line.delete(ssmtBLine)
        ssmtBLine := na
    if not na(ssmtBLbl)
        label.delete(ssmtBLbl)
        ssmtBLbl := na
    f_ssmt_hist_clear(ssmtBHistLines, ssmtBHistLbls)
    if not na(ssmtBDbgTbl)
        table.delete(ssmtBDbgTbl)
        ssmtBDbgTbl := na
    ssmtBEventKey := na
    ssmtBExtendTier := 0

// -----------------------------------------------------------------------------
// Bearish m90 SSMT (ES/NQ) — test-only
// Visibility: Only show on 90m-aligned TFs (m5–m15 per helpers/Alignments.txt)
// -----------------------------------------------------------------------------
var table m90SsmtDbgTbl = na
var line[] m90SsmtHistLines = array.new_line()
var label[] m90SsmtHistLbls = array.new_label()
var line m90SsmtLine = na
var int  m90SsmtEventKey = na
var label m90SsmtLbl = na
var int  m90SsmtExtendTier = 0
var int  m90SsmtActiveQTs = na
int M90SsmtQLen = 90 * 60 * 1000

bool ssmt90mTfOk = vis90mTf
if show90mBearSSMT and ssmt90mTfOk
    string esSymM = f_ssmt_norm_sym(ssmtSymES)
    string nqSymM = f_ssmt_norm_sym(ssmtSymNQ)

    [esHcurM, esHcurTsM, esHprevM, esHprevTsM, esQiM, esQtsM] = request.security(esSymM, timeframe.period, f_ssmt_m90_highs(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)
    [nqHcurM, nqHcurTsM, nqHprevM, nqHprevTsM, nqQiM, nqQtsM] = request.security(nqSymM, timeframe.period, f_ssmt_m90_highs(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)

    string chartTagM = f_ssmt_tag(syminfo.tickerid)
    bool isChartESM = chartTagM == "ES"
    bool isChartNQM = chartTagM == "NQ"
    bool isPairChartM = isChartESM or isChartNQM

    bool ssmtReadyM = not na(esHcurM) and not na(esHprevM) and not na(nqHcurM) and not na(nqHprevM)
    if ssmtReadyM and isPairChartM
        bool esSweepM = esHcurM > esHprevM
        bool nqSweepM = nqHcurM > nqHprevM
        bool splitM = esSweepM != nqSweepM

        bool crackedESM = splitM and (not esSweepM)
        bool crackedNQM = splitM and (not nqSweepM)
        string crackedM = ""
        if crackedESM
            crackedM := "ES"
        if crackedNQM
            crackedM := crackedM == "" ? "NQ" : crackedM + ",NQ"

        float curH = na
        int   curHTs = na
        float prevH = na
        int   prevHTs = na
        int   curQTs = na
        bool  curSweep = false

        if isChartESM
            curH := esHcurM
            curHTs := esHcurTsM
            prevH := esHprevM
            prevHTs := esHprevTsM
            curQTs := esQtsM
            curSweep := esSweepM
        else if isChartNQM
            curH := nqHcurM
            curHTs := nqHcurTsM
            prevH := nqHprevM
            prevHTs := nqHprevTsM
            curQTs := nqQtsM
            curSweep := nqSweepM

        bool hasPoints = splitM and not na(prevH) and not na(prevHTs) and not na(curQTs)
        if splitM
            int eventKey = prevHTs
            if na(m90SsmtEventKey) or m90SsmtEventKey != eventKey
                f_ssmt_hist_push(m90SsmtLine, m90SsmtLbl, m90SsmtHistLines, m90SsmtHistLbls, ssmtKeep)
                m90SsmtLine := na
                m90SsmtLbl := na
                m90SsmtEventKey := eventKey
                m90SsmtActiveQTs := curQTs
                m90SsmtExtendTier := 0

            if hasPoints and curSweep
                int thirdLen = int(M90SsmtQLen / 3)
                int q1End = curQTs + thirdLen
                int q2End = curQTs + (thirdLen * 2)
                int q3End = curQTs + M90SsmtQLen

                int sweepTier = 1
                if not na(curHTs)
                    if curHTs >= q2End
                        sweepTier := 3
                    else if curHTs >= q1End
                        sweepTier := 2

                int barTier = 1
                if time_close >= q2End
                    barTier := 3
                else if time_close >= q1End
                    barTier := 2

                m90SsmtExtendTier := m90SsmtExtendTier < sweepTier ? sweepTier : m90SsmtExtendTier
                bool touch = high >= prevH
                if touch
                    m90SsmtExtendTier := m90SsmtExtendTier < barTier ? barTier : m90SsmtExtendTier

                int x2 = q1End
                if m90SsmtExtendTier >= 3
                    x2 := q3End
                else if m90SsmtExtendTier == 2
                    x2 := q2End

                m90SsmtLine := f_set_or_make_hline_w(m90SsmtLine, prevHTs, x2, prevH, color.new(ssmtBearLineCol, 50), line.style_solid, ssmtLineWidth)
            else if hasPoints and not curSweep and not na(curH) and not na(curHTs)
                m90SsmtLine := f_set_or_make_line(m90SsmtLine, prevHTs, prevH, curHTs, curH, color.new(ssmtBearLineCol, 50), ssmtLineWidth)
            bool showLabel = (isChartESM and crackedESM) or (isChartNQM and crackedNQM)
            if hasPoints and crackedM != "" and showLabel
                string lblText = "m90 " + crackedM

                int xMid = prevHTs
                float yMid = prevH
                if not na(m90SsmtLine)
                    int x1 = line.get_x1(m90SsmtLine)
                    int x2 = line.get_x2(m90SsmtLine)
                    xMid := x1 + int((x2 - x1) / 2)
                    yMid := (line.get_y1(m90SsmtLine) + line.get_y2(m90SsmtLine)) / 2
                float yLbl = yMid + syminfo.mintick

                if na(m90SsmtLbl)
                    m90SsmtLbl := label.new(xMid, yLbl, lblText, xloc=xloc.bar_time, style=label.style_none, textcolor=color.black, size=size.tiny)
                else
                    label.set_xy(m90SsmtLbl, xMid, yLbl)
                    label.set_text(m90SsmtLbl, lblText)
                    label.set_textcolor(m90SsmtLbl, color.black)
            else if not showLabel and not na(m90SsmtLbl)
                label.delete(m90SsmtLbl)
                m90SsmtLbl := na
        // State-based finalize/cleanup:
        // - If split resolves within the same quarter: delete active drawings.
        // - If the quarter rolls while an active split existed: archive into history (SSMT History) then clear.
        if not splitM and not na(m90SsmtEventKey)
            bool rolled = not na(m90SsmtActiveQTs) and not na(curQTs) and curQTs != m90SsmtActiveQTs
            if rolled
                f_ssmt_hist_push(m90SsmtLine, m90SsmtLbl, m90SsmtHistLines, m90SsmtHistLbls, ssmtKeep)
            else
                if not na(m90SsmtLine)
                    line.delete(m90SsmtLine)
                if not na(m90SsmtLbl)
                    label.delete(m90SsmtLbl)
            m90SsmtLine := na
            m90SsmtLbl := na
            m90SsmtEventKey := na
            m90SsmtActiveQTs := na
            m90SsmtExtendTier := 0
    if not (ssmtReadyM and isPairChartM)
        // Not ready or not on ES/NQ: clear active state to avoid stale drawings
        if not na(m90SsmtLine)
            line.delete(m90SsmtLine)
            m90SsmtLine := na
        if not na(m90SsmtLbl)
            label.delete(m90SsmtLbl)
            m90SsmtLbl := na
        m90SsmtEventKey := na
        m90SsmtExtendTier := 0
    f_ssmt_hist_trim(m90SsmtHistLines, m90SsmtHistLbls, ssmtKeep)
else
    if not na(m90SsmtLine)
        line.delete(m90SsmtLine)
        m90SsmtLine := na
    if not na(m90SsmtLbl)
        label.delete(m90SsmtLbl)
        m90SsmtLbl := na
    f_ssmt_hist_clear(m90SsmtHistLines, m90SsmtHistLbls)
    if not na(m90SsmtDbgTbl)
        table.delete(m90SsmtDbgTbl)
        m90SsmtDbgTbl := na
    m90SsmtEventKey := na
    m90SsmtExtendTier := 0

// -----------------------------------------------------------------------------
// Bullish m90 SSMT (ES/NQ) — test-only
// Visibility: Only show on 90m-aligned TFs (m5–m15 per helpers/Alignments.txt)
// -----------------------------------------------------------------------------
var table m90SsmtBDbgTbl = na
var line[] m90SsmtBHistLines = array.new_line()
var label[] m90SsmtBHistLbls = array.new_label()
var line m90SsmtBLine = na
var int  m90SsmtBEventKey = na
var label m90SsmtBLbl = na
var int  m90SsmtBExtendTier = 0
var int  m90SsmtBActiveQTs = na

bool ssmt90mBullTfOk = vis90mTf
if show90mBullSSMT and ssmt90mBullTfOk
    string esSymMB = f_ssmt_norm_sym(ssmtSymES)
    string nqSymMB = f_ssmt_norm_sym(ssmtSymNQ)

    [esLcurM, esLcurTsM, esLprevM, esLprevTsM, esQiMB, esQtsMB] = request.security(esSymMB, timeframe.period, f_ssmt_m90_lows(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)
    [nqLcurM, nqLcurTsM, nqLprevM, nqLprevTsM, nqQiMB, nqQtsMB] = request.security(nqSymMB, timeframe.period, f_ssmt_m90_lows(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)

    string chartTagMB = f_ssmt_tag(syminfo.tickerid)
    bool isChartESMB = chartTagMB == "ES"
    bool isChartNQMB = chartTagMB == "NQ"
    bool isPairChartMB = isChartESMB or isChartNQMB

    bool ssmtReadyMB = not na(esLcurM) and not na(esLprevM) and not na(nqLcurM) and not na(nqLprevM)
    if ssmtReadyMB and isPairChartMB
        bool esSweepMB = esLcurM < esLprevM
        bool nqSweepMB = nqLcurM < nqLprevM
        bool splitMB = esSweepMB != nqSweepMB

        bool crackedESMB = splitMB and (not esSweepMB)
        bool crackedNQMB = splitMB and (not nqSweepMB)
        string crackedMB = ""
        if crackedESMB
            crackedMB := "ES"
        if crackedNQMB
            crackedMB := crackedMB == "" ? "NQ" : crackedMB + ",NQ"

        float curL = na
        int   curLTs = na
        float prevL = na
        int   prevLTs = na
        int   curQTs = na
        bool  curSweepB = false

        if isChartESMB
            curL := esLcurM
            curLTs := esLcurTsM
            prevL := esLprevM
            prevLTs := esLprevTsM
            curQTs := esQtsMB
            curSweepB := esSweepMB
        else if isChartNQMB
            curL := nqLcurM
            curLTs := nqLcurTsM
            prevL := nqLprevM
            prevLTs := nqLprevTsM
            curQTs := nqQtsMB
            curSweepB := nqSweepMB

        bool hasPointsB = splitMB and not na(prevL) and not na(prevLTs) and not na(curQTs)
        if splitMB
            int eventKeyB = prevLTs
            if na(m90SsmtBEventKey) or m90SsmtBEventKey != eventKeyB
                f_ssmt_hist_push(m90SsmtBLine, m90SsmtBLbl, m90SsmtBHistLines, m90SsmtBHistLbls, ssmtKeep)
                m90SsmtBLine := na
                m90SsmtBLbl := na
                m90SsmtBEventKey := eventKeyB
                m90SsmtBActiveQTs := curQTs
                m90SsmtBExtendTier := 0

            if hasPointsB and curSweepB
                int thirdLenB = int(M90SsmtQLen / 3)
                int q1EndB = curQTs + thirdLenB
                int q2EndB = curQTs + (thirdLenB * 2)
                int q3EndB = curQTs + M90SsmtQLen

                int sweepTierB = 1
                if not na(curLTs)
                    if curLTs >= q2EndB
                        sweepTierB := 3
                    else if curLTs >= q1EndB
                        sweepTierB := 2

                int barTierB = 1
                if time_close >= q2EndB
                    barTierB := 3
                else if time_close >= q1EndB
                    barTierB := 2

                m90SsmtBExtendTier := m90SsmtBExtendTier < sweepTierB ? sweepTierB : m90SsmtBExtendTier
                bool touchB = low <= prevL
                if touchB
                    m90SsmtBExtendTier := m90SsmtBExtendTier < barTierB ? barTierB : m90SsmtBExtendTier

                int x2B = q1EndB
                if m90SsmtBExtendTier >= 3
                    x2B := q3EndB
                else if m90SsmtBExtendTier == 2
                    x2B := q2EndB

                m90SsmtBLine := f_set_or_make_hline_w(m90SsmtBLine, prevLTs, x2B, prevL, color.new(ssmtBullLineCol, 50), line.style_solid, ssmtLineWidth)
            else if hasPointsB and not curSweepB and not na(curL) and not na(curLTs)
                m90SsmtBLine := f_set_or_make_line(m90SsmtBLine, prevLTs, prevL, curLTs, curL, color.new(ssmtBullLineCol, 50), ssmtLineWidth)
            bool showLabelB = (isChartESMB and crackedESMB) or (isChartNQMB and crackedNQMB)
            if hasPointsB and crackedMB != "" and showLabelB
                string lblTextB = "m90 " + crackedMB

                int xMidB = prevLTs
                float yMidB = prevL
                if not na(m90SsmtBLine)
                    int x1B = line.get_x1(m90SsmtBLine)
                    int x2B = line.get_x2(m90SsmtBLine)
                    xMidB := x1B + int((x2B - x1B) / 2)
                    yMidB := (line.get_y1(m90SsmtBLine) + line.get_y2(m90SsmtBLine)) / 2
                float yLblB = yMidB - syminfo.mintick

                if na(m90SsmtBLbl)
                    m90SsmtBLbl := label.new(xMidB, yLblB, lblTextB, xloc=xloc.bar_time, style=label.style_none, textcolor=color.black, size=size.tiny)
                else
                    label.set_xy(m90SsmtBLbl, xMidB, yLblB)
                    label.set_text(m90SsmtBLbl, lblTextB)
                    label.set_textcolor(m90SsmtBLbl, color.black)
            else if not showLabelB and not na(m90SsmtBLbl)
                label.delete(m90SsmtBLbl)
                m90SsmtBLbl := na
        // State-based finalize/cleanup:
        // - If split resolves within the same quarter: delete active drawings.
        // - If the quarter rolls while an active split existed: archive into history (SSMT History) then clear.
        if not splitMB and not na(m90SsmtBEventKey)
            bool rolled = not na(m90SsmtBActiveQTs) and not na(curQTs) and curQTs != m90SsmtBActiveQTs
            if rolled
                f_ssmt_hist_push(m90SsmtBLine, m90SsmtBLbl, m90SsmtBHistLines, m90SsmtBHistLbls, ssmtKeep)
            else
                if not na(m90SsmtBLine)
                    line.delete(m90SsmtBLine)
                if not na(m90SsmtBLbl)
                    label.delete(m90SsmtBLbl)
            m90SsmtBLine := na
            m90SsmtBLbl := na
            m90SsmtBEventKey := na
            m90SsmtBActiveQTs := na
            m90SsmtBExtendTier := 0
    if not (ssmtReadyMB and isPairChartMB)
        // Not ready or not on ES/NQ: clear active state to avoid stale drawings
        if not na(m90SsmtBLine)
            line.delete(m90SsmtBLine)
            m90SsmtBLine := na
        if not na(m90SsmtBLbl)
            label.delete(m90SsmtBLbl)
            m90SsmtBLbl := na
        m90SsmtBEventKey := na
        m90SsmtBExtendTier := 0
    f_ssmt_hist_trim(m90SsmtBHistLines, m90SsmtBHistLbls, ssmtKeep)
else
    if not na(m90SsmtBLine)
        line.delete(m90SsmtBLine)
        m90SsmtBLine := na
    if not na(m90SsmtBLbl)
        label.delete(m90SsmtBLbl)
        m90SsmtBLbl := na
    f_ssmt_hist_clear(m90SsmtBHistLines, m90SsmtBHistLbls)
    if not na(m90SsmtBDbgTbl)
        table.delete(m90SsmtBDbgTbl)
        m90SsmtBDbgTbl := na
    m90SsmtBEventKey := na
    m90SsmtBExtendTier := 0


// -----------------------------------------------------------------------------
// Bearish Weekly SSMT (ES/NQ) — test-only
// Visibility: Only show on Weekly-aligned TFs (H1–H3 per helpers/Alignments.txt)
// -----------------------------------------------------------------------------
var line[] wSsmtHistLines = array.new_line()
var label[] wSsmtHistLbls = array.new_label()
var line wSsmtLine = na
var int  wSsmtEventKey = na
var label wSsmtLbl = na
var int  wSsmtExtendTier = 0
int WSSmtQLen = 24 * 60 * 60 * 1000

bool wSsmtTfOk = visWeeklyTf
if showWeeklyBearSSMT and wSsmtTfOk
    string esSymW = f_ssmt_norm_sym(ssmtSymES)
    string nqSymW = f_ssmt_norm_sym(ssmtSymNQ)

    [esHcurW, esHcurTsW, esHprevW, esHprevTsW, esQiW, esQtsW] = request.security(esSymW, timeframe.period, f_ssmt_weekly_highs(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)
    [nqHcurW, nqHcurTsW, nqHprevW, nqHprevTsW, nqQiW, nqQtsW] = request.security(nqSymW, timeframe.period, f_ssmt_weekly_highs(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)

    string chartTagW = f_ssmt_tag(syminfo.tickerid)
    bool isChartESW = chartTagW == "ES"
    bool isChartNQW = chartTagW == "NQ"
    bool isPairChartW = isChartESW or isChartNQW

    bool ssmtReadyW = not na(esHcurW) and not na(esHprevW) and not na(nqHcurW) and not na(nqHprevW)

    if ssmtReadyW and isPairChartW
        bool esSweepW = esHcurW > esHprevW
        bool nqSweepW = nqHcurW > nqHprevW
        bool splitW = esSweepW != nqSweepW

        bool crackedESW = not esSweepW
        bool crackedNQW = not nqSweepW
        string crackedW = ""
        if crackedESW
            crackedW += "ES"
        if crackedNQW
            crackedW += (crackedW == "" ? "" : "/") + "NQ"

        // Select chart-local series (for this symbol) for drawing
        float curH = na
        int   curHTs = na
        float prevH = na
        int   prevHTs = na
        int   curQTs = na
        bool  curSweep = false
        if isChartESW
            curH := esHcurW
            curHTs := esHcurTsW
            prevH := esHprevW
            prevHTs := esHprevTsW
            curQTs := esQtsW
            curSweep := esSweepW
        else if isChartNQW
            curH := nqHcurW
            curHTs := nqHcurTsW
            prevH := nqHprevW
            prevHTs := nqHprevTsW
            curQTs := nqQtsW
            curSweep := nqSweepW

        int eventKey = prevHTs
        bool eventChanged = not na(eventKey) and (na(wSsmtEventKey) or eventKey != wSsmtEventKey)
        if eventChanged
            f_ssmt_hist_push(wSsmtLine, wSsmtLbl, wSsmtHistLines, wSsmtHistLbls, ssmtKeep)
            wSsmtLine := na
            wSsmtLbl := na
            wSsmtExtendTier := 0
            wSsmtEventKey := eventKey

        if not splitW or not isPairChartW
            if not na(wSsmtLine)
                line.delete(wSsmtLine)
                wSsmtLine := na
            if not na(wSsmtLbl)
                label.delete(wSsmtLbl)
                wSsmtLbl := na
            wSsmtEventKey := na
            wSsmtExtendTier := 0
        else
            bool hasPoints = not na(prevH) and not na(prevHTs) and not na(curQTs)
            if hasPoints and curSweep and not na(prevH)
                int thirdLen = int(WSSmtQLen / 3)
                int q1End = curQTs + thirdLen
                int q2End = curQTs + (thirdLen * 2)
                int q3End = curQTs + WSSmtQLen

                int sweepTier = 1
                if not na(curHTs)
                    if curHTs >= q2End
                        sweepTier := 3
                    else if curHTs >= q1End
                        sweepTier := 2

                int barTier = 1
                if time_close >= q2End
                    barTier := 3
                else if time_close >= q1End
                    barTier := 2

                wSsmtExtendTier := wSsmtExtendTier < sweepTier ? sweepTier : wSsmtExtendTier

                // Auto-extend when price is still through the swept PQH level as later thirds begin
                bool touch = high >= prevH
                if touch
                    wSsmtExtendTier := wSsmtExtendTier < barTier ? barTier : wSsmtExtendTier

                int x2 = q1End
                if wSsmtExtendTier >= 3
                    x2 := q3End
                else if wSsmtExtendTier == 2
                    x2 := q2End

                wSsmtLine := f_set_or_make_hline_w(wSsmtLine, prevHTs, x2, prevH, color.new(ssmtBearLineCol, 50), line.style_solid, ssmtLineWidth)
            else if hasPoints and not curSweep and not na(curH) and not na(curHTs)
                wSsmtLine := f_set_or_make_line(wSsmtLine, prevHTs, prevH, curHTs, curH, color.new(ssmtBearLineCol, 50), ssmtLineWidth)

            bool showLabel = (isChartESW and crackedESW) or (isChartNQW and crackedNQW)
            if hasPoints and crackedW != "" and showLabel
                string lblText = "W " + crackedW
                if na(wSsmtLbl)
                    wSsmtLbl := label.new(prevHTs, prevH, lblText, xloc=xloc.bar_time, style=label.style_label_left, textcolor=color.black, color=color.new(color.black, 100), size=size.tiny)
                else
                    label.set_x(wSsmtLbl, prevHTs)
                    label.set_y(wSsmtLbl, prevH)
                    label.set_text(wSsmtLbl, lblText)

            f_ssmt_hist_trim(wSsmtHistLines, wSsmtHistLbls, ssmtKeep)
    else
        if not na(wSsmtLine)
            line.delete(wSsmtLine)
            wSsmtLine := na
        if not na(wSsmtLbl)
            label.delete(wSsmtLbl)
            wSsmtLbl := na
        f_ssmt_hist_trim(wSsmtHistLines, wSsmtHistLbls, ssmtKeep)
        wSsmtEventKey := na
        wSsmtExtendTier := 0
else
    if not na(wSsmtLine)
        line.delete(wSsmtLine)
        wSsmtLine := na
    if not na(wSsmtLbl)
        label.delete(wSsmtLbl)
        wSsmtLbl := na
    f_ssmt_hist_clear(wSsmtHistLines, wSsmtHistLbls)
    wSsmtEventKey := na
    wSsmtExtendTier := 0

// -----------------------------------------------------------------------------
// Bullish Weekly SSMT (ES/NQ) — test-only
// Visibility: Only show on Weekly-aligned TFs (H1–H3 per helpers/Alignments.txt)
// -----------------------------------------------------------------------------
var line[] wSsmtBHistLines = array.new_line()
var label[] wSsmtBHistLbls = array.new_label()
var line wSsmtBLine = na
var int  wSsmtBEventKey = na
var label wSsmtBLbl = na
var int  wSsmtBExtendTier = 0

bool wSsmtBullTfOk = visWeeklyTf
if showWeeklyBullSSMT and wSsmtBullTfOk
    string esSymWB = f_ssmt_norm_sym(ssmtSymES)
    string nqSymWB = f_ssmt_norm_sym(ssmtSymNQ)

    [esLcurWB, esLcurTsWB, esLprevWB, esLprevTsWB, esQiWB, esQtsWB] = request.security(esSymWB, timeframe.period, f_ssmt_weekly_lows(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)
    [nqLcurWB, nqLcurTsWB, nqLprevWB, nqLprevTsWB, nqQiWB, nqQtsWB] = request.security(nqSymWB, timeframe.period, f_ssmt_weekly_lows(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off, ignore_invalid_symbol=true)

    string chartTagWB = f_ssmt_tag(syminfo.tickerid)
    bool isChartESWB = chartTagWB == "ES"
    bool isChartNQWB = chartTagWB == "NQ"
    bool isPairChartWB = isChartESWB or isChartNQWB

    bool ssmtWBReady = not na(esLcurWB) and not na(esLprevWB) and not na(nqLcurWB) and not na(nqLprevWB)
    if ssmtWBReady
        bool esSweepWB = esLcurWB < esLprevWB
        bool nqSweepWB = nqLcurWB < nqLprevWB
        bool splitWB = esSweepWB != nqSweepWB

        bool crackedESWB = splitWB and (not esSweepWB)
        bool crackedNQWB = splitWB and (not nqSweepWB)
        string crackedWB = ""
        if crackedESWB
            crackedWB := "ES"
        if crackedNQWB
            crackedWB := crackedWB == "" ? "NQ" : crackedWB + ",NQ"

        float curL = na
        int   curLTs = na
        float prevL = na
        int   prevLTs = na
        int   curQTs = na
        bool  curSweep = false
        if isChartESWB
            curL := esLcurWB
            curLTs := esLcurTsWB
            prevL := esLprevWB
            prevLTs := esLprevTsWB
            curQTs := esQtsWB
            curSweep := esSweepWB
        else if isChartNQWB
            curL := nqLcurWB
            curLTs := nqLcurTsWB
            prevL := nqLprevWB
            prevLTs := nqLprevTsWB
            curQTs := nqQtsWB
            curSweep := nqSweepWB

        int eventKeyWB = prevLTs
        bool eventChangedWB = not na(eventKeyWB) and (na(wSsmtBEventKey) or eventKeyWB != wSsmtBEventKey)
        if eventChangedWB
            f_ssmt_hist_push(wSsmtBLine, wSsmtBLbl, wSsmtBHistLines, wSsmtBHistLbls, ssmtKeep)
            wSsmtBLine := na
            wSsmtBLbl := na
            wSsmtBExtendTier := 0
            wSsmtBEventKey := eventKeyWB

        if not splitWB or not isPairChartWB
            if not na(wSsmtBLine)
                line.delete(wSsmtBLine)
                wSsmtBLine := na
            if not na(wSsmtBLbl)
                label.delete(wSsmtBLbl)
                wSsmtBLbl := na
            wSsmtBExtendTier := 0
        else
            bool hasPointsWB = not na(prevL) and not na(prevLTs) and not na(curQTs)
            if hasPointsWB and curSweep
                int thirdLenWB = int(WSSmtQLen / 3)
                int q1EndWB = curQTs + thirdLenWB
                int q2EndWB = curQTs + (thirdLenWB * 2)
                int q3EndWB = curQTs + WSSmtQLen

                int sweepTierWB = 1
                if not na(curLTs)
                    if curLTs >= q2EndWB
                        sweepTierWB := 3
                    else if curLTs >= q1EndWB
                        sweepTierWB := 2

                int barTierWB = 1
                if time_close >= q2EndWB
                    barTierWB := 3
                else if time_close >= q1EndWB
                    barTierWB := 2

                wSsmtBExtendTier := wSsmtBExtendTier < sweepTierWB ? sweepTierWB : wSsmtBExtendTier
                bool touchWB = low <= prevL
                if touchWB
                    wSsmtBExtendTier := wSsmtBExtendTier < barTierWB ? barTierWB : wSsmtBExtendTier

                int x2WB = q1EndWB
                if wSsmtBExtendTier >= 3
                    x2WB := q3EndWB
                else if wSsmtBExtendTier == 2
                    x2WB := q2EndWB

                wSsmtBLine := f_set_or_make_hline_w(wSsmtBLine, prevLTs, x2WB, prevL, color.new(ssmtBullLineCol, 50), line.style_solid, ssmtLineWidth)
            else if hasPointsWB and not curSweep and not na(curL) and not na(curLTs)
                wSsmtBLine := f_set_or_make_line(wSsmtBLine, prevLTs, prevL, curLTs, curL, color.new(ssmtBullLineCol, 50), ssmtLineWidth)

            bool showLabelWB = (isChartESWB and crackedESWB) or (isChartNQWB and crackedNQWB)
            if hasPointsWB and crackedWB != "" and showLabelWB
                string lblTextWB = "W " + crackedWB
                if na(wSsmtBLbl)
                    wSsmtBLbl := label.new(prevLTs, prevL, lblTextWB, xloc=xloc.bar_time, style=label.style_label_left, textcolor=color.black, color=color.new(color.black, 100), size=size.tiny)
                else
                    label.set_xy(wSsmtBLbl, prevLTs, prevL)
                    label.set_text(wSsmtBLbl, lblTextWB)
                    label.set_textcolor(wSsmtBLbl, color.black)
                    label.set_color(wSsmtBLbl, color.new(color.black, 100))
            else if not showLabelWB and not na(wSsmtBLbl)
                label.delete(wSsmtBLbl)
                wSsmtBLbl := na
    f_ssmt_hist_trim(wSsmtBHistLines, wSsmtBHistLbls, ssmtKeep)
else
    if not na(wSsmtBLine)
        line.delete(wSsmtBLine)
        wSsmtBLine := na
    if not na(wSsmtBLbl)
        label.delete(wSsmtBLbl)
        wSsmtBLbl := na
    f_ssmt_hist_clear(wSsmtBHistLines, wSsmtBHistLbls)
    wSsmtBEventKey := na
    wSsmtBExtendTier := 0

// -----------------------------------------------------------------------------
// Divider + cycle-window management (QTIndicator model)
// -----------------------------------------------------------------------------
// TODO Later: Add option to extend all opening lines an entire cycle length
var int MAX_LINES = 500
var int STORE_MAX = 800

// -----------------------------------------------------------------------------
// Daily cycle storage
// -----------------------------------------------------------------------------
var int[] dailyStarts = array.new_int()
var vset  dailyV = vset_new()

var line dailyProjQ2  = na
var line dailyProjQ3  = na
var line dailyProjQ4  = na
var line dailyProjEnd = na

var int[]   dailyHistStart = array.new_int()
var int[]   dailyHistEnd   = array.new_int()

var float[] daily_h_q1o   = array.new_float()
var int[]   daily_h_q1oTs = array.new_int()
var float[] daily_h_q2o   = array.new_float()
var int[]   daily_h_q2oTs = array.new_int()
var float[] daily_h_q3o   = array.new_float()
var int[]   daily_h_q3oTs = array.new_int()
var float[] daily_h_q4o   = array.new_float()
var int[]   daily_h_q4oTs = array.new_int()

var line[]  daily_l_q1o   = array.new_line()
var line[]  daily_l_q2o   = array.new_line()
var line[]  daily_l_q3o   = array.new_line()
var line[]  daily_l_q4o   = array.new_line()

f_dhist_kill_at(int idx) =>
    line a = array.get(daily_l_q1o, idx)
    line b = array.get(daily_l_q2o, idx)
    line c = array.get(daily_l_q3o, idx)
    line l4 = array.get(daily_l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(daily_l_q1o, idx, na)
    array.set(daily_l_q2o, idx, na)
    array.set(daily_l_q3o, idx, na)
    array.set(daily_l_q4o, idx, na)
    0

f_dhist_shift_front() =>
    if array.size(dailyHistStart) > 0
        f_dhist_kill_at(0)
        array.shift(dailyHistStart)
        array.shift(dailyHistEnd)

        array.shift(daily_h_q1o),  array.shift(daily_h_q1oTs)
        array.shift(daily_h_q2o),  array.shift(daily_h_q2oTs)
        array.shift(daily_h_q3o),  array.shift(daily_h_q3oTs)
        array.shift(daily_h_q4o),  array.shift(daily_h_q4oTs)

        array.shift(daily_l_q1o)
        array.shift(daily_l_q2o)
        array.shift(daily_l_q3o)
        array.shift(daily_l_q4o)
    0

f_dhist_trim_cutoff(int cutoffTs) =>
    while array.size(dailyHistStart) > 0 and array.get(dailyHistStart, 0) < cutoffTs
        f_dhist_shift_front()
    0

f_dhist_ensure_current() =>
    if d.inWindow and not na(d.q1Ts)
        int key = d.q1Ts
        int idx = f_find_int(dailyHistStart, key)
        if idx == -1
            array.push(dailyHistStart, key)
            array.push(dailyHistEnd, d.endTs)

            array.push(daily_h_q1o, na), array.push(daily_h_q1oTs, na)
            array.push(daily_h_q2o, na), array.push(daily_h_q2oTs, na)
            array.push(daily_h_q3o, na), array.push(daily_h_q3oTs, na)
            array.push(daily_h_q4o, na), array.push(daily_h_q4oTs, na)

            line naL = na
            array.push(daily_l_q1o, naL)
            array.push(daily_l_q2o, naL)
            array.push(daily_l_q3o, naL)
            array.push(daily_l_q4o, naL)
            idx := array.size(dailyHistStart) - 1

        array.set(dailyHistEnd, idx, d.endTs)

        float q1o = d.q1.o
        int   q1t = d.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(daily_h_q1o, idx, q1o)
            array.set(daily_h_q1oTs, idx, q1t)

        float q2o = d.q2.o
        int   q2t = d.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(daily_h_q2o, idx, q2o)
            array.set(daily_h_q2oTs, idx, q2t)

        float q3o = d.q3.o
        int   q3t = d.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(daily_h_q3o, idx, q3o)
            array.set(daily_h_q3oTs, idx, q3t)

        float q4o = d.q4.o
        int   q4t = d.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(daily_h_q4o, idx, q4o)
            array.set(daily_h_q4oTs, idx, q4t)

        while array.size(dailyHistStart) > STORE_MAX
            f_dhist_shift_front()
    0

// -----------------------------------------------------------------------------
// 90m cycle storage
// -----------------------------------------------------------------------------
var int[] m90Starts = array.new_int()
var vset  m90V = vset_new()

var line m90ProjQ2  = na
var line m90ProjQ3  = na
var line m90ProjQ4  = na
var line m90ProjEnd = na

var int[]   m90HistStart = array.new_int()
var int[]   m90HistEnd   = array.new_int()

var float[] m90_h_q1o   = array.new_float()
var int[]   m90_h_q1oTs = array.new_int()
var float[] m90_h_q2o   = array.new_float()
var int[]   m90_h_q2oTs = array.new_int()
var float[] m90_h_q3o   = array.new_float()
var int[]   m90_h_q3oTs = array.new_int()
var float[] m90_h_q4o   = array.new_float()
var int[]   m90_h_q4oTs = array.new_int()

var line[]  m90_l_q1o   = array.new_line()
var line[]  m90_l_q2o   = array.new_line()
var line[]  m90_l_q3o   = array.new_line()
var line[]  m90_l_q4o   = array.new_line()

f_m90hist_kill_at(int idx) =>
    line a = array.get(m90_l_q1o, idx)
    line b = array.get(m90_l_q2o, idx)
    line c = array.get(m90_l_q3o, idx)
    line l4 = array.get(m90_l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(m90_l_q1o, idx, na)
    array.set(m90_l_q2o, idx, na)
    array.set(m90_l_q3o, idx, na)
    array.set(m90_l_q4o, idx, na)
    0

f_m90hist_shift_front() =>
    if array.size(m90HistStart) > 0
        f_m90hist_kill_at(0)
        array.shift(m90HistStart)
        array.shift(m90HistEnd)

        array.shift(m90_h_q1o),  array.shift(m90_h_q1oTs)
        array.shift(m90_h_q2o),  array.shift(m90_h_q2oTs)
        array.shift(m90_h_q3o),  array.shift(m90_h_q3oTs)
        array.shift(m90_h_q4o),  array.shift(m90_h_q4oTs)

        array.shift(m90_l_q1o)
        array.shift(m90_l_q2o)
        array.shift(m90_l_q3o)
        array.shift(m90_l_q4o)
    0

f_m90hist_trim_cutoff(int cutoffTs) =>
    while array.size(m90HistStart) > 0 and array.get(m90HistStart, 0) < cutoffTs
        f_m90hist_shift_front()
    0

f_m90hist_ensure_current() =>
    if m90.inWindow and not na(m90.q1Ts)
        int key = m90.q1Ts
        int idx = f_find_int(m90HistStart, key)
        if idx == -1
            array.push(m90HistStart, key)
            array.push(m90HistEnd, m90.endTs)

            array.push(m90_h_q1o, na), array.push(m90_h_q1oTs, na)
            array.push(m90_h_q2o, na), array.push(m90_h_q2oTs, na)
            array.push(m90_h_q3o, na), array.push(m90_h_q3oTs, na)
            array.push(m90_h_q4o, na), array.push(m90_h_q4oTs, na)

            line naL = na
            array.push(m90_l_q1o, naL)
            array.push(m90_l_q2o, naL)
            array.push(m90_l_q3o, naL)
            array.push(m90_l_q4o, naL)
            idx := array.size(m90HistStart) - 1

        array.set(m90HistEnd, idx, m90.endTs)

        float q1o = m90.q1.o
        int   q1t = m90.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(m90_h_q1o, idx, q1o)
            array.set(m90_h_q1oTs, idx, q1t)

        float q2o = m90.q2.o
        int   q2t = m90.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(m90_h_q2o, idx, q2o)
            array.set(m90_h_q2oTs, idx, q2t)

        float q3o = m90.q3.o
        int   q3t = m90.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(m90_h_q3o, idx, q3o)
            array.set(m90_h_q3oTs, idx, q3t)

        float q4o = m90.q4.o
        int   q4t = m90.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(m90_h_q4o, idx, q4o)
            array.set(m90_h_q4oTs, idx, q4t)

        while array.size(m90HistStart) > STORE_MAX
            f_m90hist_shift_front()
    0

// -----------------------------------------------------------------------------
// Micro cycle storage
// -----------------------------------------------------------------------------
var int[] microStarts = array.new_int()
var vset  microV = vset_new()

var line microProjQ2  = na
var line microProjQ3  = na
var line microProjQ4  = na
var line microProjEnd = na

var int[]   microHistStart = array.new_int()
var int[]   microHistEnd   = array.new_int()

var float[] micro_h_q1o   = array.new_float()
var int[]   micro_h_q1oTs = array.new_int()
var float[] micro_h_q2o   = array.new_float()
var int[]   micro_h_q2oTs = array.new_int()
var float[] micro_h_q3o   = array.new_float()
var int[]   micro_h_q3oTs = array.new_int()
var float[] micro_h_q4o   = array.new_float()
var int[]   micro_h_q4oTs = array.new_int()

var line[]  micro_l_q1o   = array.new_line()
var line[]  micro_l_q2o   = array.new_line()
var line[]  micro_l_q3o   = array.new_line()
var line[]  micro_l_q4o   = array.new_line()

f_mhist_kill_at(int idx) =>
    line a = array.get(micro_l_q1o, idx)
    line b = array.get(micro_l_q2o, idx)
    line c = array.get(micro_l_q3o, idx)
    line l4 = array.get(micro_l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(micro_l_q1o, idx, na)
    array.set(micro_l_q2o, idx, na)
    array.set(micro_l_q3o, idx, na)
    array.set(micro_l_q4o, idx, na)
    0

f_mhist_shift_front() =>
    if array.size(microHistStart) > 0
        f_mhist_kill_at(0)
        array.shift(microHistStart)
        array.shift(microHistEnd)

        array.shift(micro_h_q1o),  array.shift(micro_h_q1oTs)
        array.shift(micro_h_q2o),  array.shift(micro_h_q2oTs)
        array.shift(micro_h_q3o),  array.shift(micro_h_q3oTs)
        array.shift(micro_h_q4o),  array.shift(micro_h_q4oTs)

        array.shift(micro_l_q1o)
        array.shift(micro_l_q2o)
        array.shift(micro_l_q3o)
        array.shift(micro_l_q4o)
    0

f_mhist_trim_cutoff(int cutoffTs) =>
    while array.size(microHistStart) > 0 and array.get(microHistStart, 0) < cutoffTs
        f_mhist_shift_front()
    0

f_mhist_ensure_current() =>
    if m.inWindow and not na(m.q1Ts)
        int key = m.q1Ts
        int idx = f_find_int(microHistStart, key)
        if idx == -1
            array.push(microHistStart, key)
            array.push(microHistEnd, m.endTs)

            array.push(micro_h_q1o, na), array.push(micro_h_q1oTs, na)
            array.push(micro_h_q2o, na), array.push(micro_h_q2oTs, na)
            array.push(micro_h_q3o, na), array.push(micro_h_q3oTs, na)
            array.push(micro_h_q4o, na), array.push(micro_h_q4oTs, na)

            line naL = na
            array.push(micro_l_q1o, naL)
            array.push(micro_l_q2o, naL)
            array.push(micro_l_q3o, naL)
            array.push(micro_l_q4o, naL)
            idx := array.size(microHistStart) - 1

        array.set(microHistEnd, idx, m.endTs)

        float q1o = m.q1.o
        int   q1t = m.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(micro_h_q1o, idx, q1o)
            array.set(micro_h_q1oTs, idx, q1t)

        float q2o = m.q2.o
        int   q2t = m.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(micro_h_q2o, idx, q2o)
            array.set(micro_h_q2oTs, idx, q2t)

        float q3o = m.q3.o
        int   q3t = m.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(micro_h_q3o, idx, q3o)
            array.set(micro_h_q3oTs, idx, q3t)

        float q4o = m.q4.o
        int   q4t = m.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(micro_h_q4o, idx, q4o)
            array.set(micro_h_q4oTs, idx, q4t)

        while array.size(microHistStart) > STORE_MAX
            f_mhist_shift_front()
    0

// -----------------------------------------------------------------------------
// Nano cycle storage
// -----------------------------------------------------------------------------
var int[] nanoStarts = array.new_int()
var vset  nanoV = vset_new()

var line projQ2  = na
var line projQ3  = na
var line projQ4  = na
var line projEnd = na

// -----------------------------------------------------------------------------
// Weekly cycle storage (dividers only)
// -----------------------------------------------------------------------------
var int[] weeklyStarts = array.new_int()
var vset  weeklyV = vset_new()
var line weekProjQ2  = na
var line weekProjQ3  = na
var line weekProjQ4  = na
var line weekProjQ5  = na
var line weekProjEnd = na

// Weekly open-line history
var int[]   weeklyHistStart = array.new_int()
var int[]   weeklyHistEnd   = array.new_int()

var float[] weekly_h_q1o    = array.new_float()
var int[]   weekly_h_q1oTs  = array.new_int()
var float[] weekly_h_q2o    = array.new_float()
var int[]   weekly_h_q2oTs  = array.new_int()
var float[] weekly_h_q3o    = array.new_float()
var int[]   weekly_h_q3oTs  = array.new_int()
var float[] weekly_h_q4o    = array.new_float()
var int[]   weekly_h_q4oTs  = array.new_int()
var float[] weekly_h_q5o    = array.new_float()
var int[]   weekly_h_q5oTs  = array.new_int()

var line[]  weekly_l_q1o    = array.new_line()
var line[]  weekly_l_q2o    = array.new_line()
var line[]  weekly_l_q3o    = array.new_line()
var line[]  weekly_l_q4o    = array.new_line()
var line[]  weekly_l_q5o    = array.new_line()

f_whist_kill_at(int idx) =>
    line a = array.get(weekly_l_q1o, idx)
    line b = array.get(weekly_l_q2o, idx)
    line c = array.get(weekly_l_q3o, idx)
    line wl4 = array.get(weekly_l_q4o, idx)
    line e = array.get(weekly_l_q5o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(wl4)
        line.delete(wl4)
    if not na(e)
        line.delete(e)
    array.set(weekly_l_q1o, idx, na)
    array.set(weekly_l_q2o, idx, na)
    array.set(weekly_l_q3o, idx, na)
    array.set(weekly_l_q4o, idx, na)
    array.set(weekly_l_q5o, idx, na)
    0

f_whist_shift_front() =>
    if array.size(weeklyHistStart) > 0
        f_whist_kill_at(0)
        array.shift(weeklyHistStart)
        array.shift(weeklyHistEnd)

        array.shift(weekly_h_q1o),  array.shift(weekly_h_q1oTs)
        array.shift(weekly_h_q2o),  array.shift(weekly_h_q2oTs)
        array.shift(weekly_h_q3o),  array.shift(weekly_h_q3oTs)
        array.shift(weekly_h_q4o),  array.shift(weekly_h_q4oTs)
        array.shift(weekly_h_q5o),  array.shift(weekly_h_q5oTs)

        array.shift(weekly_l_q1o)
        array.shift(weekly_l_q2o)
        array.shift(weekly_l_q3o)
        array.shift(weekly_l_q4o)
        array.shift(weekly_l_q5o)
    0

f_whist_trim_cutoff(int cutoffTs) =>
    while array.size(weeklyHistStart) > 0 and array.get(weeklyHistStart, 0) < cutoffTs
        f_whist_shift_front()
    0

f_whist_ensure_current() =>
    if not na(w.wsEff)
        int key = w.wsEff
        int idx = f_find_int(weeklyHistStart, key)
        if idx == -1
            array.push(weeklyHistStart, key)
            int wEnd = not na(w.wsNextEff) ? w.wsNextEff : w.wsNextIntent
            array.push(weeklyHistEnd, wEnd)

            array.push(weekly_h_q1o, na), array.push(weekly_h_q1oTs, na)
            array.push(weekly_h_q2o, na), array.push(weekly_h_q2oTs, na)
            array.push(weekly_h_q3o, na), array.push(weekly_h_q3oTs, na)
            array.push(weekly_h_q4o, na), array.push(weekly_h_q4oTs, na)
            array.push(weekly_h_q5o, na), array.push(weekly_h_q5oTs, na)

            line naL = na
            array.push(weekly_l_q1o, naL)
            array.push(weekly_l_q2o, naL)
            array.push(weekly_l_q3o, naL)
            array.push(weekly_l_q4o, naL)
            array.push(weekly_l_q5o, naL)
            idx := array.size(weeklyHistStart) - 1

        int wEnd2 = not na(w.wsNextEff) ? w.wsNextEff : w.wsNextIntent
        array.set(weeklyHistEnd, idx, wEnd2)

        if not na(w.q1.open) and not na(w.q1.startEff)
            array.set(weekly_h_q1o, idx, w.q1.open)
            array.set(weekly_h_q1oTs, idx, w.q1.startEff)
        if not na(w.q2.open) and not na(w.q2.startEff)
            array.set(weekly_h_q2o, idx, w.q2.open)
            array.set(weekly_h_q2oTs, idx, w.q2.startEff)
        if not na(w.q3.open) and not na(w.q3.startEff)
            array.set(weekly_h_q3o, idx, w.q3.open)
            array.set(weekly_h_q3oTs, idx, w.q3.startEff)
        if not na(w.q4.open) and not na(w.q4.startEff)
            array.set(weekly_h_q4o, idx, w.q4.open)
            array.set(weekly_h_q4oTs, idx, w.q4.startEff)
        if not na(w.q5.open) and not na(w.q5.startEff)
            array.set(weekly_h_q5o, idx, w.q5.open)
            array.set(weekly_h_q5oTs, idx, w.q5.startEff)

        while array.size(weeklyHistStart) > STORE_MAX
            f_whist_shift_front()
    0

// -----------------------------------------------------------------------------
// Open-line history (per displayed cycle) — values captured from QTCore during
// the cycle, then retained + drawn as long as the cycle is inside keepCycles.
// -----------------------------------------------------------------------------
var int[]   histStart = array.new_int()
var int[]   histEnd   = array.new_int()

var float[] h_q1o     = array.new_float()
var int[]   h_q1oTs   = array.new_int()
var float[] h_q2o     = array.new_float()
var int[]   h_q2oTs   = array.new_int()
var float[] h_q3o     = array.new_float()
var int[]   h_q3oTs   = array.new_int()
var float[] h_q4o     = array.new_float()
var int[]   h_q4oTs   = array.new_int()

var line[]  l_q1o     = array.new_line()
var line[]  l_q2o     = array.new_line()
var line[]  l_q3o     = array.new_line()
var line[]  l_q4o     = array.new_line()

f_hist_kill_at(int idx) =>
    line a = array.get(l_q1o, idx)
    line b = array.get(l_q2o, idx)
    line c = array.get(l_q3o, idx)
    line l4 = array.get(l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(l_q1o, idx, na)
    array.set(l_q2o, idx, na)
    array.set(l_q3o, idx, na)
    array.set(l_q4o, idx, na)
    0

f_hist_shift_front() =>
    if array.size(histStart) > 0
        f_hist_kill_at(0)
        array.shift(histStart)
        array.shift(histEnd)

        array.shift(h_q1o),  array.shift(h_q1oTs)
        array.shift(h_q2o),  array.shift(h_q2oTs)
        array.shift(h_q3o),  array.shift(h_q3oTs)
        array.shift(h_q4o),  array.shift(h_q4oTs)

        array.shift(l_q1o)
        array.shift(l_q2o)
        array.shift(l_q3o)
        array.shift(l_q4o)
    0

f_hist_trim_cutoff(int cutoffTs) =>
    while array.size(histStart) > 0 and array.get(histStart, 0) < cutoffTs
        f_hist_shift_front()
    0

f_hist_ensure_current() =>
    if n.inWindow and not na(n.q1Ts)
        int key = n.q1Ts
        int idx = f_find_int(histStart, key)
        if idx == -1
            array.push(histStart, key)
            array.push(histEnd, n.endTs)

            array.push(h_q1o, na), array.push(h_q1oTs, na)
            array.push(h_q2o, na), array.push(h_q2oTs, na)
            array.push(h_q3o, na), array.push(h_q3oTs, na)
            array.push(h_q4o, na), array.push(h_q4oTs, na)

            line naL = na
            array.push(l_q1o, naL)
            array.push(l_q2o, naL)
            array.push(l_q3o, naL)
            array.push(l_q4o, naL)
            idx := array.size(histStart) - 1

        // Update current cycle snapshot from QTCore values
        // IMPORTANT: For sub-TF-aligned opens (e.g., Nano forced to 5S), always anchor open-lines to q?.oTs.
        // Do NOT fall back to boundaryTs (q?Ts), or the line will be shifted on higher chart TFs.
        array.set(histEnd, idx, n.endTs)

        float q1o = n.q1.o
        int   q1t = n.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(h_q1o, idx, q1o)
            array.set(h_q1oTs, idx, q1t)

        float q2o = n.q2.o
        int   q2t = n.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(h_q2o, idx, q2o)
            array.set(h_q2oTs, idx, q2t)

        float q3o = n.q3.o
        int   q3t = n.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(h_q3o, idx, q3o)
            array.set(h_q3oTs, idx, q3t)

        float q4o = n.q4.o
        int   q4t = n.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(h_q4o, idx, q4o)
            array.set(h_q4oTs, idx, q4t)

        // Hard cap history storage (delete oldest if exceeded)
        while array.size(histStart) > STORE_MAX
            f_hist_shift_front()
    0

// -----------------------------------------------------------------------------
// Main draw logic
// -----------------------------------------------------------------------------
int enabledCycles = (showDailyTf ? 1 : 0) + (show90mTf ? 1 : 0) + (showMicroTf ? 1 : 0) + (showNanoTf ? 1 : 0) + (showWeeklyTf ? 1 : 0)
if enabledCycles < 1
    enabledCycles := 1
int perCycle = showOpens ? 9 : 5
int maxC = int(math.floor((MAX_LINES - 10) / (perCycle * (enabledCycles * 1.0))))
maxC := f_clamp_int(maxC, 1, 200)
int keepEff = f_clamp_int(keepCycles, 1, maxC)

if not showDailyTf
    vset_clear(dailyV)
    dailyProjQ2  := f_kill(dailyProjQ2)
    dailyProjQ3  := f_kill(dailyProjQ3)
    dailyProjQ4  := f_kill(dailyProjQ4)
    dailyProjEnd := f_kill(dailyProjEnd)

    int di = array.size(dailyHistStart) - 1
    while di >= 0
        f_dhist_kill_at(di)
        di -= 1
    array.clear(dailyHistStart), array.clear(dailyHistEnd)
    array.clear(daily_h_q1o), array.clear(daily_h_q1oTs)
    array.clear(daily_h_q2o), array.clear(daily_h_q2oTs)
    array.clear(daily_h_q3o), array.clear(daily_h_q3oTs)
    array.clear(daily_h_q4o), array.clear(daily_h_q4oTs)
    array.clear(daily_l_q1o), array.clear(daily_l_q2o), array.clear(daily_l_q3o), array.clear(daily_l_q4o)
    array.clear(dailyStarts)
else
    if not na(d.q2Ts)
        dailyProjQ2 := tc > d.q2Ts ? f_kill(dailyProjQ2) : f_set_or_make_vline(dailyProjQ2, d.q2Ts, COL_Q2)
    if not na(d.q3Ts)
        dailyProjQ3 := tc > d.q3Ts ? f_kill(dailyProjQ3) : f_set_or_make_vline(dailyProjQ3, d.q3Ts, COL_Q3)
    if not na(d.q4Ts)
        dailyProjQ4 := tc > d.q4Ts ? f_kill(dailyProjQ4) : f_set_or_make_vline(dailyProjQ4, d.q4Ts, COL_Q4)

    if not na(d.endTs)
        dailyProjEnd := f_set_or_make_vline(dailyProjEnd, d.endTs, COL_Q1)

    if d.inWindow and not na(d.q1Ts)
        f_push_unique_int(dailyStarts, d.q1Ts, STORE_MAX)

    int dCutoff = na(d.q1Ts) ? 0 : d.q1Ts
    int dAvail = array.size(dailyStarts)
    int dUse   = math.min(keepEff, dAvail)
    int dFirst = dAvail - dUse
    if dUse > 0
        dCutoff := array.get(dailyStarts, dFirst)

    vset_trim_since(dailyV, dCutoff)

    f_dhist_ensure_current()
    f_dhist_trim_cutoff(dCutoff)

    if d.inWindow
        if not na(d.q1Ts) and tc > d.q1Ts
            vset_add(dailyV, d.q1Ts, COL_Q1)
        if not na(d.q2Ts) and tc > d.q2Ts
            vset_add(dailyV, d.q2Ts, COL_Q2)
        if not na(d.q3Ts) and tc > d.q3Ts
            vset_add(dailyV, d.q3Ts, COL_Q3)
        if not na(d.q4Ts) and tc > d.q4Ts
            vset_add(dailyV, d.q4Ts, COL_Q4)
        if not na(d.endTs) and tc > d.endTs
            vset_add(dailyV, d.endTs, COL_Q1)

    if not showOpens
        int dj = array.size(dailyHistStart) - 1
        while dj >= 0
            f_dhist_kill_at(dj)
            dj -= 1
    else
        int dsz = array.size(dailyHistStart)
        int dk = 0
        while dk < dsz
            int dEndTs = array.get(dailyHistEnd, dk)

            float dy1 = array.get(daily_h_q1o, dk)
            int   dx1 = array.get(daily_h_q1oTs, dk)
            line  dl1 = array.get(daily_l_q1o, dk)
            if not na(dy1) and not na(dx1) and not na(dEndTs)
                dl1 := f_set_or_make_hline(dl1, dx1, dEndTs, dy1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                dl1 := f_kill(dl1)
            array.set(daily_l_q1o, dk, dl1)

            float dy2 = array.get(daily_h_q2o, dk)
            int   dx2 = array.get(daily_h_q2oTs, dk)
            line  dl2 = array.get(daily_l_q2o, dk)
            if not na(dy2) and not na(dx2) and not na(dEndTs)
                dl2 := f_set_or_make_hline(dl2, dx2, dEndTs, dy2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                dl2 := f_kill(dl2)
            array.set(daily_l_q2o, dk, dl2)

            float dy3 = array.get(daily_h_q3o, dk)
            int   dx3 = array.get(daily_h_q3oTs, dk)
            line  dl3 = array.get(daily_l_q3o, dk)
            if not na(dy3) and not na(dx3) and not na(dEndTs)
                dl3 := f_set_or_make_hline(dl3, dx3, dEndTs, dy3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                dl3 := f_kill(dl3)
            array.set(daily_l_q3o, dk, dl3)

            float dy4 = array.get(daily_h_q4o, dk)
            int   dx4 = array.get(daily_h_q4oTs, dk)
            line  dl4 = array.get(daily_l_q4o, dk)
            if not na(dy4) and not na(dx4) and not na(dEndTs)
                dl4 := f_set_or_make_hline(dl4, dx4, dEndTs, dy4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                dl4 := f_kill(dl4)
            array.set(daily_l_q4o, dk, dl4)

            dk += 1

if not showMicroTf
    vset_clear(microV)
    microProjQ2  := f_kill(microProjQ2)
    microProjQ3  := f_kill(microProjQ3)
    microProjQ4  := f_kill(microProjQ4)
    microProjEnd := f_kill(microProjEnd)

    int mi = array.size(microHistStart) - 1
    while mi >= 0
        f_mhist_kill_at(mi)
        mi -= 1
    array.clear(microHistStart), array.clear(microHistEnd)
    array.clear(micro_h_q1o), array.clear(micro_h_q1oTs)
    array.clear(micro_h_q2o), array.clear(micro_h_q2oTs)
    array.clear(micro_h_q3o), array.clear(micro_h_q3oTs)
    array.clear(micro_h_q4o), array.clear(micro_h_q4oTs)
    array.clear(micro_l_q1o), array.clear(micro_l_q2o), array.clear(micro_l_q3o), array.clear(micro_l_q4o)
    array.clear(microStarts)
else
    if not na(m.q2Ts)
        microProjQ2 := tc > m.q2Ts ? f_kill(microProjQ2) : f_set_or_make_vline(microProjQ2, m.q2Ts, COL_Q2)
    if not na(m.q3Ts)
        microProjQ3 := tc > m.q3Ts ? f_kill(microProjQ3) : f_set_or_make_vline(microProjQ3, m.q3Ts, COL_Q3)
    if not na(m.q4Ts)
        microProjQ4 := tc > m.q4Ts ? f_kill(microProjQ4) : f_set_or_make_vline(microProjQ4, m.q4Ts, COL_Q4)

    if not na(m.endTs)
        microProjEnd := f_set_or_make_vline(microProjEnd, m.endTs, COL_Q1)

    if m.inWindow and not na(m.q1Ts)
        f_push_unique_int(microStarts, m.q1Ts, STORE_MAX)

    int mCutoff = na(m.q1Ts) ? 0 : m.q1Ts
    int mAvail = array.size(microStarts)
    int mUse   = math.min(keepEff, mAvail)
    int mFirst = mAvail - mUse
    if mUse > 0
        mCutoff := array.get(microStarts, mFirst)

    vset_trim_since(microV, mCutoff)

    f_mhist_ensure_current()
    f_mhist_trim_cutoff(mCutoff)

    if m.inWindow
        if not na(m.q1Ts) and tc > m.q1Ts
            vset_add(microV, m.q1Ts, COL_Q1)
        if not na(m.q2Ts) and tc > m.q2Ts
            vset_add(microV, m.q2Ts, COL_Q2)
        if not na(m.q3Ts) and tc > m.q3Ts
            vset_add(microV, m.q3Ts, COL_Q3)
        if not na(m.q4Ts) and tc > m.q4Ts
            vset_add(microV, m.q4Ts, COL_Q4)
        if not na(m.endTs) and tc > m.endTs
            vset_add(microV, m.endTs, COL_Q1)

    if not showOpens
        int mj = array.size(microHistStart) - 1
        while mj >= 0
            f_mhist_kill_at(mj)
            mj -= 1
    else
        int msz = array.size(microHistStart)
        int mk = 0
        while mk < msz
            int mEndTs = array.get(microHistEnd, mk)

            float my1 = array.get(micro_h_q1o, mk)
            int   mx1 = array.get(micro_h_q1oTs, mk)
            line  ml1 = array.get(micro_l_q1o, mk)
            if not na(my1) and not na(mx1) and not na(mEndTs)
                ml1 := f_set_or_make_hline(ml1, mx1, mEndTs, my1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                ml1 := f_kill(ml1)
            array.set(micro_l_q1o, mk, ml1)

            float my2 = array.get(micro_h_q2o, mk)
            int   mx2 = array.get(micro_h_q2oTs, mk)
            line  ml2 = array.get(micro_l_q2o, mk)
            if not na(my2) and not na(mx2) and not na(mEndTs)
                ml2 := f_set_or_make_hline(ml2, mx2, mEndTs, my2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                ml2 := f_kill(ml2)
            array.set(micro_l_q2o, mk, ml2)

            float my3 = array.get(micro_h_q3o, mk)
            int   mx3 = array.get(micro_h_q3oTs, mk)
            line  ml3 = array.get(micro_l_q3o, mk)
            if not na(my3) and not na(mx3) and not na(mEndTs)
                ml3 := f_set_or_make_hline(ml3, mx3, mEndTs, my3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                ml3 := f_kill(ml3)
            array.set(micro_l_q3o, mk, ml3)

            float my4 = array.get(micro_h_q4o, mk)
            int   mx4 = array.get(micro_h_q4oTs, mk)
            line  ml4 = array.get(micro_l_q4o, mk)
            if not na(my4) and not na(mx4) and not na(mEndTs)
                ml4 := f_set_or_make_hline(ml4, mx4, mEndTs, my4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                ml4 := f_kill(ml4)
            array.set(micro_l_q4o, mk, ml4)

            mk += 1

if not show90mTf
    vset_clear(m90V)
    m90ProjQ2  := f_kill(m90ProjQ2)
    m90ProjQ3  := f_kill(m90ProjQ3)
    m90ProjQ4  := f_kill(m90ProjQ4)
    m90ProjEnd := f_kill(m90ProjEnd)

    int m90i = array.size(m90HistStart) - 1
    while m90i >= 0
        f_m90hist_kill_at(m90i)
        m90i -= 1
    array.clear(m90HistStart), array.clear(m90HistEnd)
    array.clear(m90_h_q1o), array.clear(m90_h_q1oTs)
    array.clear(m90_h_q2o), array.clear(m90_h_q2oTs)
    array.clear(m90_h_q3o), array.clear(m90_h_q3oTs)
    array.clear(m90_h_q4o), array.clear(m90_h_q4oTs)
    array.clear(m90_l_q1o), array.clear(m90_l_q2o), array.clear(m90_l_q3o), array.clear(m90_l_q4o)
    array.clear(m90Starts)
else
    if not na(m90.q2Ts)
        m90ProjQ2 := tc > m90.q2Ts ? f_kill(m90ProjQ2) : f_set_or_make_vline(m90ProjQ2, m90.q2Ts, COL_Q2)
    if not na(m90.q3Ts)
        m90ProjQ3 := tc > m90.q3Ts ? f_kill(m90ProjQ3) : f_set_or_make_vline(m90ProjQ3, m90.q3Ts, COL_Q3)
    if not na(m90.q4Ts)
        m90ProjQ4 := tc > m90.q4Ts ? f_kill(m90ProjQ4) : f_set_or_make_vline(m90ProjQ4, m90.q4Ts, COL_Q4)

    if not na(m90.endTs)
        m90ProjEnd := f_set_or_make_vline(m90ProjEnd, m90.endTs, COL_Q1)

    if m90.inWindow and not na(m90.q1Ts)
        f_push_unique_int(m90Starts, m90.q1Ts, STORE_MAX)

    int m90Cutoff = na(m90.q1Ts) ? 0 : m90.q1Ts
    int m90Avail = array.size(m90Starts)
    int m90Use   = math.min(keepEff, m90Avail)
    int m90First = m90Avail - m90Use
    if m90Use > 0
        m90Cutoff := array.get(m90Starts, m90First)

    vset_trim_since(m90V, m90Cutoff)

    f_m90hist_ensure_current()
    f_m90hist_trim_cutoff(m90Cutoff)

    if m90.inWindow
        if not na(m90.q1Ts) and tc > m90.q1Ts
            vset_add(m90V, m90.q1Ts, COL_Q1)
        if not na(m90.q2Ts) and tc > m90.q2Ts
            vset_add(m90V, m90.q2Ts, COL_Q2)
        if not na(m90.q3Ts) and tc > m90.q3Ts
            vset_add(m90V, m90.q3Ts, COL_Q3)
        if not na(m90.q4Ts) and tc > m90.q4Ts
            vset_add(m90V, m90.q4Ts, COL_Q4)
        if not na(m90.endTs) and tc > m90.endTs
            vset_add(m90V, m90.endTs, COL_Q1)

    if not showOpens
        int m90j = array.size(m90HistStart) - 1
        while m90j >= 0
            f_m90hist_kill_at(m90j)
            m90j -= 1
    else
        int m90sz = array.size(m90HistStart)
        int m90k = 0
        while m90k < m90sz
            int m90EndTs = array.get(m90HistEnd, m90k)

            float m90y1 = array.get(m90_h_q1o, m90k)
            int   m90x1 = array.get(m90_h_q1oTs, m90k)
            line  m90l1 = array.get(m90_l_q1o, m90k)
            if not na(m90y1) and not na(m90x1) and not na(m90EndTs)
                m90l1 := f_set_or_make_hline(m90l1, m90x1, m90EndTs, m90y1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                m90l1 := f_kill(m90l1)
            array.set(m90_l_q1o, m90k, m90l1)

            float m90y2 = array.get(m90_h_q2o, m90k)
            int   m90x2 = array.get(m90_h_q2oTs, m90k)
            line  m90l2 = array.get(m90_l_q2o, m90k)
            if not na(m90y2) and not na(m90x2) and not na(m90EndTs)
                m90l2 := f_set_or_make_hline(m90l2, m90x2, m90EndTs, m90y2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                m90l2 := f_kill(m90l2)
            array.set(m90_l_q2o, m90k, m90l2)

            float m90y3 = array.get(m90_h_q3o, m90k)
            int   m90x3 = array.get(m90_h_q3oTs, m90k)
            line  m90l3 = array.get(m90_l_q3o, m90k)
            if not na(m90y3) and not na(m90x3) and not na(m90EndTs)
                m90l3 := f_set_or_make_hline(m90l3, m90x3, m90EndTs, m90y3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                m90l3 := f_kill(m90l3)
            array.set(m90_l_q3o, m90k, m90l3)

            float m90y4 = array.get(m90_h_q4o, m90k)
            int   m90x4 = array.get(m90_h_q4oTs, m90k)
            line  m90l4 = array.get(m90_l_q4o, m90k)
            if not na(m90y4) and not na(m90x4) and not na(m90EndTs)
                m90l4 := f_set_or_make_hline(m90l4, m90x4, m90EndTs, m90y4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                m90l4 := f_kill(m90l4)
            array.set(m90_l_q4o, m90k, m90l4)

            m90k += 1

if not showNanoTf
    // Clear everything
    vset_clear(nanoV)
    projQ2  := f_kill(projQ2)
    projQ3  := f_kill(projQ3)
    projQ4  := f_kill(projQ4)
    projEnd := f_kill(projEnd)

    // Kill open lines + clear history arrays
    int i = array.size(histStart) - 1
    while i >= 0
        f_hist_kill_at(i)
        i -= 1
    array.clear(histStart), array.clear(histEnd)
    array.clear(h_q1o), array.clear(h_q1oTs)
    array.clear(h_q2o), array.clear(h_q2oTs)
    array.clear(h_q3o), array.clear(h_q3oTs)
    array.clear(h_q4o), array.clear(h_q4oTs)
    array.clear(l_q1o), array.clear(l_q2o), array.clear(l_q3o), array.clear(l_q4o)

    array.clear(nanoStarts)
else
    // Projections (future boundaries only; killed once passed)
    if not na(n.q2Ts)
        projQ2 := tc > n.q2Ts ? f_kill(projQ2) : f_set_or_make_vline(projQ2, n.q2Ts, COL_Q2)
    if not na(n.q3Ts)
        projQ3 := tc > n.q3Ts ? f_kill(projQ3) : f_set_or_make_vline(projQ3, n.q3Ts, COL_Q3)
    if not na(n.q4Ts)
        projQ4 := tc > n.q4Ts ? f_kill(projQ4) : f_set_or_make_vline(projQ4, n.q4Ts, COL_Q4)

    // End projection always visible for the active cycle
    if not na(n.endTs)
        projEnd := f_set_or_make_vline(projEnd, n.endTs, COL_Q1)

    // Track printed cycle starts
    if n.inWindow and not na(n.q1Ts)
        f_push_unique_int(nanoStarts, n.q1Ts, STORE_MAX)

    int cutoff = na(n.q1Ts) ? 0 : n.q1Ts
    int nAvail = array.size(nanoStarts)
    int nUse   = math.min(keepEff, nAvail)
    int first  = nAvail - nUse
    if nUse > 0
        cutoff := array.get(nanoStarts, first)

    // Trim realized divider set to cutoff window
    vset_trim_since(nanoV, cutoff)

    // Update current-cycle snapshot (from QTCore) into open history
    f_hist_ensure_current()

    // Trim open history to cutoff
    f_hist_trim_cutoff(cutoff)

    // Realized dividers (persist via vset; windowed by keepCycles)
    if n.inWindow
        if not na(n.q1Ts) and tc > n.q1Ts
            vset_add(nanoV, n.q1Ts, COL_Q1)
        if not na(n.q2Ts) and tc > n.q2Ts
            vset_add(nanoV, n.q2Ts, COL_Q2)
        if not na(n.q3Ts) and tc > n.q3Ts
            vset_add(nanoV, n.q3Ts, COL_Q3)
        if not na(n.q4Ts) and tc > n.q4Ts
            vset_add(nanoV, n.q4Ts, COL_Q4)

        // Only persist cycle-end once it’s actually passed
        if not na(n.endTs) and tc > n.endTs
            vset_add(nanoV, n.endTs, COL_Q1)

    // Draw/update open lines for every retained cycle
    if not showOpens
        int j = array.size(histStart) - 1
        while j >= 0
            f_hist_kill_at(j)
            j -= 1
    else
        int sz = array.size(histStart)
        int k = 0
        while k < sz
            int endTs = array.get(histEnd, k)

            // Q1 open line
            float y1 = array.get(h_q1o, k)
            int   x1 = array.get(h_q1oTs, k)
            line  l1 = array.get(l_q1o, k)
            if not na(y1) and not na(x1) and not na(endTs)
                l1 := f_set_or_make_hline(l1, x1, endTs, y1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                l1 := f_kill(l1)
            array.set(l_q1o, k, l1)

            // Q2 open / true open line
            float y2 = array.get(h_q2o, k)
            int   x2 = array.get(h_q2oTs, k)
            line  l2 = array.get(l_q2o, k)
            if not na(y2) and not na(x2) and not na(endTs)
                l2 := f_set_or_make_hline(l2, x2, endTs, y2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                l2 := f_kill(l2)
            array.set(l_q2o, k, l2)

            // Q3 open line
            float y3 = array.get(h_q3o, k)
            int   x3 = array.get(h_q3oTs, k)
            line  l3 = array.get(l_q3o, k)
            if not na(y3) and not na(x3) and not na(endTs)
                l3 := f_set_or_make_hline(l3, x3, endTs, y3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                l3 := f_kill(l3)
            array.set(l_q3o, k, l3)

            // Q4 open line
            float y4 = array.get(h_q4o, k)
            int   x4 = array.get(h_q4oTs, k)
            line  l4 = array.get(l_q4o, k)
            if not na(y4) and not na(x4) and not na(endTs)
                l4 := f_set_or_make_hline(l4, x4, endTs, y4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                l4 := f_kill(l4)
            array.set(l_q4o, k, l4)

            k += 1

if not showWeeklyTf
    vset_clear(weeklyV)
    weekProjQ2  := f_kill(weekProjQ2)
    weekProjQ3  := f_kill(weekProjQ3)
    weekProjQ4  := f_kill(weekProjQ4)
    weekProjQ5  := f_kill(weekProjQ5)
    weekProjEnd := f_kill(weekProjEnd)
    int wi = array.size(weeklyHistStart) - 1
    while wi >= 0
        f_whist_kill_at(wi)
        wi -= 1
    array.clear(weeklyHistStart), array.clear(weeklyHistEnd)
    array.clear(weekly_h_q1o), array.clear(weekly_h_q1oTs)
    array.clear(weekly_h_q2o), array.clear(weekly_h_q2oTs)
    array.clear(weekly_h_q3o), array.clear(weekly_h_q3oTs)
    array.clear(weekly_h_q4o), array.clear(weekly_h_q4oTs)
    array.clear(weekly_h_q5o), array.clear(weekly_h_q5oTs)
    array.clear(weekly_l_q1o), array.clear(weekly_l_q2o), array.clear(weekly_l_q3o), array.clear(weekly_l_q4o), array.clear(weekly_l_q5o)
    array.clear(weeklyStarts)
else
    if not na(w.wsEff)
        f_push_unique_int(weeklyStarts, w.wsEff, STORE_MAX)

    int wCutoff = na(w.wsEff) ? 0 : w.wsEff
    int wAvail = array.size(weeklyStarts)
    int wUse   = math.min(keepEff, wAvail)
    int wFirst = wAvail - wUse
    if wUse > 0
        wCutoff := array.get(weeklyStarts, wFirst)

    vset_trim_since(weeklyV, wCutoff)
    f_whist_ensure_current()
    f_whist_trim_cutoff(wCutoff)

    if not na(w.wsEff) and tc > w.wsEff
        vset_add(weeklyV, w.wsEff, COL_Q1)
    if not na(w.q2.startEff) and tc > w.q2.startEff
        vset_add(weeklyV, w.q2.startEff, COL_Q2)
    if not na(w.q3.startEff) and tc > w.q3.startEff
        vset_add(weeklyV, w.q3.startEff, COL_Q3)
    if not na(w.q4.startEff) and tc > w.q4.startEff
        vset_add(weeklyV, w.q4.startEff, COL_Q4)
    if not na(w.q5.startEff) and tc > w.q5.startEff
        vset_add(weeklyV, w.q5.startEff, COL_Q5)
    if not na(w.wsNextEff) and tc > w.wsNextEff
        vset_add(weeklyV, w.wsNextEff, COL_Q1)

    // Weekly projections (intent-based; kill once passed)
    if not na(w.q2.startIntent) and tc <= w.q2.startIntent
        weekProjQ2 := f_set_or_make_vline(weekProjQ2, w.q2.startIntent, COL_Q2)
    else
        weekProjQ2 := f_kill(weekProjQ2)

    if not na(w.q3.startIntent) and tc <= w.q3.startIntent
        weekProjQ3 := f_set_or_make_vline(weekProjQ3, w.q3.startIntent, COL_Q3)
    else
        weekProjQ3 := f_kill(weekProjQ3)

    if not na(w.q4.startIntent) and tc <= w.q4.startIntent
        weekProjQ4 := f_set_or_make_vline(weekProjQ4, w.q4.startIntent, COL_Q4)
    else
        weekProjQ4 := f_kill(weekProjQ4)

    if not na(w.q5.startIntent) and tc <= w.q5.startIntent
        weekProjQ5 := f_set_or_make_vline(weekProjQ5, w.q5.startIntent, COL_Q5)
    else
        weekProjQ5 := f_kill(weekProjQ5)

    if not na(w.wsNextIntent)
        weekProjEnd := f_set_or_make_vline(weekProjEnd, w.wsNextIntent, COL_Q1)

    if not showOpens
        int wj = array.size(weeklyHistStart) - 1
        while wj >= 0
            f_whist_kill_at(wj)
            wj -= 1
    else
        int wsz = array.size(weeklyHistStart)
        int wk = 0
        while wk < wsz
            int wEndTs = array.get(weeklyHistEnd, wk)

            float wy1 = array.get(weekly_h_q1o, wk)
            int   wx1 = array.get(weekly_h_q1oTs, wk)
            line  wl1 = array.get(weekly_l_q1o, wk)
            if not na(wy1) and not na(wx1) and not na(wEndTs)
                wl1 := f_set_or_make_hline(wl1, wx1, wEndTs, wy1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                wl1 := f_kill(wl1)
            array.set(weekly_l_q1o, wk, wl1)

            float wy2 = array.get(weekly_h_q2o, wk)
            int   wx2 = array.get(weekly_h_q2oTs, wk)
            line  wl2 = array.get(weekly_l_q2o, wk)
            if not na(wy2) and not na(wx2) and not na(wEndTs)
                wl2 := f_set_or_make_hline(wl2, wx2, wEndTs, wy2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                wl2 := f_kill(wl2)
            array.set(weekly_l_q2o, wk, wl2)

            float wy3 = array.get(weekly_h_q3o, wk)
            int   wx3 = array.get(weekly_h_q3oTs, wk)
            line  wl3 = array.get(weekly_l_q3o, wk)
            if not na(wy3) and not na(wx3) and not na(wEndTs)
                wl3 := f_set_or_make_hline(wl3, wx3, wEndTs, wy3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                wl3 := f_kill(wl3)
            array.set(weekly_l_q3o, wk, wl3)

            float wy4 = array.get(weekly_h_q4o, wk)
            int   wx4 = array.get(weekly_h_q4oTs, wk)
            line  wl4 = array.get(weekly_l_q4o, wk)
            if not na(wy4) and not na(wx4) and not na(wEndTs)
                wl4 := f_set_or_make_hline(wl4, wx4, wEndTs, wy4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                wl4 := f_kill(wl4)
            array.set(weekly_l_q4o, wk, wl4)

            float wy5 = array.get(weekly_h_q5o, wk)
            int   wx5 = array.get(weekly_h_q5oTs, wk)
            line  wl5 = array.get(weekly_l_q5o, wk)
            if not na(wy5) and not na(wx5) and not na(wEndTs)
                wl5 := f_set_or_make_hline(wl5, wx5, wEndTs, wy5, f_vcol(COL_Q5), lineStyleFrom(q4OpenStyleStr))
            else
                wl5 := f_kill(wl5)
            array.set(weekly_l_q5o, wk, wl5)

            wk += 1
