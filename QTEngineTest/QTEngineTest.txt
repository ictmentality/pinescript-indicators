//@version=6
indicator("QTEngine Test", overlay=true, max_lines_count=500, max_labels_count=500)

import Jaw1312/QTEngine/12 as qt

// -----------------------------------------------------------------------------
// Inputs
// -----------------------------------------------------------------------------
groupCycles = "TIME CYCLES"
showDaily = input.bool(true, "Daily (24h cycle; q=6h)", group=groupCycles)
show90m  = input.bool(true, "90m (6h cycle; q=90m)", group=groupCycles)
showMicro = input.bool(true, "Micro (90m cycle; q=22m30s)", group=groupCycles)
showNano  = input.bool(true, "Nano (22m30s cycle; q=5m37.5s)", group=groupCycles)

groupAll = "CYCLE SETTINGS"
showOpens = input.bool(true, "Show Opens", group=groupAll)
keepCycles = input.int(4, "# of Cycles", minval=1, maxval=200, group=groupAll)

q1OpenCol = input.color(color.new(color.rgb(99, 99, 99), 70), "Q1 Open Color", group=groupAll)
q2OpenCol = input.color(color.new(color.rgb(242, 54, 69), 70), "Q2 Open / True Open Color", group=groupAll)
q3OpenCol = input.color(color.new(color.rgb(76, 175, 80), 70), "Q3 Open Color", group=groupAll)
q4OpenCol = input.color(color.new(color.rgb(41, 98, 255), 70), "Q4 Open Color", group=groupAll)

q1OpenStyleStr = input.string("Dashed", "Q1 Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)
q2OpenStyleStr = input.string("Dashed", "Q2 Open / True Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)
q3OpenStyleStr = input.string("Dashed", "Q3 Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)
q4OpenStyleStr = input.string("Dashed", "Q4 Open Style", options=["Solid", "Dashed", "Dotted"], group=groupAll)

groupDW      = "DATA WINDOW"
dw90mStep1  = input.bool(true, "Step 1 — 90m boundaryTs checks", group=groupDW)
dwMicroStep1 = input.bool(true, "Step 1 — Micro boundaryTs checks", group=groupDW)
dwMicroStep2 = input.bool(true, "Step 2 — Micro QuarterRecord (q1–q4) — minimal", group=groupDW)
dwNanoStep1  = input.bool(true, "Step 1 — Nano boundaryTs checks", group=groupDW)
dwNanoStep2  = input.bool(true, "Step 2 — Nano QuarterRecord (q1–q4) — minimal", group=groupDW)

groupDbg = "ALIGNED TF DEBUG"
showAlignedOhlc = input.bool(false, "Show aligned TF OHLC table", group=groupDbg)

// -----------------------------------------------------------------------------
// Color palette (Old QT Indicator) + divider opacity rule
// -----------------------------------------------------------------------------
var color COL_Q1 = color.rgb(99, 99, 99)      // #636363
var color COL_Q2 = color.rgb(242, 54, 69)     // #f23645
var color COL_Q3 = color.rgb(76, 175, 80)     // #4caf50
var color COL_Q4 = color.rgb(41, 98, 255)     // #2962ff

var int V_TRANSP = 70
f_vcol(color c) =>
    color.new(c, V_TRANSP)

// -----------------------------------------------------------------------------
// Helpers (display-only)
// -----------------------------------------------------------------------------
f_hhmmss(int ts, string tz) =>
    int hh = hour(ts, tz)
    int mm = minute(ts, tz)
    int ss = second(ts, tz)
    float(hh * 10000 + mm * 100 + ss)

f_fmt(float v) =>
    na(v) ? "-" : str.tostring(v)

f_fmt_time(int ts, string tz) =>
    na(ts) ? "-" : str.tostring(f_hhmmss(ts, tz))

f_ceil_5s(int ts) =>
    int step = 5 * 1000
    int rem = ts % step
    rem == 0 ? ts : ts + (step - rem)

// -----------------------------------------------------------------------------
// Visibility Alignments (hardcoded)
// Nano  = 5s - 15s
// Micro = 30s - 4m
// 90m   = 5m - 14m
// Daily = 15m - 30m
// -----------------------------------------------------------------------------
int tfSec = timeframe.in_seconds(timeframe.period)
bool visNanoTf = not na(tfSec) and tfSec >= 5 and tfSec <= 15
bool visMicroTf = not na(tfSec) and tfSec >= 30 and tfSec <= 240
bool vis90mTf = not na(tfSec) and tfSec >= 300 and tfSec <= 840
bool visDailyTf = not na(tfSec) and tfSec >= 900 and tfSec <= 1800
bool showNanoTf = showNano and visNanoTf
bool showMicroTf = showMicro and visMicroTf
bool show90mTf = show90m and vis90mTf
bool showDailyTf = showDaily and visDailyTf

// QTIndicator mapping (string → TradingView style)
lineStyleFrom(string s) =>
    switch s
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        =>          line.style_dotted

f_clamp_int(int v, int lo, int hi) =>
    v < lo ? lo : v > hi ? hi : v

f_pick_qr(int idx, qt.QuarterRecord q1, qt.QuarterRecord q2, qt.QuarterRecord q3, qt.QuarterRecord q4) =>
    qt.QuarterRecord out = q1
    if idx == 2
        out := q2
    else if idx == 3
        out := q3
    else if idx == 4
        out := q4
    out

// -----------------------------------------------------------------------------
// Array helpers
// -----------------------------------------------------------------------------
f_find_int(int[] arr, int v) =>
    int idx = -1
    int i = array.size(arr) - 1
    while i >= 0 and idx == -1
        if array.get(arr, i) == v
            idx := i
        i -= 1
    idx

f_push_unique_int(int[] arr, int v, int maxN) =>
    if f_find_int(arr, v) == -1
        array.push(arr, v)
        while array.size(arr) > maxN
            array.shift(arr)
    0

// -----------------------------------------------------------------------------
// Old-QT vertical divider line storage helpers
// -----------------------------------------------------------------------------
type vset
    line[] ln
    int[]  ts

vset_new() =>
    vset.new(array.new_line(), array.new_int())

vset_clear(vset s) =>
    int i = array.size(s.ln) - 1
    while i >= 0
        line.delete(array.get(s.ln, i))
        i -= 1
    array.clear(s.ln)
    array.clear(s.ts)
    0

vset_has(vset s, int ts) =>
    bool found = false
    int i = array.size(s.ts) - 1
    while i >= 0 and not found
        found := array.get(s.ts, i) == ts
        i -= 1
    found

vset_add(vset s, int ts, color c) =>
    if not vset_has(s, ts)
        array.push(s.ln, line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c)))
        array.push(s.ts, ts)
    0

vset_trim_since(vset s, int cutoffTs) =>
    int i = array.size(s.ts) - 1
    while i >= 0
        int t = array.get(s.ts, i)
        if t < cutoffTs
            line ln = array.remove(s.ln, i)
            line.delete(ln)
            array.remove(s.ts, i)
        i -= 1
    0

f_set_or_make_vline(line ln, int ts, color c) =>
    line out = ln
    if na(out)
        out := line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c))
    else
        line.set_xy1(out, ts, low)
        line.set_xy2(out, ts, high)
        line.set_style(out, line.style_solid)
        line.set_width(out, 1)
        line.set_color(out, f_vcol(c))
    out

f_set_or_make_hline(line ln, int x1, int x2, float y, color c, sty) =>
    line out = ln
    if na(out)
        out := line.new(x1, y, x2, y, xloc=xloc.bar_time, extend=extend.none, style=sty, width=1, color=c)
    else
        line.set_xy1(out, x1, y)
        line.set_xy2(out, x2, y)
        line.set_extend(out, extend.none)
        line.set_style(out, sty)
        line.set_width(out, 1)
        line.set_color(out, c)
    out

f_kill(line ln) =>
    line out = na
    if not na(ln)
        line.delete(ln)
    out

// -----------------------------------------------------------------------------
// QT Core update (Daily + 90m + Micro + Nano)
// -----------------------------------------------------------------------------
var qt.QTConfig   cfg = qt.qt_config_default()
var qt.CycleState st  = qt.qt_state_new()

int t  = time
int tc = time_close

[st0, d] = qt.qt_daily_update(st, cfg, t, tc)
[st1, m90] = qt.qt_m90_update(st0, cfg, t, tc)
[st2, m] = qt.qt_micro_update(st1, cfg, t, tc)
[st3, n] = qt.qt_nano_update(st2, cfg, t, tc)
st := st3

[m_aq1, m_aq2, m_aq3, m_aq4] = qt.qt_micro_aligned_qr_debug(st)
[n_aq1, n_aq2, n_aq3, n_aq4] = qt.qt_nano_aligned_qr_debug(st)
qt.QuarterRecord m90_q = f_pick_qr(m90.curQuarterIndex, m90.q1, m90.q2, m90.q3, m90.q4)
qt.QuarterRecord m_q = f_pick_qr(m.curQuarterIndex, m.q1, m.q2, m.q3, m.q4)
qt.QuarterRecord n_q = f_pick_qr(n.curQuarterIndex, n.q1, n.q2, n.q3, n.q4)

// -----------------------------------------------------------------------------
// Data Window — Step 1: boundaryTs checks
// -----------------------------------------------------------------------------
plot(show90mTf and dw90mStep1 ? m90.q1Ts : na, "90m q1Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? m90.q2Ts : na, "90m q2Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? m90.q3Ts : na, "90m q3Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? m90.q4Ts : na, "90m q4Ts", display=display.data_window)
plot(show90mTf and dw90mStep1 ? (m90.q2Realized ? 1.0 : 0.0) : na, "90m q2Realized", display=display.data_window)
plot(show90mTf and dw90mStep1 ? (m90.q3Realized ? 1.0 : 0.0) : na, "90m q3Realized", display=display.data_window)
plot(show90mTf and dw90mStep1 ? (m90.q4Realized ? 1.0 : 0.0) : na, "90m q4Realized", display=display.data_window)

plot(showMicroTf and dwMicroStep1 ? m.q1Ts : na, "Micro q1Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? m.q2Ts : na, "Micro q2Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? m.q3Ts : na, "Micro q3Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? m.q4Ts : na, "Micro q4Ts", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? (m.q2Realized ? 1.0 : 0.0) : na, "Micro q2Realized", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? (m.q3Realized ? 1.0 : 0.0) : na, "Micro q3Realized", display=display.data_window)
plot(showMicroTf and dwMicroStep1 ? (m.q4Realized ? 1.0 : 0.0) : na, "Micro q4Realized", display=display.data_window)

plot(showNanoTf and dwNanoStep1 ? n.q1Ts : na, "Nano q1Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? n.q2Ts : na, "Nano q2Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? n.q3Ts : na, "Nano q3Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? n.q4Ts : na, "Nano q4Ts", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? (n.q2Realized ? 1.0 : 0.0) : na, "Nano q2Realized", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? (n.q3Realized ? 1.0 : 0.0) : na, "Nano q3Realized", display=display.data_window)
plot(showNanoTf and dwNanoStep1 ? (n.q4Realized ? 1.0 : 0.0) : na, "Nano q4Realized", display=display.data_window)

// -----------------------------------------------------------------------------
// Data Window — Step 2: QuarterRecord (minimal)
// -----------------------------------------------------------------------------
float m_q1_o_hhmmss = f_hhmmss(m.q1.oTs, cfg.tz)
float m_q2_o_hhmmss = f_hhmmss(m.q2.oTs, cfg.tz)
float m_q3_o_hhmmss = f_hhmmss(m.q3.oTs, cfg.tz)
float m_q4_o_hhmmss = f_hhmmss(m.q4.oTs, cfg.tz)

plot(showMicroTf and dwMicroStep2 ? m.q1.o : na, "Micro QR q1.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q1.h : na, "Micro QR q1.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q1.l : na, "Micro QR q1.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q1.c : na, "Micro QR q1.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q1_o_hhmmss : na, "Micro QR q1.oTs (HHMMSS)", display=display.data_window)

plot(showMicroTf and dwMicroStep2 ? m.q2.o : na, "Micro QR q2.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q2.h : na, "Micro QR q2.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q2.l : na, "Micro QR q2.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q2.c : na, "Micro QR q2.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q2_o_hhmmss : na, "Micro QR q2.oTs (HHMMSS)", display=display.data_window)

plot(showMicroTf and dwMicroStep2 ? m.q3.o : na, "Micro QR q3.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q3.h : na, "Micro QR q3.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q3.l : na, "Micro QR q3.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q3.c : na, "Micro QR q3.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q3_o_hhmmss : na, "Micro QR q3.oTs (HHMMSS)", display=display.data_window)

plot(showMicroTf and dwMicroStep2 ? m.q4.o : na, "Micro QR q4.o", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q4.h : na, "Micro QR q4.h", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q4.l : na, "Micro QR q4.l", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m.q4.c : na, "Micro QR q4.c", display=display.data_window)
plot(showMicroTf and dwMicroStep2 ? m_q4_o_hhmmss : na, "Micro QR q4.oTs (HHMMSS)", display=display.data_window)

float n_q1_o_hhmmss = f_hhmmss(n.q1.oTs, cfg.tz)
float n_q2_o_hhmmss = f_hhmmss(n.q2.oTs, cfg.tz)
float n_q3_o_hhmmss = f_hhmmss(n.q3.oTs, cfg.tz)
float n_q4_o_hhmmss = f_hhmmss(n.q4.oTs, cfg.tz)

[nano_o5, nano_ts5, nano_qi5, nano_qcurts5] = qt.qt_nano_open_debug()
float nano_ts5_hhmmss = f_hhmmss(nano_ts5, cfg.tz)
float nano_qcurts5_hhmmss = f_hhmmss(nano_qcurts5, cfg.tz)
float nano_target_delta = not na(nano_ts5) and not na(nano_qcurts5) ? (nano_ts5 - f_ceil_5s(nano_qcurts5)) / 1000.0 : na

int n_qcurts_engine = n.curQuarterIndex == 1 ? n.q1Ts : n.curQuarterIndex == 2 ? n.q2Ts : n.curQuarterIndex == 3 ? n.q3Ts : n.q4Ts
float n_qcurts_delta = not na(n_qcurts_engine) and not na(nano_qcurts5) ? (nano_qcurts5 - n_qcurts_engine) / 1000.0 : na

int n_q1_target = f_ceil_5s(n.q1Ts)
int n_q2_target = f_ceil_5s(n.q2Ts)
int n_q3_target = f_ceil_5s(n.q3Ts)
int n_q4_target = f_ceil_5s(n.q4Ts)

float n_q1_target_hhmmss = f_hhmmss(n_q1_target, cfg.tz)
float n_q2_target_hhmmss = f_hhmmss(n_q2_target, cfg.tz)
float n_q3_target_hhmmss = f_hhmmss(n_q3_target, cfg.tz)
float n_q4_target_hhmmss = f_hhmmss(n_q4_target, cfg.tz)

float n_q1_open_delta = not na(n.q1.oTs) ? (n.q1.oTs - n_q1_target) / 1000.0 : na
float n_q2_open_delta = not na(n.q2.oTs) ? (n.q2.oTs - n_q2_target) / 1000.0 : na
float n_q3_open_delta = not na(n.q3.oTs) ? (n.q3.oTs - n_q3_target) / 1000.0 : na
float n_q4_open_delta = not na(n.q4.oTs) ? (n.q4.oTs - n_q4_target) / 1000.0 : na

// -----------------------------------------------------------------------------
// Aligned TF OHLC (read-only debug)
// -----------------------------------------------------------------------------
var table aligned_tbl = na
if showAlignedOhlc and barstate.islast
    if na(aligned_tbl)
        aligned_tbl := table.new(position.top_right, 4, 12, border_width=1, border_color=color.gray)
    table.cell(aligned_tbl, 0, 0, "Field", text_color=color.black, bgcolor=color.new(color.black, 60))
    table.cell(aligned_tbl, 1, 0, "90m 5m", text_color=color.black, bgcolor=color.new(color.black, 60))
    table.cell(aligned_tbl, 2, 0, "Micro 30s", text_color=color.black, bgcolor=color.new(color.black, 60))
    table.cell(aligned_tbl, 3, 0, "Nano 5s", text_color=color.black, bgcolor=color.new(color.black, 60))

    [m90_a_o, m90_a_h, m90_a_l, m90_a_c, m90_a_t] = qt.qt_m90_aligned_ohlc_debug()
    [m_a_o, m_a_h, m_a_l, m_a_c, m_a_t] = qt.qt_micro_aligned_ohlc_debug()
    [n_a_o, n_a_h, n_a_l, n_a_c, n_a_t] = qt.qt_nano_aligned_ohlc_debug()

    table.cell(aligned_tbl, 0, 1, "O", text_color=color.black)
    table.cell(aligned_tbl, 1, 1, f_fmt(m90_a_o), text_color=color.black)
    table.cell(aligned_tbl, 2, 1, f_fmt(m_a_o), text_color=color.black)
    table.cell(aligned_tbl, 3, 1, f_fmt(n_a_o), text_color=color.black)

    table.cell(aligned_tbl, 0, 2, "H", text_color=color.black)
    table.cell(aligned_tbl, 1, 2, f_fmt(m90_a_h), text_color=color.black)
    table.cell(aligned_tbl, 2, 2, f_fmt(m_a_h), text_color=color.black)
    table.cell(aligned_tbl, 3, 2, f_fmt(n_a_h), text_color=color.black)

    table.cell(aligned_tbl, 0, 3, "L", text_color=color.black)
    table.cell(aligned_tbl, 1, 3, f_fmt(m90_a_l), text_color=color.black)
    table.cell(aligned_tbl, 2, 3, f_fmt(m_a_l), text_color=color.black)
    table.cell(aligned_tbl, 3, 3, f_fmt(n_a_l), text_color=color.black)

    table.cell(aligned_tbl, 0, 4, "C", text_color=color.black)
    table.cell(aligned_tbl, 1, 4, f_fmt(m90_a_c), text_color=color.black)
    table.cell(aligned_tbl, 2, 4, f_fmt(m_a_c), text_color=color.black)
    table.cell(aligned_tbl, 3, 4, f_fmt(n_a_c), text_color=color.black)

    table.cell(aligned_tbl, 0, 5, "T", text_color=color.black)
    table.cell(aligned_tbl, 1, 5, f_fmt_time(m90_a_t, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 2, 5, f_fmt_time(m_a_t, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 3, 5, f_fmt_time(n_a_t, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 0, 6, "Qi", text_color=color.black)
    table.cell(aligned_tbl, 1, 6, str.tostring(m90.curQuarterIndex), text_color=color.black)
    table.cell(aligned_tbl, 2, 6, str.tostring(m.curQuarterIndex), text_color=color.black)
    table.cell(aligned_tbl, 3, 6, str.tostring(n.curQuarterIndex), text_color=color.black)
    table.cell(aligned_tbl, 0, 7, "QO", text_color=color.black)
    table.cell(aligned_tbl, 1, 7, f_fmt(m90_q.o), text_color=color.black)
    table.cell(aligned_tbl, 2, 7, f_fmt(m_q.o), text_color=color.black)
    table.cell(aligned_tbl, 3, 7, f_fmt(n_q.o), text_color=color.black)
    table.cell(aligned_tbl, 0, 8, "QH", text_color=color.black)
    table.cell(aligned_tbl, 1, 8, f_fmt(m90_q.h), text_color=color.black)
    table.cell(aligned_tbl, 2, 8, f_fmt(m_q.h), text_color=color.black)
    table.cell(aligned_tbl, 3, 8, f_fmt(n_q.h), text_color=color.black)
    table.cell(aligned_tbl, 0, 9, "QL", text_color=color.black)
    table.cell(aligned_tbl, 1, 9, f_fmt(m90_q.l), text_color=color.black)
    table.cell(aligned_tbl, 2, 9, f_fmt(m_q.l), text_color=color.black)
    table.cell(aligned_tbl, 3, 9, f_fmt(n_q.l), text_color=color.black)
    table.cell(aligned_tbl, 0, 10, "QC", text_color=color.black)
    table.cell(aligned_tbl, 1, 10, f_fmt(m90_q.c), text_color=color.black)
    table.cell(aligned_tbl, 2, 10, f_fmt(m_q.c), text_color=color.black)
    table.cell(aligned_tbl, 3, 10, f_fmt(n_q.c), text_color=color.black)
    table.cell(aligned_tbl, 0, 11, "QT", text_color=color.black)
    table.cell(aligned_tbl, 1, 11, f_fmt_time(m90_q.oTs, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 2, 11, f_fmt_time(m_q.oTs, cfg.tz), text_color=color.black)
    table.cell(aligned_tbl, 3, 11, f_fmt_time(n_q.oTs, cfg.tz), text_color=color.black)
else if not showAlignedOhlc and not na(aligned_tbl)
    table.delete(aligned_tbl)
    aligned_tbl := na

plot(showNanoTf and dwNanoStep2 ? n.q1.o : na, "Nano QR q1.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q1.h : na, "Nano QR q1.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q1.l : na, "Nano QR q1.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q1.c : na, "Nano QR q1.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q1_o_hhmmss : na, "Nano QR q1.oTs (HHMMSS)", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? nano_target_delta : na, "Nano 5s open delta (sec)", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_qcurts_delta : na, "Nano qCurTs mismatch (sec)", display=display.data_window)

plot(showNanoTf and dwNanoStep2 ? n.q2.o : na, "Nano QR q2.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q2.h : na, "Nano QR q2.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q2.l : na, "Nano QR q2.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q2.c : na, "Nano QR q2.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q2_o_hhmmss : na, "Nano QR q2.oTs (HHMMSS)", display=display.data_window)

plot(showNanoTf and dwNanoStep2 ? n.q3.o : na, "Nano QR q3.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q3.h : na, "Nano QR q3.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q3.l : na, "Nano QR q3.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q3.c : na, "Nano QR q3.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q3_o_hhmmss : na, "Nano QR q3.oTs (HHMMSS)", display=display.data_window)

plot(showNanoTf and dwNanoStep2 ? n.q4.o : na, "Nano QR q4.o", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q4.h : na, "Nano QR q4.h", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q4.l : na, "Nano QR q4.l", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n.q4.c : na, "Nano QR q4.c", display=display.data_window)
plot(showNanoTf and dwNanoStep2 ? n_q4_o_hhmmss : na, "Nano QR q4.oTs (HHMMSS)", display=display.data_window)

// -----------------------------------------------------------------------------
// Divider + cycle-window management (QTIndicator model)
// -----------------------------------------------------------------------------
// TODO Later: Add option to extend all opening lines an entire cycle length
var int MAX_LINES = 500
var int STORE_MAX = 800

// -----------------------------------------------------------------------------
// Daily cycle storage
// -----------------------------------------------------------------------------
var int[] dailyStarts = array.new_int()
var vset  dailyV = vset_new()

var line dailyProjQ2  = na
var line dailyProjQ3  = na
var line dailyProjQ4  = na
var line dailyProjEnd = na

var int[]   dailyHistStart = array.new_int()
var int[]   dailyHistEnd   = array.new_int()

var float[] daily_h_q1o   = array.new_float()
var int[]   daily_h_q1oTs = array.new_int()
var float[] daily_h_q2o   = array.new_float()
var int[]   daily_h_q2oTs = array.new_int()
var float[] daily_h_q3o   = array.new_float()
var int[]   daily_h_q3oTs = array.new_int()
var float[] daily_h_q4o   = array.new_float()
var int[]   daily_h_q4oTs = array.new_int()

var line[]  daily_l_q1o   = array.new_line()
var line[]  daily_l_q2o   = array.new_line()
var line[]  daily_l_q3o   = array.new_line()
var line[]  daily_l_q4o   = array.new_line()

f_dhist_kill_at(int idx) =>
    line a = array.get(daily_l_q1o, idx)
    line b = array.get(daily_l_q2o, idx)
    line c = array.get(daily_l_q3o, idx)
    line l4 = array.get(daily_l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(daily_l_q1o, idx, na)
    array.set(daily_l_q2o, idx, na)
    array.set(daily_l_q3o, idx, na)
    array.set(daily_l_q4o, idx, na)
    0

f_dhist_shift_front() =>
    if array.size(dailyHistStart) > 0
        f_dhist_kill_at(0)
        array.shift(dailyHistStart)
        array.shift(dailyHistEnd)

        array.shift(daily_h_q1o),  array.shift(daily_h_q1oTs)
        array.shift(daily_h_q2o),  array.shift(daily_h_q2oTs)
        array.shift(daily_h_q3o),  array.shift(daily_h_q3oTs)
        array.shift(daily_h_q4o),  array.shift(daily_h_q4oTs)

        array.shift(daily_l_q1o)
        array.shift(daily_l_q2o)
        array.shift(daily_l_q3o)
        array.shift(daily_l_q4o)
    0

f_dhist_trim_cutoff(int cutoffTs) =>
    while array.size(dailyHistStart) > 0 and array.get(dailyHistStart, 0) < cutoffTs
        f_dhist_shift_front()
    0

f_dhist_ensure_current() =>
    if d.inWindow and not na(d.q1Ts)
        int key = d.q1Ts
        int idx = f_find_int(dailyHistStart, key)
        if idx == -1
            array.push(dailyHistStart, key)
            array.push(dailyHistEnd, d.endTs)

            array.push(daily_h_q1o, na), array.push(daily_h_q1oTs, na)
            array.push(daily_h_q2o, na), array.push(daily_h_q2oTs, na)
            array.push(daily_h_q3o, na), array.push(daily_h_q3oTs, na)
            array.push(daily_h_q4o, na), array.push(daily_h_q4oTs, na)

            line naL = na
            array.push(daily_l_q1o, naL)
            array.push(daily_l_q2o, naL)
            array.push(daily_l_q3o, naL)
            array.push(daily_l_q4o, naL)
            idx := array.size(dailyHistStart) - 1

        array.set(dailyHistEnd, idx, d.endTs)

        float q1o = d.q1.o
        int   q1t = d.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(daily_h_q1o, idx, q1o)
            array.set(daily_h_q1oTs, idx, q1t)

        float q2o = d.q2.o
        int   q2t = d.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(daily_h_q2o, idx, q2o)
            array.set(daily_h_q2oTs, idx, q2t)

        float q3o = d.q3.o
        int   q3t = d.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(daily_h_q3o, idx, q3o)
            array.set(daily_h_q3oTs, idx, q3t)

        float q4o = d.q4.o
        int   q4t = d.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(daily_h_q4o, idx, q4o)
            array.set(daily_h_q4oTs, idx, q4t)

        while array.size(dailyHistStart) > STORE_MAX
            f_dhist_shift_front()
    0

// -----------------------------------------------------------------------------
// 90m cycle storage
// -----------------------------------------------------------------------------
var int[] m90Starts = array.new_int()
var vset  m90V = vset_new()

var line m90ProjQ2  = na
var line m90ProjQ3  = na
var line m90ProjQ4  = na
var line m90ProjEnd = na

var int[]   m90HistStart = array.new_int()
var int[]   m90HistEnd   = array.new_int()

var float[] m90_h_q1o   = array.new_float()
var int[]   m90_h_q1oTs = array.new_int()
var float[] m90_h_q2o   = array.new_float()
var int[]   m90_h_q2oTs = array.new_int()
var float[] m90_h_q3o   = array.new_float()
var int[]   m90_h_q3oTs = array.new_int()
var float[] m90_h_q4o   = array.new_float()
var int[]   m90_h_q4oTs = array.new_int()

var line[]  m90_l_q1o   = array.new_line()
var line[]  m90_l_q2o   = array.new_line()
var line[]  m90_l_q3o   = array.new_line()
var line[]  m90_l_q4o   = array.new_line()

f_m90hist_kill_at(int idx) =>
    line a = array.get(m90_l_q1o, idx)
    line b = array.get(m90_l_q2o, idx)
    line c = array.get(m90_l_q3o, idx)
    line l4 = array.get(m90_l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(m90_l_q1o, idx, na)
    array.set(m90_l_q2o, idx, na)
    array.set(m90_l_q3o, idx, na)
    array.set(m90_l_q4o, idx, na)
    0

f_m90hist_shift_front() =>
    if array.size(m90HistStart) > 0
        f_m90hist_kill_at(0)
        array.shift(m90HistStart)
        array.shift(m90HistEnd)

        array.shift(m90_h_q1o),  array.shift(m90_h_q1oTs)
        array.shift(m90_h_q2o),  array.shift(m90_h_q2oTs)
        array.shift(m90_h_q3o),  array.shift(m90_h_q3oTs)
        array.shift(m90_h_q4o),  array.shift(m90_h_q4oTs)

        array.shift(m90_l_q1o)
        array.shift(m90_l_q2o)
        array.shift(m90_l_q3o)
        array.shift(m90_l_q4o)
    0

f_m90hist_trim_cutoff(int cutoffTs) =>
    while array.size(m90HistStart) > 0 and array.get(m90HistStart, 0) < cutoffTs
        f_m90hist_shift_front()
    0

f_m90hist_ensure_current() =>
    if m90.inWindow and not na(m90.q1Ts)
        int key = m90.q1Ts
        int idx = f_find_int(m90HistStart, key)
        if idx == -1
            array.push(m90HistStart, key)
            array.push(m90HistEnd, m90.endTs)

            array.push(m90_h_q1o, na), array.push(m90_h_q1oTs, na)
            array.push(m90_h_q2o, na), array.push(m90_h_q2oTs, na)
            array.push(m90_h_q3o, na), array.push(m90_h_q3oTs, na)
            array.push(m90_h_q4o, na), array.push(m90_h_q4oTs, na)

            line naL = na
            array.push(m90_l_q1o, naL)
            array.push(m90_l_q2o, naL)
            array.push(m90_l_q3o, naL)
            array.push(m90_l_q4o, naL)
            idx := array.size(m90HistStart) - 1

        array.set(m90HistEnd, idx, m90.endTs)

        float q1o = m90.q1.o
        int   q1t = m90.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(m90_h_q1o, idx, q1o)
            array.set(m90_h_q1oTs, idx, q1t)

        float q2o = m90.q2.o
        int   q2t = m90.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(m90_h_q2o, idx, q2o)
            array.set(m90_h_q2oTs, idx, q2t)

        float q3o = m90.q3.o
        int   q3t = m90.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(m90_h_q3o, idx, q3o)
            array.set(m90_h_q3oTs, idx, q3t)

        float q4o = m90.q4.o
        int   q4t = m90.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(m90_h_q4o, idx, q4o)
            array.set(m90_h_q4oTs, idx, q4t)

        while array.size(m90HistStart) > STORE_MAX
            f_m90hist_shift_front()
    0

// -----------------------------------------------------------------------------
// Micro cycle storage
// -----------------------------------------------------------------------------
var int[] microStarts = array.new_int()
var vset  microV = vset_new()

var line microProjQ2  = na
var line microProjQ3  = na
var line microProjQ4  = na
var line microProjEnd = na

var int[]   microHistStart = array.new_int()
var int[]   microHistEnd   = array.new_int()

var float[] micro_h_q1o   = array.new_float()
var int[]   micro_h_q1oTs = array.new_int()
var float[] micro_h_q2o   = array.new_float()
var int[]   micro_h_q2oTs = array.new_int()
var float[] micro_h_q3o   = array.new_float()
var int[]   micro_h_q3oTs = array.new_int()
var float[] micro_h_q4o   = array.new_float()
var int[]   micro_h_q4oTs = array.new_int()

var line[]  micro_l_q1o   = array.new_line()
var line[]  micro_l_q2o   = array.new_line()
var line[]  micro_l_q3o   = array.new_line()
var line[]  micro_l_q4o   = array.new_line()

f_mhist_kill_at(int idx) =>
    line a = array.get(micro_l_q1o, idx)
    line b = array.get(micro_l_q2o, idx)
    line c = array.get(micro_l_q3o, idx)
    line l4 = array.get(micro_l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(micro_l_q1o, idx, na)
    array.set(micro_l_q2o, idx, na)
    array.set(micro_l_q3o, idx, na)
    array.set(micro_l_q4o, idx, na)
    0

f_mhist_shift_front() =>
    if array.size(microHistStart) > 0
        f_mhist_kill_at(0)
        array.shift(microHistStart)
        array.shift(microHistEnd)

        array.shift(micro_h_q1o),  array.shift(micro_h_q1oTs)
        array.shift(micro_h_q2o),  array.shift(micro_h_q2oTs)
        array.shift(micro_h_q3o),  array.shift(micro_h_q3oTs)
        array.shift(micro_h_q4o),  array.shift(micro_h_q4oTs)

        array.shift(micro_l_q1o)
        array.shift(micro_l_q2o)
        array.shift(micro_l_q3o)
        array.shift(micro_l_q4o)
    0

f_mhist_trim_cutoff(int cutoffTs) =>
    while array.size(microHistStart) > 0 and array.get(microHistStart, 0) < cutoffTs
        f_mhist_shift_front()
    0

f_mhist_ensure_current() =>
    if m.inWindow and not na(m.q1Ts)
        int key = m.q1Ts
        int idx = f_find_int(microHistStart, key)
        if idx == -1
            array.push(microHistStart, key)
            array.push(microHistEnd, m.endTs)

            array.push(micro_h_q1o, na), array.push(micro_h_q1oTs, na)
            array.push(micro_h_q2o, na), array.push(micro_h_q2oTs, na)
            array.push(micro_h_q3o, na), array.push(micro_h_q3oTs, na)
            array.push(micro_h_q4o, na), array.push(micro_h_q4oTs, na)

            line naL = na
            array.push(micro_l_q1o, naL)
            array.push(micro_l_q2o, naL)
            array.push(micro_l_q3o, naL)
            array.push(micro_l_q4o, naL)
            idx := array.size(microHistStart) - 1

        array.set(microHistEnd, idx, m.endTs)

        float q1o = m.q1.o
        int   q1t = m.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(micro_h_q1o, idx, q1o)
            array.set(micro_h_q1oTs, idx, q1t)

        float q2o = m.q2.o
        int   q2t = m.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(micro_h_q2o, idx, q2o)
            array.set(micro_h_q2oTs, idx, q2t)

        float q3o = m.q3.o
        int   q3t = m.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(micro_h_q3o, idx, q3o)
            array.set(micro_h_q3oTs, idx, q3t)

        float q4o = m.q4.o
        int   q4t = m.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(micro_h_q4o, idx, q4o)
            array.set(micro_h_q4oTs, idx, q4t)

        while array.size(microHistStart) > STORE_MAX
            f_mhist_shift_front()
    0

// -----------------------------------------------------------------------------
// Nano cycle storage
// -----------------------------------------------------------------------------
var int[] nanoStarts = array.new_int()
var vset  nanoV = vset_new()

var line projQ2  = na
var line projQ3  = na
var line projQ4  = na
var line projEnd = na

// -----------------------------------------------------------------------------
// Open-line history (per displayed cycle) — values captured from QTCore during
// the cycle, then retained + drawn as long as the cycle is inside keepCycles.
// -----------------------------------------------------------------------------
var int[]   histStart = array.new_int()
var int[]   histEnd   = array.new_int()

var float[] h_q1o     = array.new_float()
var int[]   h_q1oTs   = array.new_int()
var float[] h_q2o     = array.new_float()
var int[]   h_q2oTs   = array.new_int()
var float[] h_q3o     = array.new_float()
var int[]   h_q3oTs   = array.new_int()
var float[] h_q4o     = array.new_float()
var int[]   h_q4oTs   = array.new_int()

var line[]  l_q1o     = array.new_line()
var line[]  l_q2o     = array.new_line()
var line[]  l_q3o     = array.new_line()
var line[]  l_q4o     = array.new_line()

f_hist_kill_at(int idx) =>
    line a = array.get(l_q1o, idx)
    line b = array.get(l_q2o, idx)
    line c = array.get(l_q3o, idx)
    line l4 = array.get(l_q4o, idx)
    if not na(a)
        line.delete(a)
    if not na(b)
        line.delete(b)
    if not na(c)
        line.delete(c)
    if not na(l4)
        line.delete(l4)
    array.set(l_q1o, idx, na)
    array.set(l_q2o, idx, na)
    array.set(l_q3o, idx, na)
    array.set(l_q4o, idx, na)
    0

f_hist_shift_front() =>
    if array.size(histStart) > 0
        f_hist_kill_at(0)
        array.shift(histStart)
        array.shift(histEnd)

        array.shift(h_q1o),  array.shift(h_q1oTs)
        array.shift(h_q2o),  array.shift(h_q2oTs)
        array.shift(h_q3o),  array.shift(h_q3oTs)
        array.shift(h_q4o),  array.shift(h_q4oTs)

        array.shift(l_q1o)
        array.shift(l_q2o)
        array.shift(l_q3o)
        array.shift(l_q4o)
    0

f_hist_trim_cutoff(int cutoffTs) =>
    while array.size(histStart) > 0 and array.get(histStart, 0) < cutoffTs
        f_hist_shift_front()
    0

f_hist_ensure_current() =>
    if n.inWindow and not na(n.q1Ts)
        int key = n.q1Ts
        int idx = f_find_int(histStart, key)
        if idx == -1
            array.push(histStart, key)
            array.push(histEnd, n.endTs)

            array.push(h_q1o, na), array.push(h_q1oTs, na)
            array.push(h_q2o, na), array.push(h_q2oTs, na)
            array.push(h_q3o, na), array.push(h_q3oTs, na)
            array.push(h_q4o, na), array.push(h_q4oTs, na)

            line naL = na
            array.push(l_q1o, naL)
            array.push(l_q2o, naL)
            array.push(l_q3o, naL)
            array.push(l_q4o, naL)
            idx := array.size(histStart) - 1

        // Update current cycle snapshot from QTCore values
        // IMPORTANT: For sub-TF-aligned opens (e.g., Nano forced to 5S), always anchor open-lines to q?.oTs.
        // Do NOT fall back to boundaryTs (q?Ts), or the line will be shifted on higher chart TFs.
        array.set(histEnd, idx, n.endTs)

        float q1o = n.q1.o
        int   q1t = n.q1.oTs
        if not na(q1o) and not na(q1t)
            array.set(h_q1o, idx, q1o)
            array.set(h_q1oTs, idx, q1t)

        float q2o = n.q2.o
        int   q2t = n.q2.oTs
        if not na(q2o) and not na(q2t)
            array.set(h_q2o, idx, q2o)
            array.set(h_q2oTs, idx, q2t)

        float q3o = n.q3.o
        int   q3t = n.q3.oTs
        if not na(q3o) and not na(q3t)
            array.set(h_q3o, idx, q3o)
            array.set(h_q3oTs, idx, q3t)

        float q4o = n.q4.o
        int   q4t = n.q4.oTs
        if not na(q4o) and not na(q4t)
            array.set(h_q4o, idx, q4o)
            array.set(h_q4oTs, idx, q4t)

        // Hard cap history storage (delete oldest if exceeded)
        while array.size(histStart) > STORE_MAX
            f_hist_shift_front()
    0

// -----------------------------------------------------------------------------
// Main draw logic
// -----------------------------------------------------------------------------
int enabledCycles = (showDailyTf ? 1 : 0) + (show90mTf ? 1 : 0) + (showMicroTf ? 1 : 0) + (showNanoTf ? 1 : 0)
if enabledCycles < 1
    enabledCycles := 1
int perCycle = showOpens ? 9 : 5
int maxC = int(math.floor((MAX_LINES - 10) / (perCycle * (enabledCycles * 1.0))))
maxC := f_clamp_int(maxC, 1, 200)
int keepEff = f_clamp_int(keepCycles, 1, maxC)

if not showDailyTf
    vset_clear(dailyV)
    dailyProjQ2  := f_kill(dailyProjQ2)
    dailyProjQ3  := f_kill(dailyProjQ3)
    dailyProjQ4  := f_kill(dailyProjQ4)
    dailyProjEnd := f_kill(dailyProjEnd)

    int di = array.size(dailyHistStart) - 1
    while di >= 0
        f_dhist_kill_at(di)
        di -= 1
    array.clear(dailyHistStart), array.clear(dailyHistEnd)
    array.clear(daily_h_q1o), array.clear(daily_h_q1oTs)
    array.clear(daily_h_q2o), array.clear(daily_h_q2oTs)
    array.clear(daily_h_q3o), array.clear(daily_h_q3oTs)
    array.clear(daily_h_q4o), array.clear(daily_h_q4oTs)
    array.clear(daily_l_q1o), array.clear(daily_l_q2o), array.clear(daily_l_q3o), array.clear(daily_l_q4o)
    array.clear(dailyStarts)
else
    if not na(d.q2Ts)
        dailyProjQ2 := tc > d.q2Ts ? f_kill(dailyProjQ2) : f_set_or_make_vline(dailyProjQ2, d.q2Ts, COL_Q2)
    if not na(d.q3Ts)
        dailyProjQ3 := tc > d.q3Ts ? f_kill(dailyProjQ3) : f_set_or_make_vline(dailyProjQ3, d.q3Ts, COL_Q3)
    if not na(d.q4Ts)
        dailyProjQ4 := tc > d.q4Ts ? f_kill(dailyProjQ4) : f_set_or_make_vline(dailyProjQ4, d.q4Ts, COL_Q4)

    if not na(d.endTs)
        dailyProjEnd := f_set_or_make_vline(dailyProjEnd, d.endTs, COL_Q1)

    if d.inWindow and not na(d.q1Ts)
        f_push_unique_int(dailyStarts, d.q1Ts, STORE_MAX)

    int dCutoff = na(d.q1Ts) ? 0 : d.q1Ts
    int dAvail = array.size(dailyStarts)
    int dUse   = math.min(keepEff, dAvail)
    int dFirst = dAvail - dUse
    if dUse > 0
        dCutoff := array.get(dailyStarts, dFirst)

    vset_trim_since(dailyV, dCutoff)

    f_dhist_ensure_current()
    f_dhist_trim_cutoff(dCutoff)

    if d.inWindow
        if not na(d.q1Ts) and tc > d.q1Ts
            vset_add(dailyV, d.q1Ts, COL_Q1)
        if not na(d.q2Ts) and tc > d.q2Ts
            vset_add(dailyV, d.q2Ts, COL_Q2)
        if not na(d.q3Ts) and tc > d.q3Ts
            vset_add(dailyV, d.q3Ts, COL_Q3)
        if not na(d.q4Ts) and tc > d.q4Ts
            vset_add(dailyV, d.q4Ts, COL_Q4)
        if not na(d.endTs) and tc > d.endTs
            vset_add(dailyV, d.endTs, COL_Q1)

    if not showOpens
        int dj = array.size(dailyHistStart) - 1
        while dj >= 0
            f_dhist_kill_at(dj)
            dj -= 1
    else
        int dsz = array.size(dailyHistStart)
        int dk = 0
        while dk < dsz
            int dEndTs = array.get(dailyHistEnd, dk)

            float dy1 = array.get(daily_h_q1o, dk)
            int   dx1 = array.get(daily_h_q1oTs, dk)
            line  dl1 = array.get(daily_l_q1o, dk)
            if not na(dy1) and not na(dx1) and not na(dEndTs)
                dl1 := f_set_or_make_hline(dl1, dx1, dEndTs, dy1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                dl1 := f_kill(dl1)
            array.set(daily_l_q1o, dk, dl1)

            float dy2 = array.get(daily_h_q2o, dk)
            int   dx2 = array.get(daily_h_q2oTs, dk)
            line  dl2 = array.get(daily_l_q2o, dk)
            if not na(dy2) and not na(dx2) and not na(dEndTs)
                dl2 := f_set_or_make_hline(dl2, dx2, dEndTs, dy2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                dl2 := f_kill(dl2)
            array.set(daily_l_q2o, dk, dl2)

            float dy3 = array.get(daily_h_q3o, dk)
            int   dx3 = array.get(daily_h_q3oTs, dk)
            line  dl3 = array.get(daily_l_q3o, dk)
            if not na(dy3) and not na(dx3) and not na(dEndTs)
                dl3 := f_set_or_make_hline(dl3, dx3, dEndTs, dy3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                dl3 := f_kill(dl3)
            array.set(daily_l_q3o, dk, dl3)

            float dy4 = array.get(daily_h_q4o, dk)
            int   dx4 = array.get(daily_h_q4oTs, dk)
            line  dl4 = array.get(daily_l_q4o, dk)
            if not na(dy4) and not na(dx4) and not na(dEndTs)
                dl4 := f_set_or_make_hline(dl4, dx4, dEndTs, dy4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                dl4 := f_kill(dl4)
            array.set(daily_l_q4o, dk, dl4)

            dk += 1

if not showMicroTf
    vset_clear(microV)
    microProjQ2  := f_kill(microProjQ2)
    microProjQ3  := f_kill(microProjQ3)
    microProjQ4  := f_kill(microProjQ4)
    microProjEnd := f_kill(microProjEnd)

    int mi = array.size(microHistStart) - 1
    while mi >= 0
        f_mhist_kill_at(mi)
        mi -= 1
    array.clear(microHistStart), array.clear(microHistEnd)
    array.clear(micro_h_q1o), array.clear(micro_h_q1oTs)
    array.clear(micro_h_q2o), array.clear(micro_h_q2oTs)
    array.clear(micro_h_q3o), array.clear(micro_h_q3oTs)
    array.clear(micro_h_q4o), array.clear(micro_h_q4oTs)
    array.clear(micro_l_q1o), array.clear(micro_l_q2o), array.clear(micro_l_q3o), array.clear(micro_l_q4o)
    array.clear(microStarts)
else
    if not na(m.q2Ts)
        microProjQ2 := tc > m.q2Ts ? f_kill(microProjQ2) : f_set_or_make_vline(microProjQ2, m.q2Ts, COL_Q2)
    if not na(m.q3Ts)
        microProjQ3 := tc > m.q3Ts ? f_kill(microProjQ3) : f_set_or_make_vline(microProjQ3, m.q3Ts, COL_Q3)
    if not na(m.q4Ts)
        microProjQ4 := tc > m.q4Ts ? f_kill(microProjQ4) : f_set_or_make_vline(microProjQ4, m.q4Ts, COL_Q4)

    if not na(m.endTs)
        microProjEnd := f_set_or_make_vline(microProjEnd, m.endTs, COL_Q1)

    if m.inWindow and not na(m.q1Ts)
        f_push_unique_int(microStarts, m.q1Ts, STORE_MAX)

    int mCutoff = na(m.q1Ts) ? 0 : m.q1Ts
    int mAvail = array.size(microStarts)
    int mUse   = math.min(keepEff, mAvail)
    int mFirst = mAvail - mUse
    if mUse > 0
        mCutoff := array.get(microStarts, mFirst)

    vset_trim_since(microV, mCutoff)

    f_mhist_ensure_current()
    f_mhist_trim_cutoff(mCutoff)

    if m.inWindow
        if not na(m.q1Ts) and tc > m.q1Ts
            vset_add(microV, m.q1Ts, COL_Q1)
        if not na(m.q2Ts) and tc > m.q2Ts
            vset_add(microV, m.q2Ts, COL_Q2)
        if not na(m.q3Ts) and tc > m.q3Ts
            vset_add(microV, m.q3Ts, COL_Q3)
        if not na(m.q4Ts) and tc > m.q4Ts
            vset_add(microV, m.q4Ts, COL_Q4)
        if not na(m.endTs) and tc > m.endTs
            vset_add(microV, m.endTs, COL_Q1)

    if not showOpens
        int mj = array.size(microHistStart) - 1
        while mj >= 0
            f_mhist_kill_at(mj)
            mj -= 1
    else
        int msz = array.size(microHistStart)
        int mk = 0
        while mk < msz
            int mEndTs = array.get(microHistEnd, mk)

            float my1 = array.get(micro_h_q1o, mk)
            int   mx1 = array.get(micro_h_q1oTs, mk)
            line  ml1 = array.get(micro_l_q1o, mk)
            if not na(my1) and not na(mx1) and not na(mEndTs)
                ml1 := f_set_or_make_hline(ml1, mx1, mEndTs, my1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                ml1 := f_kill(ml1)
            array.set(micro_l_q1o, mk, ml1)

            float my2 = array.get(micro_h_q2o, mk)
            int   mx2 = array.get(micro_h_q2oTs, mk)
            line  ml2 = array.get(micro_l_q2o, mk)
            if not na(my2) and not na(mx2) and not na(mEndTs)
                ml2 := f_set_or_make_hline(ml2, mx2, mEndTs, my2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                ml2 := f_kill(ml2)
            array.set(micro_l_q2o, mk, ml2)

            float my3 = array.get(micro_h_q3o, mk)
            int   mx3 = array.get(micro_h_q3oTs, mk)
            line  ml3 = array.get(micro_l_q3o, mk)
            if not na(my3) and not na(mx3) and not na(mEndTs)
                ml3 := f_set_or_make_hline(ml3, mx3, mEndTs, my3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                ml3 := f_kill(ml3)
            array.set(micro_l_q3o, mk, ml3)

            float my4 = array.get(micro_h_q4o, mk)
            int   mx4 = array.get(micro_h_q4oTs, mk)
            line  ml4 = array.get(micro_l_q4o, mk)
            if not na(my4) and not na(mx4) and not na(mEndTs)
                ml4 := f_set_or_make_hline(ml4, mx4, mEndTs, my4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                ml4 := f_kill(ml4)
            array.set(micro_l_q4o, mk, ml4)

            mk += 1

if not show90mTf
    vset_clear(m90V)
    m90ProjQ2  := f_kill(m90ProjQ2)
    m90ProjQ3  := f_kill(m90ProjQ3)
    m90ProjQ4  := f_kill(m90ProjQ4)
    m90ProjEnd := f_kill(m90ProjEnd)

    int m90i = array.size(m90HistStart) - 1
    while m90i >= 0
        f_m90hist_kill_at(m90i)
        m90i -= 1
    array.clear(m90HistStart), array.clear(m90HistEnd)
    array.clear(m90_h_q1o), array.clear(m90_h_q1oTs)
    array.clear(m90_h_q2o), array.clear(m90_h_q2oTs)
    array.clear(m90_h_q3o), array.clear(m90_h_q3oTs)
    array.clear(m90_h_q4o), array.clear(m90_h_q4oTs)
    array.clear(m90_l_q1o), array.clear(m90_l_q2o), array.clear(m90_l_q3o), array.clear(m90_l_q4o)
    array.clear(m90Starts)
else
    if not na(m90.q2Ts)
        m90ProjQ2 := tc > m90.q2Ts ? f_kill(m90ProjQ2) : f_set_or_make_vline(m90ProjQ2, m90.q2Ts, COL_Q2)
    if not na(m90.q3Ts)
        m90ProjQ3 := tc > m90.q3Ts ? f_kill(m90ProjQ3) : f_set_or_make_vline(m90ProjQ3, m90.q3Ts, COL_Q3)
    if not na(m90.q4Ts)
        m90ProjQ4 := tc > m90.q4Ts ? f_kill(m90ProjQ4) : f_set_or_make_vline(m90ProjQ4, m90.q4Ts, COL_Q4)

    if not na(m90.endTs)
        m90ProjEnd := f_set_or_make_vline(m90ProjEnd, m90.endTs, COL_Q1)

    if m90.inWindow and not na(m90.q1Ts)
        f_push_unique_int(m90Starts, m90.q1Ts, STORE_MAX)

    int m90Cutoff = na(m90.q1Ts) ? 0 : m90.q1Ts
    int m90Avail = array.size(m90Starts)
    int m90Use   = math.min(keepEff, m90Avail)
    int m90First = m90Avail - m90Use
    if m90Use > 0
        m90Cutoff := array.get(m90Starts, m90First)

    vset_trim_since(m90V, m90Cutoff)

    f_m90hist_ensure_current()
    f_m90hist_trim_cutoff(m90Cutoff)

    if m90.inWindow
        if not na(m90.q1Ts) and tc > m90.q1Ts
            vset_add(m90V, m90.q1Ts, COL_Q1)
        if not na(m90.q2Ts) and tc > m90.q2Ts
            vset_add(m90V, m90.q2Ts, COL_Q2)
        if not na(m90.q3Ts) and tc > m90.q3Ts
            vset_add(m90V, m90.q3Ts, COL_Q3)
        if not na(m90.q4Ts) and tc > m90.q4Ts
            vset_add(m90V, m90.q4Ts, COL_Q4)
        if not na(m90.endTs) and tc > m90.endTs
            vset_add(m90V, m90.endTs, COL_Q1)

    if not showOpens
        int m90j = array.size(m90HistStart) - 1
        while m90j >= 0
            f_m90hist_kill_at(m90j)
            m90j -= 1
    else
        int m90sz = array.size(m90HistStart)
        int m90k = 0
        while m90k < m90sz
            int m90EndTs = array.get(m90HistEnd, m90k)

            float m90y1 = array.get(m90_h_q1o, m90k)
            int   m90x1 = array.get(m90_h_q1oTs, m90k)
            line  m90l1 = array.get(m90_l_q1o, m90k)
            if not na(m90y1) and not na(m90x1) and not na(m90EndTs)
                m90l1 := f_set_or_make_hline(m90l1, m90x1, m90EndTs, m90y1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                m90l1 := f_kill(m90l1)
            array.set(m90_l_q1o, m90k, m90l1)

            float m90y2 = array.get(m90_h_q2o, m90k)
            int   m90x2 = array.get(m90_h_q2oTs, m90k)
            line  m90l2 = array.get(m90_l_q2o, m90k)
            if not na(m90y2) and not na(m90x2) and not na(m90EndTs)
                m90l2 := f_set_or_make_hline(m90l2, m90x2, m90EndTs, m90y2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                m90l2 := f_kill(m90l2)
            array.set(m90_l_q2o, m90k, m90l2)

            float m90y3 = array.get(m90_h_q3o, m90k)
            int   m90x3 = array.get(m90_h_q3oTs, m90k)
            line  m90l3 = array.get(m90_l_q3o, m90k)
            if not na(m90y3) and not na(m90x3) and not na(m90EndTs)
                m90l3 := f_set_or_make_hline(m90l3, m90x3, m90EndTs, m90y3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                m90l3 := f_kill(m90l3)
            array.set(m90_l_q3o, m90k, m90l3)

            float m90y4 = array.get(m90_h_q4o, m90k)
            int   m90x4 = array.get(m90_h_q4oTs, m90k)
            line  m90l4 = array.get(m90_l_q4o, m90k)
            if not na(m90y4) and not na(m90x4) and not na(m90EndTs)
                m90l4 := f_set_or_make_hline(m90l4, m90x4, m90EndTs, m90y4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                m90l4 := f_kill(m90l4)
            array.set(m90_l_q4o, m90k, m90l4)

            m90k += 1

if not showNanoTf
    // Clear everything
    vset_clear(nanoV)
    projQ2  := f_kill(projQ2)
    projQ3  := f_kill(projQ3)
    projQ4  := f_kill(projQ4)
    projEnd := f_kill(projEnd)

    // Kill open lines + clear history arrays
    int i = array.size(histStart) - 1
    while i >= 0
        f_hist_kill_at(i)
        i -= 1
    array.clear(histStart), array.clear(histEnd)
    array.clear(h_q1o), array.clear(h_q1oTs)
    array.clear(h_q2o), array.clear(h_q2oTs)
    array.clear(h_q3o), array.clear(h_q3oTs)
    array.clear(h_q4o), array.clear(h_q4oTs)
    array.clear(l_q1o), array.clear(l_q2o), array.clear(l_q3o), array.clear(l_q4o)

    array.clear(nanoStarts)
else
    // Projections (future boundaries only; killed once passed)
    if not na(n.q2Ts)
        projQ2 := tc > n.q2Ts ? f_kill(projQ2) : f_set_or_make_vline(projQ2, n.q2Ts, COL_Q2)
    if not na(n.q3Ts)
        projQ3 := tc > n.q3Ts ? f_kill(projQ3) : f_set_or_make_vline(projQ3, n.q3Ts, COL_Q3)
    if not na(n.q4Ts)
        projQ4 := tc > n.q4Ts ? f_kill(projQ4) : f_set_or_make_vline(projQ4, n.q4Ts, COL_Q4)

    // End projection always visible for the active cycle
    if not na(n.endTs)
        projEnd := f_set_or_make_vline(projEnd, n.endTs, COL_Q1)

    // Track printed cycle starts
    if n.inWindow and not na(n.q1Ts)
        f_push_unique_int(nanoStarts, n.q1Ts, STORE_MAX)

    int cutoff = na(n.q1Ts) ? 0 : n.q1Ts
    int nAvail = array.size(nanoStarts)
    int nUse   = math.min(keepEff, nAvail)
    int first  = nAvail - nUse
    if nUse > 0
        cutoff := array.get(nanoStarts, first)

    // Trim realized divider set to cutoff window
    vset_trim_since(nanoV, cutoff)

    // Update current-cycle snapshot (from QTCore) into open history
    f_hist_ensure_current()

    // Trim open history to cutoff
    f_hist_trim_cutoff(cutoff)

    // Realized dividers (persist via vset; windowed by keepCycles)
    if n.inWindow
        if not na(n.q1Ts) and tc > n.q1Ts
            vset_add(nanoV, n.q1Ts, COL_Q1)
        if not na(n.q2Ts) and tc > n.q2Ts
            vset_add(nanoV, n.q2Ts, COL_Q2)
        if not na(n.q3Ts) and tc > n.q3Ts
            vset_add(nanoV, n.q3Ts, COL_Q3)
        if not na(n.q4Ts) and tc > n.q4Ts
            vset_add(nanoV, n.q4Ts, COL_Q4)

        // Only persist cycle-end once it’s actually passed
        if not na(n.endTs) and tc > n.endTs
            vset_add(nanoV, n.endTs, COL_Q1)

    // Draw/update open lines for every retained cycle
    if not showOpens
        int j = array.size(histStart) - 1
        while j >= 0
            f_hist_kill_at(j)
            j -= 1
    else
        int sz = array.size(histStart)
        int k = 0
        while k < sz
            int endTs = array.get(histEnd, k)

            // Q1 open line
            float y1 = array.get(h_q1o, k)
            int   x1 = array.get(h_q1oTs, k)
            line  l1 = array.get(l_q1o, k)
            if not na(y1) and not na(x1) and not na(endTs)
                l1 := f_set_or_make_hline(l1, x1, endTs, y1, q1OpenCol, lineStyleFrom(q1OpenStyleStr))
            else
                l1 := f_kill(l1)
            array.set(l_q1o, k, l1)

            // Q2 open / true open line
            float y2 = array.get(h_q2o, k)
            int   x2 = array.get(h_q2oTs, k)
            line  l2 = array.get(l_q2o, k)
            if not na(y2) and not na(x2) and not na(endTs)
                l2 := f_set_or_make_hline(l2, x2, endTs, y2, q2OpenCol, lineStyleFrom(q2OpenStyleStr))
            else
                l2 := f_kill(l2)
            array.set(l_q2o, k, l2)

            // Q3 open line
            float y3 = array.get(h_q3o, k)
            int   x3 = array.get(h_q3oTs, k)
            line  l3 = array.get(l_q3o, k)
            if not na(y3) and not na(x3) and not na(endTs)
                l3 := f_set_or_make_hline(l3, x3, endTs, y3, q3OpenCol, lineStyleFrom(q3OpenStyleStr))
            else
                l3 := f_kill(l3)
            array.set(l_q3o, k, l3)

            // Q4 open line
            float y4 = array.get(h_q4o, k)
            int   x4 = array.get(h_q4oTs, k)
            line  l4 = array.get(l_q4o, k)
            if not na(y4) and not na(x4) and not na(endTs)
                l4 := f_set_or_make_hline(l4, x4, endTs, y4, q4OpenCol, lineStyleFrom(q4OpenStyleStr))
            else
                l4 := f_kill(l4)
            array.set(l_q4o, k, l4)

            k += 1
