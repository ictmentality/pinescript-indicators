//@version=6
library("QTEngine", overlay=false)

// ============================================================================
// QT CORE (SKELETON) — Fixed cycles only (Daily / m90 / Micro / Nano)
// - Data-first: timestamps + OHLC + state flags
// - No drawings, no styling opinions
// - Timestamp anchoring only (bar_time), never bar_index
// - State-trigger correctness everywhere: realized = (time_close > ts)
// - Non-repaint: any request.security(..., lookahead_off) only (future step)
// - Step 2 (implemented): quarter OHLC aggregated on chart TF into QuarterRecords
// - Weekly cycle intentionally excluded for now
//
// NOTE: Step 2 aggregates quarter OHLC on chart TF. A later step will add aligned-TF OHLC
//       aggregation + printed-cycle backfill behaviors.
// ============================================================================

// ============================================================================
// CONSTANTS
// ============================================================================
const int MS_SEC  = 1000
const int MS_MIN  = 60 * MS_SEC
const int LEN_24H = 24 * 60 * MS_MIN
const int LEN_6H  = 6  * 60 * MS_MIN
const int LEN_90M = 90 * MS_MIN
const int LEN_22M30S = 22 * MS_MIN + 30 * MS_SEC  // 22.5 minutes

const string NANO_OPEN_TF = "5S"
// Nano open capture uses fixed config to satisfy library request.* constraints.
const string NANO_TZ = "America/New_York"
const int NANO_DAY_START_HOUR = 18
const int NANO_DAY_START_MIN = 0
// ============================================================================
// USER-DEFINED TYPES (UDTs)
// ============================================================================

export type QTConfig
    string tz
    int    dayStartHour
    int    dayStartMin
    int    keepCycles

    // Aligned TFs per QT cycle (canonical)
    string tfDaily      // "15"
    string tfM90        // "5"
    string tfMicro      // "30S"
    string tfNano       // "5S"

export type QuarterRecord
    int   boundaryTs
    float o
    float h
    float l
    float c
    int   oTs
    int   hTs
    int   lTs
    int   cTs
    bool  has
    bool  isEmpty
    bool  isFinal
    bool  evtStart
    bool  evtFinalize

export type CycleResult
    // Cycle window
    int  startTs
    int  endTs
    bool startRealized
    bool endRealized

    // Quarter boundaries (Q1 is the cycle start)
    int  q1Ts
    int  q2Ts
    int  q3Ts
    int  q4Ts

    // State-trigger realization (early mode)
    bool q2Realized
    bool q3Realized
    bool q4Realized

    // Where we are right now
    int  curQuarterIndex   // 1..4
    bool inWindow

    // Quarter records (OHLC + timestamps + flags; populated on chart TF)
    QuarterRecord q1
    QuarterRecord q2
    QuarterRecord q3
    QuarterRecord q4

export type FixedCycleState
    // Printed-cycle retention (cycle starts)
    int[] starts
    int   lastStartTs

    // Last realized quarter boundary (start ts of the current quarter)
    int   lastBoundaryTs

    // Current-cycle quarter records (running OHLC on chart TF)
    QuarterRecord q1
    QuarterRecord q2
    QuarterRecord q3
    QuarterRecord q4

    // Small history buffer of finalized quarters (most recent first)
    QuarterRecord prev1
    QuarterRecord prev2

    // Nano-only: pending true-open capture (applied when quarter becomes active)
    int   pendingBoundaryTs
    float pendingOpen
    int   pendingOpenTs
    bool  pendingHas

export type CycleState
    FixedCycleState daily
    FixedCycleState m90
    FixedCycleState micro
    FixedCycleState nano

// ============================================================================
// CONSTRUCTORS
// ============================================================================

export qt_config_default() =>
    QTConfig cfg = QTConfig.new(
        "America/New_York",
        18, 0,
        32,
        "15",
        "5",
        "30S",
        "5S"
    )
    cfg


export qt_state_new() =>
    QuarterRecord nilQ = QuarterRecord.new(
        int(na),
        float(na),
        float(na),
        float(na),
        float(na),
        int(na),
        int(na),
        int(na),
        int(na),
        false,
        true,
        false,
        false,
        false
    )

    FixedCycleState d = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false)
    FixedCycleState m = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false)
    FixedCycleState u = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false)
    FixedCycleState n = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false)
    CycleState st = CycleState.new(d, m, u, n)
    st


// ============================================================================
// HELPERS (timestamp math only)
// ============================================================================

f_qt_day_start_raw(int t, string tz, int dayStartHour, int dayStartMin) =>
    int y  = year(t, tz)
    int mo = month(t, tz)
    int da = dayofmonth(t, tz)
    int h  = hour(t, tz)
    int mi = minute(t, tz)
    int base = timestamp(tz, y, mo, da, dayStartHour, dayStartMin)
    int out  = (h > dayStartHour or (h == dayStartHour and mi >= dayStartMin)) ? base : base - LEN_24H
    out

f_qt_day_start(int t, QTConfig cfg) =>
    f_qt_day_start_raw(t, cfg.tz, cfg.dayStartHour, cfg.dayStartMin)

f_next_ds_after(int t, QTConfig cfg) =>
    int ds0 = f_qt_day_start(t, cfg)
    ds0 <= t ? ds0 + LEN_24H : ds0

f_cycle_start(int t, int baseTs, int lenMs) =>
    // Computes start = baseTs + floor((t - baseTs)/lenMs) * lenMs
    // Assumes baseTs is the correct anchor for t (e.g., DS for the day containing t)
    int k = int(math.floor((t - baseTs) / lenMs))
    baseTs + k * lenMs

f_quarter_index(int t, int cycleStart, int lenMs) =>
    int qLen = int(lenMs / 4)
    int qi0  = int(math.floor((t - cycleStart) / qLen))  // 0..3
    int qi1  = qi0 < 0 ? 0 : (qi0 > 3 ? 3 : qi0)
    qi1 + 1

f_make_empty_q(int qStart) =>
    QuarterRecord.new(
        qStart,
        na, na, na, na,
        int(na), int(na), int(na), int(na),
        false, true, false,
        false, false
    )

// ============================================================================
// NANO OPEN SOURCE (FORCED 5S) — First printed 5s bar on/after boundary
// - This is a "first-on/after" policy (gap-safe) for Nano opens only.
// - H/L/C are still chart-TF aggregated (Step 2 scope stays intact).
// ============================================================================

f_ceil_to_5s(int ts) =>
    int step = 5 * MS_SEC
    int rem  = ts % step
    rem == 0 ? ts : ts + (step - rem)

f_nano_open_5s_expr() =>
    // Use bar start time to align "first printed bar on/after boundary".
    int tRef = time
    int ds = f_qt_day_start_raw(tRef, NANO_TZ, NANO_DAY_START_HOUR, NANO_DAY_START_MIN)

    int cStart = f_cycle_start(tRef, ds, LEN_22M30S)
    int qLen   = int(LEN_22M30S / 4)

    int q1Ts = cStart
    int q2Ts = cStart + 1 * qLen
    int q3Ts = cStart + 2 * qLen
    int q4Ts = cStart + 3 * qLen

    int qi = f_quarter_index(tRef, cStart, LEN_22M30S)

    int qCurTs = q1Ts
    if qi == 2
        qCurTs := q2Ts
    else if qi == 3
        qCurTs := q3Ts
    else if qi == 4
        qCurTs := q4Ts

    // Target = first 5s bar time on/after the (possibly half-second) boundary.
    int targetTs = f_ceil_to_5s(qCurTs)

    var int   lastTarget = int(na)
    var float oOut  = float(na)
    var int   tsOut = int(na)

    if na(lastTarget) or targetTs != lastTarget
        lastTarget := targetTs
        oOut  := float(na)
        tsOut := int(na)

    bool hit = (time >= targetTs) and (na(time[1]) or time[1] < targetTs)
    if hit and na(oOut)
        oOut  := open
        tsOut := time

    [oOut, tsOut, qi, qCurTs]

f_nano_open_current_5s() =>
    request.security(
        syminfo.tickerid,
        NANO_OPEN_TF,
        f_nano_open_5s_expr(),
        lookahead=barmerge.lookahead_off
    )

// Debug helper (read-only): expose Nano 5S open capture tuple for tests.
export qt_nano_open_debug() =>
    f_nano_open_current_5s()

// ============================================================================
// STEP 2 HELPERS — Chart-TF quarter OHLC aggregation (minimal, gap-safe)
// ============================================================================

f_q_clear_evts(QuarterRecord qIn) =>
    QuarterRecord q = qIn
    q.evtStart := false
    q.evtFinalize := false
    q

f_q_finalize(QuarterRecord qIn) =>
    QuarterRecord q = qIn
    q.isFinal := true
    q.evtFinalize := true
    if not q.has
        q.isEmpty := true
    q

f_finalize_and_roll(QuarterRecord qIn, QuarterRecord prev1In, QuarterRecord prev2In) =>
    QuarterRecord q = qIn
    QuarterRecord p1 = prev1In
    QuarterRecord p2 = prev2In
    if not q.isFinal and not na(q.boundaryTs)
        q := f_q_finalize(q)
        p2 := p1
        p1 := q
    [q, p1, p2]

f_q_apply_bar(QuarterRecord qIn, int t, float o, float h, float l, float c, bool isStartBar) =>
    QuarterRecord q = qIn

    if not q.has
        q.o := o
        q.oTs := t
        q.h := h
        q.hTs := t
        q.l := l
        q.lTs := t
        q.c := c
        q.cTs := t
        q.has := true
        q.isEmpty := false
        q.isFinal := false
        q.evtStart := isStartBar
    else
        bool newHigh = na(q.h) or h > q.h
        bool newLow  = na(q.l) or l < q.l
        if newHigh
            q.h := h
            q.hTs := t
        if newLow
            q.l := l
            q.lTs := t
        q.c := c
        q.cTs := t
        if isStartBar
            q.evtStart := true

    q

f_q_idx_from_boundary(int boundaryTs, int q1Ts, int q2Ts, int q3Ts, int q4Ts) =>
    int idx = 0
    if not na(boundaryTs)
        if boundaryTs == q1Ts
            idx := 1
        else if boundaryTs == q2Ts
            idx := 2
        else if boundaryTs == q3Ts
            idx := 3
        else if boundaryTs == q4Ts
            idx := 4
    idx


f_push_printed_start(int[] startsIn, int startTs, int keepCycles) =>
    // No mutation of input param: copy first, return the new array.
    int[] out = array.copy(startsIn)
    int sz = array.size(out)
    int last = sz > 0 ? array.get(out, sz - 1) : int(na)
    if na(last) or startTs > last
        array.push(out, startTs)

    // Cap to keepCycles (drop oldest)
    while array.size(out) > keepCycles
        array.shift(out)

    out

// ============================================================================

// CORE FIXED-CYCLE UPDATE (STEP 1: TIMESTAMPS ONLY)
// - Kept as a fallback (timestamps-only). All fixed cycles currently use Step 2.
// - Produces boundaryTs + realized flags; QuarterRecord OHLC fields remain `na`.
f_fixed_cycle_update_step1(FixedCycleState stIn, QTConfig cfg, int t, int tClose, int lenMs) =>
    // Anchor: use the session-day start (18:00 NY) as the base for all fixed cycles.
    int ds = f_qt_day_start(t, cfg)
    int cStart = f_cycle_start(t, ds, lenMs)
    int cEnd = cStart + lenMs

    int qLen = int(lenMs / 4)
    int q1Ts = cStart
    int q2Ts = cStart + (1 * qLen)
    int q3Ts = cStart + (2 * qLen)
    int q4Ts = cStart + (3 * qLen)

    bool q2Realized = tClose > q2Ts
    bool q3Realized = tClose > q3Ts
    bool q4Realized = tClose > q4Ts
    bool startRealized = tClose > cStart
    bool endRealized = tClose > cEnd
    bool inWindow = (t >= cStart) and (t < cEnd)
    int qIdx = f_quarter_index(t, cStart, lenMs)

    // Cycle-change detection + printed-cycle retention.
    int[] starts2 = stIn.starts
    int lastStart2 = stIn.lastStartTs
    bool cycleChanged = na(lastStart2) or cStart != lastStart2
    if cycleChanged
        starts2 := f_push_printed_start(stIn.starts, cStart, cfg.keepCycles)
        lastStart2 := cStart

    // Local working copies (clear one-bar event pulses).
    QuarterRecord q1 = f_q_clear_evts(stIn.q1)
    QuarterRecord q2 = f_q_clear_evts(stIn.q2)
    QuarterRecord q3 = f_q_clear_evts(stIn.q3)
    QuarterRecord q4 = f_q_clear_evts(stIn.q4)
    QuarterRecord prev1 = f_q_clear_evts(stIn.prev1)
    QuarterRecord prev2 = f_q_clear_evts(stIn.prev2)
    int lastBoundary2 = stIn.lastBoundaryTs
    int pendingBoundary2 = stIn.pendingBoundaryTs
    float pendingOpen2 = stIn.pendingOpen
    int pendingOpenTs2 = stIn.pendingOpenTs
    bool pendingHas2 = stIn.pendingHas

    // On new cycle, reset the quarter records to the new boundaries.
    if cycleChanged
        q1 := f_make_empty_q(q1Ts)
        q2 := f_make_empty_q(q2Ts)
        q3 := f_make_empty_q(q3Ts)
        q4 := f_make_empty_q(q4Ts)
        lastBoundary2 := int(na)
        pendingBoundary2 := int(na)
        pendingOpen2 := float(na)
        pendingOpenTs2 := int(na)
        pendingHas2 := false

    // Ensure boundaryTs always matches the computed timestamps (gap/holiday safe).
    if na(q1.boundaryTs) or q1.boundaryTs != q1Ts
        q1 := f_make_empty_q(q1Ts)
    if na(q2.boundaryTs) or q2.boundaryTs != q2Ts
        q2 := f_make_empty_q(q2Ts)
    if na(q3.boundaryTs) or q3.boundaryTs != q3Ts
        q3 := f_make_empty_q(q3Ts)
    if na(q4.boundaryTs) or q4.boundaryTs != q4Ts
        q4 := f_make_empty_q(q4Ts)
    if pendingHas2 and pendingBoundary2 != q1Ts and pendingBoundary2 != q2Ts and pendingBoundary2 != q3Ts and pendingBoundary2 != q4Ts
        pendingBoundary2 := int(na)
        pendingOpen2 := float(na)
        pendingOpenTs2 := int(na)
        pendingHas2 := false

    // State-trigger: realize the current quarter boundary (early mode) to prevent missing gaps.
    int qCurTs = q1Ts
    if qIdx == 2
        qCurTs := q2Ts
    else if qIdx == 3
        qCurTs := q3Ts
    else if qIdx == 4
        qCurTs := q4Ts

    bool startEdge = inWindow and (tClose > qCurTs) and (na(lastBoundary2) or qCurTs != lastBoundary2)
    if startEdge
        lastBoundary2 := qCurTs

    FixedCycleState stOut = FixedCycleState.new(starts2, lastStart2, lastBoundary2, q1, q2, q3, q4, prev1, prev2, pendingBoundary2, pendingOpen2, pendingOpenTs2, pendingHas2)

    CycleResult res = CycleResult.new(cStart, cEnd, startRealized, endRealized, q1Ts, q2Ts, q3Ts, q4Ts, q2Realized, q3Realized, q4Realized, qIdx, inWindow, q1, q2, q3, q4)
    [stOut, res]

// CORE FIXED-CYCLE UPDATE (STEP 2: CHART-TF OHLC)
// - Enabled now for Daily + m90 + Micro + Nano.
// - This step aggregates quarter OHLC on chart TF into QuarterRecords
// - Gap-safe: skipped quarters finalize as isEmpty/isFinal on the next printed bar
// ============================================================================

f_fixed_cycle_update(
    FixedCycleState stIn,
    QTConfig cfg,
    int t,
    int tClose,
    int lenMs
) =>
    bool isNano = (lenMs == LEN_22M30S)
    int tRef = isNano ? t : (tClose - 1)
    int ds = f_qt_day_start(tRef, cfg)

    int cStart = f_cycle_start(tRef, ds, lenMs)
    int cEnd   = cStart + lenMs
    int qLen   = int(lenMs / 4)

    int q1Ts = cStart
    int q2Ts = cStart + 1 * qLen
    int q3Ts = cStart + 2 * qLen
    int q4Ts = cStart + 3 * qLen

    bool q2R = tClose > q2Ts
    bool q3R = tClose > q3Ts
    bool q4R = tClose > q4Ts

    bool sR  = tClose > cStart
    bool eR  = tClose > cEnd

    bool inW = tRef >= cStart and tRef < cEnd
    int  qi  = f_quarter_index(tRef, cStart, lenMs)

    // Printed start retention + cycle-change detection
    int[] starts2    = stIn.starts
    int  lastStart2  = stIn.lastStartTs
    bool cycleChanged = na(lastStart2) or cStart != lastStart2
    if cycleChanged
        starts2    := f_push_printed_start(stIn.starts, cStart, cfg.keepCycles)
        lastStart2 := cStart

    // Local copies (clear pulse events each bar)
    QuarterRecord q1 = f_q_clear_evts(stIn.q1)
    QuarterRecord q2 = f_q_clear_evts(stIn.q2)
    QuarterRecord q3 = f_q_clear_evts(stIn.q3)
    QuarterRecord q4 = f_q_clear_evts(stIn.q4)

    QuarterRecord prev1 = f_q_clear_evts(stIn.prev1)
    QuarterRecord prev2 = f_q_clear_evts(stIn.prev2)

    int lastBoundary2 = stIn.lastBoundaryTs
    int pendingBoundary2 = stIn.pendingBoundaryTs
    float pendingOpen2 = stIn.pendingOpen
    int pendingOpenTs2 = stIn.pendingOpenTs
    bool pendingHas2 = stIn.pendingHas

    // If cycle rolled, finalize remaining old-cycle quarters (gap-safe), then reset records for the new cycle.
    if cycleChanged
        int lastIdxOld = f_q_idx_from_boundary(lastBoundary2, q1.boundaryTs, q2.boundaryTs, q3.boundaryTs, q4.boundaryTs)

        if lastIdxOld == 0 or lastIdxOld == 1   
            [tmpQ1_1, tmpP1_1, tmpP2_1] = f_finalize_and_roll(q1, prev1, prev2)
            q1 := tmpQ1_1
            prev1 := tmpP1_1
            prev2 := tmpP2_1

            [tmpQ2_2, tmpP1_2, tmpP2_2] = f_finalize_and_roll(q2, prev1, prev2)
            q2 := tmpQ2_2
            prev1 := tmpP1_2
            prev2 := tmpP2_2

            [tmpQ3_3, tmpP1_3, tmpP2_3] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_3
            prev1 := tmpP1_3
            prev2 := tmpP2_3

            [tmpQ4_4, tmpP1_4, tmpP2_4] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_4
            prev1 := tmpP1_4
            prev2 := tmpP2_4

        else if lastIdxOld == 2
            [tmpQ2_5, tmpP1_5, tmpP2_5] = f_finalize_and_roll(q2, prev1, prev2)
            q2 := tmpQ2_5
            prev1 := tmpP1_5
            prev2 := tmpP2_5

            [tmpQ3_6, tmpP1_6, tmpP2_6] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_6
            prev1 := tmpP1_6
            prev2 := tmpP2_6

            [tmpQ4_7, tmpP1_7, tmpP2_7] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_7
            prev1 := tmpP1_7
            prev2 := tmpP2_7

        else if lastIdxOld == 3
            [tmpQ3_8, tmpP1_8, tmpP2_8] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_8
            prev1 := tmpP1_8
            prev2 := tmpP2_8

            [tmpQ4_9, tmpP1_9, tmpP2_9] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_9
            prev1 := tmpP1_9
            prev2 := tmpP2_9

        else if lastIdxOld == 4
            [tmpQ4_10, tmpP1_10, tmpP2_10] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_10
            prev1 := tmpP1_10
            prev2 := tmpP2_10


        q1 := f_make_empty_q(q1Ts)
        q2 := f_make_empty_q(q2Ts)
        q3 := f_make_empty_q(q3Ts)
        q4 := f_make_empty_q(q4Ts)
        lastBoundary2 := int(na)
        pendingBoundary2 := int(na)
        pendingOpen2 := float(na)
        pendingOpenTs2 := int(na)
        pendingHas2 := false

    // Ensure boundaries are correct (first run or mismatch)
    if na(q1.boundaryTs) or q1.boundaryTs != q1Ts
        q1 := f_make_empty_q(q1Ts)
    if na(q2.boundaryTs) or q2.boundaryTs != q2Ts
        q2 := f_make_empty_q(q2Ts)
    if na(q3.boundaryTs) or q3.boundaryTs != q3Ts
        q3 := f_make_empty_q(q3Ts)
    if na(q4.boundaryTs) or q4.boundaryTs != q4Ts
        q4 := f_make_empty_q(q4Ts)
    if pendingHas2 and pendingBoundary2 != q1Ts and pendingBoundary2 != q2Ts and pendingBoundary2 != q3Ts and pendingBoundary2 != q4Ts
        pendingBoundary2 := int(na)
        pendingOpen2 := float(na)
        pendingOpenTs2 := int(na)
        pendingHas2 := false

    // Current quarter boundary for this bar
    int qCurTs = q1Ts
    if qi == 2
        qCurTs := q2Ts
    else if qi == 3
        qCurTs := q3Ts
    else if qi == 4
        qCurTs := q4Ts

    bool startEdge = inW and (tClose > qCurTs) and (na(lastBoundary2) or qCurTs != lastBoundary2)
    float nanoO5 = float(na)
    int   nanoOTs5 = int(na)
    int   nanoQi5 = int(na)
    int   nanoQCurTs5 = int(na)
    if isNano
        [nanoO5, nanoOTs5, nanoQi5, nanoQCurTs5] = f_nano_open_current_5s()
        if not na(nanoO5) and not na(nanoOTs5)
            if nanoQCurTs5 == q1Ts or nanoQCurTs5 == q2Ts or nanoQCurTs5 == q3Ts or nanoQCurTs5 == q4Ts
                pendingBoundary2 := nanoQCurTs5
                pendingOpen2 := nanoO5
                pendingOpenTs2 := nanoOTs5
                pendingHas2 := true


    // Finalize the quarter we were last in (and any skipped quarters) on the first bar of the new quarter.
    if startEdge and not cycleChanged
        int lastIdx = f_q_idx_from_boundary(lastBoundary2, q1Ts, q2Ts, q3Ts, q4Ts)
        int newIdx  = qi

        if lastIdx == 1
            [tmpQ1_A, tmpP1_A, tmpP2_A] = f_finalize_and_roll(q1, prev1, prev2)
            q1 := tmpQ1_A
            prev1 := tmpP1_A
            prev2 := tmpP2_A

            if newIdx >= 3
                [tmpQ2_B, tmpP1_B, tmpP2_B] = f_finalize_and_roll(q2, prev1, prev2)
                q2 := tmpQ2_B
                prev1 := tmpP1_B
                prev2 := tmpP2_B

            if newIdx >= 4
                [tmpQ3_C, tmpP1_C, tmpP2_C] = f_finalize_and_roll(q3, prev1, prev2)
                q3 := tmpQ3_C
                prev1 := tmpP1_C
                prev2 := tmpP2_C

        else if lastIdx == 2
            [tmpQ2_D, tmpP1_D, tmpP2_D] = f_finalize_and_roll(q2, prev1, prev2)
            q2 := tmpQ2_D
            prev1 := tmpP1_D
            prev2 := tmpP2_D

            if newIdx >= 4
                [tmpQ3_E, tmpP1_E, tmpP2_E] = f_finalize_and_roll(q3, prev1, prev2)
                q3 := tmpQ3_E
                prev1 := tmpP1_E
                prev2 := tmpP2_E

        else if lastIdx == 3
            [tmpQ3_F, tmpP1_F, tmpP2_F] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_F
            prev1 := tmpP1_F
            prev2 := tmpP2_F


    if startEdge
        lastBoundary2 := qCurTs

    // Update active quarter OHLC on chart TF
    if qi == 1 and not q1.isFinal
        q1 := f_q_apply_bar(q1, t, open, high, low, close, startEdge)
    else if qi == 2 and not q2.isFinal
        q2 := f_q_apply_bar(q2, t, open, high, low, close, startEdge)
    else if qi == 3 and not q3.isFinal
        q3 := f_q_apply_bar(q3, t, open, high, low, close, startEdge)
    else if qi == 4 and not q4.isFinal
        q4 := f_q_apply_bar(q4, t, open, high, low, close, startEdge)

    // Nano-only: apply pending true-open when its quarter becomes active.
    if isNano and pendingHas2
        if pendingBoundary2 == q1Ts and qi == 1
            q1.o   := pendingOpen2
            q1.oTs := pendingOpenTs2
            pendingHas2 := false
        else if pendingBoundary2 == q2Ts and qi == 2
            q2.o   := pendingOpen2
            q2.oTs := pendingOpenTs2
            pendingHas2 := false
        else if pendingBoundary2 == q3Ts and qi == 3
            q3.o   := pendingOpen2
            q3.oTs := pendingOpenTs2
            pendingHas2 := false
        else if pendingBoundary2 == q4Ts and qi == 4
            q4.o   := pendingOpen2
            q4.oTs := pendingOpenTs2
            pendingHas2 := false
        else if (pendingBoundary2 == q1Ts and qi > 1) or (pendingBoundary2 == q2Ts and qi > 2) or (pendingBoundary2 == q3Ts and qi > 3)
            pendingBoundary2 := int(na)
            pendingOpen2 := float(na)
            pendingOpenTs2 := int(na)
            pendingHas2 := false

    FixedCycleState stOut = FixedCycleState.new(starts2, lastStart2, lastBoundary2, q1, q2, q3, q4, prev1, prev2, pendingBoundary2, pendingOpen2, pendingOpenTs2, pendingHas2)

    CycleResult res = CycleResult.new(
        cStart, cEnd,
        sR, eR,
        q1Ts, q2Ts, q3Ts, q4Ts,
        q2R, q3R, q4R,
        qi, inW,
        q1, q2, q3, q4
    )

    [stOut, res]


// ============================================================================
// EXPORTED API — Fixed cycles only (no Weekly)
// ============================================================================

export qt_daily_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [d2, r] = f_fixed_cycle_update(st.daily, cfg, t, tClose, LEN_24H)
    CycleState out = CycleState.new(d2, st.m90, st.micro, st.nano)
    [out, r]

export qt_m90_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [m2, r] = f_fixed_cycle_update(st.m90, cfg, t, tClose, LEN_6H)
    CycleState out = CycleState.new(st.daily, m2, st.micro, st.nano)
    [out, r]

export qt_micro_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [u2, r] = f_fixed_cycle_update(st.micro, cfg, t, tClose, LEN_90M)
    CycleState out = CycleState.new(st.daily, st.m90, u2, st.nano)
    [out, r]

export qt_nano_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [n2, r] = f_fixed_cycle_update(st.nano, cfg, t, tClose, LEN_22M30S)
    CycleState out = CycleState.new(st.daily, st.m90, st.micro, n2)
    [out, r]


// ============================================================================
// FUTURE STEPS (NOT IMPLEMENTED YET)
// - Tier B aligned-TF OHLC using request.security(..., lookahead_off)
// - Optional lower-tf aggregation for Micro/Nano correctness (heavy; revisit later)
// ============================================================================
