//@version=6
library("QTEngine", overlay=false)

// ============================================================================
// QT CORE (SKELETON) — Fixed cycles only (Daily / m90 / Micro / Nano)
// - Data-first: timestamps + OHLC + state flags
// - No drawings, no styling opinions
// - Timestamp anchoring only (bar_time), never bar_index
// - State-trigger correctness everywhere: realized = (time_close > ts)
// - Non-repaint: any request.security(..., lookahead_off) only
// - Step 2 (implemented): quarter OHLC aggregated on chart TF into QuarterRecords
// - Step 3 (implemented): Micro/Nano H/L/C sourced from aligned TF quarters
// - Step 3b (implemented): 90m O/C sourced from aligned TF quarters
// - Weekly cycle implemented (intent/eff boundaries, Q1–Q5)
//
// NOTE: Chart-TF aggregation still drives Daily. Micro/Nano now use aligned-TF
//       quarters for H/L/C, and 90m uses aligned-TF O/C, while Micro/Nano opens
//       remain aligned to the first printed bar.
// ============================================================================

// ============================================================================
// CONSTANTS
// ============================================================================
const int MS_SEC  = 1000
const int MS_MIN  = 60 * MS_SEC
const int LEN_24H = 24 * 60 * MS_MIN
const int LEN_6H  = 6  * 60 * MS_MIN
const int LEN_90M = 90 * MS_MIN
const int LEN_22M30S = 22 * MS_MIN + 30 * MS_SEC  // 22.5 minutes

const string NANO_OPEN_TF = "5S"
const string MICRO_OPEN_TF = "30S"
const string M90_ALIGNED_TF = "5"
// Micro/Nano open capture uses fixed config to satisfy library request.* constraints.
// Aligned-TF OHLC uses fixed TFs to keep request.security inputs constant.
const string NANO_TZ = "America/New_York"
const int NANO_DAY_START_HOUR = 18
const int NANO_DAY_START_MIN = 0
// ============================================================================
// USER-DEFINED TYPES (UDTs)
// ============================================================================

export type QTConfig
    string tz
    int    dayStartHour
    int    dayStartMin
    int    keepCycles

    // Aligned TFs per QT cycle (canonical)
    string tfDaily      // "15"
    string tfM90        // "5"
    string tfMicro      // "30S"
    string tfNano       // "5S"

export type QuarterRecord
    int   boundaryTs
    float o
    float h
    float l
    float c
    int   oTs
    int   hTs
    int   lTs
    int   cTs
    bool  has
    bool  isEmpty
    bool  isFinal
    bool  evtStart
    bool  evtFinalize

export type CycleResult
    // Cycle window
    int  startTs
    int  endTs
    bool startRealized
    bool endRealized

    // Quarter boundaries (Q1 is the cycle start)
    int  q1Ts
    int  q2Ts
    int  q3Ts
    int  q4Ts

    // State-trigger realization (early mode)
    bool q2Realized
    bool q3Realized
    bool q4Realized

    // Where we are right now
    int  curQuarterIndex   // 1..4
    bool inWindow

    // Quarter records (OHLC + timestamps + flags; populated on chart TF)
    QuarterRecord q1
    QuarterRecord q2
    QuarterRecord q3
    QuarterRecord q4

export type WeeklyQuarter
    int   startIntent
    int   startEff
    int   endEff
    float open
    bool  hasData
    bool  openDelayed

export type WeeklyResult
    int   wsIntent
    int   wsEff
    int   wsNextIntent
    int   wsNextEff
    WeeklyQuarter q1
    WeeklyQuarter q2
    WeeklyQuarter q3
    WeeklyQuarter q4
    WeeklyQuarter q5

export type WeeklyState
    int   wsIntent
    int   wsEff
    int   wsNextIntent
    int   wsNextEff
    WeeklyQuarter q1
    WeeklyQuarter q2
    WeeklyQuarter q3
    WeeklyQuarter q4
    WeeklyQuarter q5

export type FixedCycleState
    // Printed-cycle retention (cycle starts)
    int[] starts
    int   lastStartTs

    // Last realized quarter boundary (start ts of the current quarter)
    int   lastBoundaryTs

    // Current-cycle quarter records (running OHLC on chart TF)
    QuarterRecord q1
    QuarterRecord q2
    QuarterRecord q3
    QuarterRecord q4

    // Small history buffer of finalized quarters (most recent first)
    QuarterRecord prev1
    QuarterRecord prev2

    // Micro/Nano: pending true-open capture (applied when quarter becomes active)
    int   pendingBoundaryTs
    float pendingOpen
    int   pendingOpenTs
    bool  pendingHas

    // Aligned-TF quarter records (Micro/Nano/90m; read-only path for now)
    QuarterRecord aq1
    QuarterRecord aq2
    QuarterRecord aq3
    QuarterRecord aq4
    QuarterRecord aprev1
    QuarterRecord aprev2
    int   alignedLastStartTs
    int   alignedLastBoundaryTs
    int   alignedLastBarTs

export type CycleState
    FixedCycleState daily
    FixedCycleState m90
    FixedCycleState micro
    FixedCycleState nano
    WeeklyState     weekly

// ============================================================================
// CONSTRUCTORS
// ============================================================================

export qt_config_default() =>
    QTConfig cfg = QTConfig.new(
        "America/New_York",
        18, 0,
        32,
        "15",
        "5",
        "30S",
        "5S"
    )
    cfg


export qt_state_new() =>
    QuarterRecord nilQ = QuarterRecord.new(
        int(na),
        float(na),
        float(na),
        float(na),
        float(na),
        int(na),
        int(na),
        int(na),
        int(na),
        false,
        true,
        false,
        false,
        false
    )

    FixedCycleState d = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false, nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), int(na), int(na))
    FixedCycleState m = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false, nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), int(na), int(na))
    FixedCycleState u = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false, nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), int(na), int(na))
    FixedCycleState n = FixedCycleState.new(array.new_int(), int(na), int(na), nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), float(na), int(na), false, nilQ, nilQ, nilQ, nilQ, nilQ, nilQ, int(na), int(na), int(na))
    WeeklyQuarter nilW = WeeklyQuarter.new(int(na), int(na), int(na), float(na), false, false)
    WeeklyState w = WeeklyState.new(int(na), int(na), int(na), int(na), nilW, nilW, nilW, nilW, nilW)
    CycleState st = CycleState.new(d, m, u, n, w)
    st


// ============================================================================
// HELPERS (timestamp math only)
// ============================================================================

f_qt_day_start_raw(int t, string tz, int dayStartHour, int dayStartMin) =>
    int y  = year(t, tz)
    int mo = month(t, tz)
    int da = dayofmonth(t, tz)
    int h  = hour(t, tz)
    int mi = minute(t, tz)
    int base = timestamp(tz, y, mo, da, dayStartHour, dayStartMin)
    int out  = (h > dayStartHour or (h == dayStartHour and mi >= dayStartMin)) ? base : base - LEN_24H
    out

f_qt_day_start(int t, QTConfig cfg) =>
    f_qt_day_start_raw(t, cfg.tz, cfg.dayStartHour, cfg.dayStartMin)

f_next_ds_after(int t, QTConfig cfg) =>
    int ds0 = f_qt_day_start(t, cfg)
    ds0 <= t ? ds0 + LEN_24H : ds0

f_cycle_start(int t, int baseTs, int lenMs) =>
    // Computes start = baseTs + floor((t - baseTs)/lenMs) * lenMs
    // Assumes baseTs is the correct anchor for t (e.g., DS for the day containing t)
    int k = int(math.floor((t - baseTs) / lenMs))
    baseTs + k * lenMs

f_quarter_index(int t, int cycleStart, int lenMs) =>
    int qLen = int(lenMs / 4)
    int qi0  = int(math.floor((t - cycleStart) / qLen))  // 0..3
    int qi1  = qi0 < 0 ? 0 : (qi0 > 3 ? 3 : qi0)
    qi1 + 1

f_make_empty_q(int qStart) =>
    QuarterRecord.new(
        qStart,
        na, na, na, na,
        int(na), int(na), int(na), int(na),
        false, true, false,
        false, false
    )

f_weekly_q_new(int startIntent) =>
    WeeklyQuarter.new(startIntent, int(na), int(na), float(na), false, false)

f_week_start_intent(int tRef, QTConfig cfg) =>
    int ds = f_qt_day_start(tRef, cfg)
    int dsDow = dayofweek(ds, cfg.tz)
    int offsetDays = dsDow - int(dayofweek.sunday)
    ds - offsetDays * LEN_24H

f_eff_from_intent(int intent, int effIn, int t, int tPrev) =>
    int effOut = effIn
    if na(effOut) and t >= intent and (na(tPrev) or tPrev < intent)
        effOut := t
    effOut

f_weekly_apply_bar(WeeklyQuarter qIn, int t, float o) =>
    WeeklyQuarter q = qIn
    bool isStartBar = not na(q.startEff) and t == q.startEff
    if not na(q.startEff)
        q.openDelayed := q.startEff > q.startIntent
    if isStartBar and not q.hasData
        q.open := o
        q.hasData := true
    q

// ============================================================================
// NANO OPEN SOURCE (FORCED 5S) — First printed 5s bar on/after boundary
// - This is a "first-on/after" policy (gap-safe) for Nano opens only.
// - H/L/C are still chart-TF aggregated (Step 2 scope stays intact).
// ============================================================================

f_ceil_to_5s(int ts) =>
    int step = 5 * MS_SEC
    int rem  = ts % step
    rem == 0 ? ts : ts + (step - rem)

f_nano_open_5s_expr() =>
    // Use bar start time to align "first printed bar on/after boundary".
    int tRef = time
    int ds = f_qt_day_start_raw(tRef, NANO_TZ, NANO_DAY_START_HOUR, NANO_DAY_START_MIN)

    int cStart = f_cycle_start(tRef, ds, LEN_22M30S)
    int qLen   = int(LEN_22M30S / 4)

    int q1Ts = cStart
    int q2Ts = cStart + 1 * qLen
    int q3Ts = cStart + 2 * qLen
    int q4Ts = cStart + 3 * qLen

    int qi = f_quarter_index(tRef, cStart, LEN_22M30S)

    int qCurTs = q1Ts
    if qi == 2
        qCurTs := q2Ts
    else if qi == 3
        qCurTs := q3Ts
    else if qi == 4
        qCurTs := q4Ts

    // Target = first 5s bar time on/after the (possibly half-second) boundary.
    int targetTs = f_ceil_to_5s(qCurTs)

    var int   lastTarget = int(na)
    var float oOut  = float(na)
    var int   tsOut = int(na)

    if na(lastTarget) or targetTs != lastTarget
        lastTarget := targetTs
        oOut  := float(na)
        tsOut := int(na)

    bool hit = (time >= targetTs) and (na(time[1]) or time[1] < targetTs)
    if hit and na(oOut)
        oOut  := open
        tsOut := time

    [oOut, tsOut, qi, qCurTs]

f_nano_open_current_5s() =>
    request.security(
        syminfo.tickerid,
        NANO_OPEN_TF,
        f_nano_open_5s_expr(),
        lookahead=barmerge.lookahead_off
    )

f_micro_aligned_ohlc_expr() =>
    [open, high, low, close, time]

f_micro_aligned_ohlc_current() =>
    request.security(
        syminfo.tickerid,
        MICRO_OPEN_TF,
        f_micro_aligned_ohlc_expr(),
        lookahead=barmerge.lookahead_off
    )

f_nano_aligned_ohlc_expr() =>
    [open, high, low, close, time]

f_nano_aligned_ohlc_current() =>
    request.security(
        syminfo.tickerid,
        NANO_OPEN_TF,
        f_nano_aligned_ohlc_expr(),
        lookahead=barmerge.lookahead_off
    )

f_m90_aligned_ohlc_expr() =>
    [open, high, low, close, time]

f_m90_aligned_ohlc_current() =>
    request.security(
        syminfo.tickerid,
        M90_ALIGNED_TF,
        f_m90_aligned_ohlc_expr(),
        lookahead=barmerge.lookahead_off
    )

f_aligned_ohlc_pick(bool isNano, bool isMicro, bool isM90) =>
    float pickO = float(na)
    float pickH = float(na)
    float pickL = float(na)
    float pickC = float(na)
    int   pickT = int(na)
    if isNano
        [tmpO, tmpH, tmpL, tmpC, tmpT] = f_nano_aligned_ohlc_current()
        pickO := tmpO
        pickH := tmpH
        pickL := tmpL
        pickC := tmpC
        pickT := tmpT
    else if isMicro
        [tmpO, tmpH, tmpL, tmpC, tmpT] = f_micro_aligned_ohlc_current()
        pickO := tmpO
        pickH := tmpH
        pickL := tmpL
        pickC := tmpC
        pickT := tmpT
    else if isM90
        [tmpO, tmpH, tmpL, tmpC, tmpT] = f_m90_aligned_ohlc_current()
        pickO := tmpO
        pickH := tmpH
        pickL := tmpL
        pickC := tmpC
        pickT := tmpT
    [pickO, pickH, pickL, pickC, pickT]

f_aligned_bar_timing(bool isNano, bool isMicro, bool isM90, int aT) =>
    int aLen = isNano ? 5 * MS_SEC : isMicro ? 30 * MS_SEC : isM90 ? 5 * MS_MIN : int(na)
    int aRef = isNano ? aT : (aT + aLen - 1)
    int aClose = aT + aLen
    [aLen, aRef, aClose]

f_ceil_to_30s(int ts) =>
    int step = 30 * MS_SEC
    int rem  = ts % step
    rem == 0 ? ts : ts + (step - rem)

f_micro_open_30s_expr() =>
    int tRef = time
    int ds = f_qt_day_start_raw(tRef, NANO_TZ, NANO_DAY_START_HOUR, NANO_DAY_START_MIN)

    int cStart = f_cycle_start(tRef, ds, LEN_90M)
    int qLen   = int(LEN_90M / 4)

    int q1Ts = cStart
    int q2Ts = cStart + 1 * qLen
    int q3Ts = cStart + 2 * qLen
    int q4Ts = cStart + 3 * qLen

    int qi = f_quarter_index(tRef, cStart, LEN_90M)

    int qCurTs = q1Ts
    if qi == 2
        qCurTs := q2Ts
    else if qi == 3
        qCurTs := q3Ts
    else if qi == 4
        qCurTs := q4Ts

    int targetTs = f_ceil_to_30s(qCurTs)

    var int   lastTarget = int(na)
    var float oOut  = float(na)
    var int   tsOut = int(na)

    if na(lastTarget) or targetTs != lastTarget
        lastTarget := targetTs
        oOut  := float(na)
        tsOut := int(na)

    bool hit = (time >= targetTs) and (na(time[1]) or time[1] < targetTs)
    if hit and na(oOut)
        oOut  := open
        tsOut := time

    [oOut, tsOut, qi, qCurTs]

f_micro_open_current_30s() =>
    request.security(
        syminfo.tickerid,
        MICRO_OPEN_TF,
        f_micro_open_30s_expr(),
        lookahead=barmerge.lookahead_off
    )

// ============================================================================
// STEP 2 HELPERS — Chart-TF quarter OHLC aggregation (minimal, gap-safe)
// ============================================================================

f_q_clear_evts(QuarterRecord qIn) =>
    QuarterRecord q = qIn
    q.evtStart := false
    q.evtFinalize := false
    q

f_q_finalize(QuarterRecord qIn) =>
    QuarterRecord q = qIn
    q.isFinal := true
    q.evtFinalize := true
    if not q.has
        q.isEmpty := true
    q

f_finalize_and_roll(QuarterRecord qIn, QuarterRecord prev1In, QuarterRecord prev2In) =>
    QuarterRecord q = qIn
    QuarterRecord p1 = prev1In
    QuarterRecord p2 = prev2In
    if not q.isFinal and not na(q.boundaryTs)
        q := f_q_finalize(q)
        p2 := p1
        p1 := q
    [q, p1, p2]

f_q_apply_bar(QuarterRecord qIn, int t, float o, float h, float l, float c, bool isStartBar) =>
    QuarterRecord q = qIn

    if not q.has
        q.o := o
        q.oTs := t
        q.h := h
        q.hTs := t
        q.l := l
        q.lTs := t
        q.c := c
        q.cTs := t
        q.has := true
        q.isEmpty := false
        q.isFinal := false
        q.evtStart := isStartBar
    else
        bool newHigh = na(q.h) or h > q.h
        bool newLow  = na(q.l) or l < q.l
        if newHigh
            q.h := h
            q.hTs := t
        if newLow
            q.l := l
            q.lTs := t
        q.c := c
        q.cTs := t
        if isStartBar
            q.evtStart := true

    q

f_q_idx_from_boundary(int boundaryTs, int q1Ts, int q2Ts, int q3Ts, int q4Ts) =>
    int idx = 0
    if not na(boundaryTs)
        if boundaryTs == q1Ts
            idx := 1
        else if boundaryTs == q2Ts
            idx := 2
        else if boundaryTs == q3Ts
            idx := 3
        else if boundaryTs == q4Ts
            idx := 4
    idx


f_push_printed_start(int[] startsIn, int startTs, int keepCycles) =>
    // No mutation of input param: copy first, return the new array.
    int[] out = array.copy(startsIn)
    int sz = array.size(out)
    int last = sz > 0 ? array.get(out, sz - 1) : int(na)
    if na(last) or startTs > last
        array.push(out, startTs)

    // Cap to keepCycles (drop oldest)
    while array.size(out) > keepCycles
        array.shift(out)

    out

// ============================================================================

// CORE FIXED-CYCLE UPDATE (STEP 2: CHART-TF OHLC)
// - Enabled now for Daily + m90 + Micro + Nano.
// - This step aggregates quarter OHLC on chart TF into QuarterRecords
// - Gap-safe: skipped quarters finalize as isEmpty/isFinal on the next printed bar
// ============================================================================

f_fixed_cycle_update(
    FixedCycleState stIn,
    QTConfig cfg,
    int t,
    int tClose,
    int lenMs
) =>
    bool isNano = (lenMs == LEN_22M30S)
    bool isMicro = (lenMs == LEN_90M)
    bool isM90 = (lenMs == LEN_6H)
    int tRef = isNano ? t : (tClose - 1)
    int ds = f_qt_day_start(tRef, cfg)

    int cStart = f_cycle_start(tRef, ds, lenMs)
    int cEnd   = cStart + lenMs
    int qLen   = int(lenMs / 4)

    int q1Ts = cStart
    int q2Ts = cStart + 1 * qLen
    int q3Ts = cStart + 2 * qLen
    int q4Ts = cStart + 3 * qLen

    bool q2R = tClose > q2Ts
    bool q3R = tClose > q3Ts
    bool q4R = tClose > q4Ts

    bool sR  = tClose > cStart
    bool eR  = tClose > cEnd

    bool inW = tRef >= cStart and tRef < cEnd
    int  qi  = f_quarter_index(tRef, cStart, lenMs)

    // Printed start retention + cycle-change detection
    int[] starts2    = stIn.starts
    int  lastStart2  = stIn.lastStartTs
    bool cycleChanged = na(lastStart2) or cStart != lastStart2
    if cycleChanged
        starts2    := f_push_printed_start(stIn.starts, cStart, cfg.keepCycles)
        lastStart2 := cStart

    // Local copies (clear pulse events each bar)
    QuarterRecord q1 = f_q_clear_evts(stIn.q1)
    QuarterRecord q2 = f_q_clear_evts(stIn.q2)
    QuarterRecord q3 = f_q_clear_evts(stIn.q3)
    QuarterRecord q4 = f_q_clear_evts(stIn.q4)

    QuarterRecord prev1 = f_q_clear_evts(stIn.prev1)
    QuarterRecord prev2 = f_q_clear_evts(stIn.prev2)

    int lastBoundary2 = stIn.lastBoundaryTs
    int pendingBoundary2 = stIn.pendingBoundaryTs
    float pendingOpen2 = stIn.pendingOpen
    int pendingOpenTs2 = stIn.pendingOpenTs
    bool pendingHas2 = stIn.pendingHas
    QuarterRecord aq1 = f_q_clear_evts(stIn.aq1)
    QuarterRecord aq2 = f_q_clear_evts(stIn.aq2)
    QuarterRecord aq3 = f_q_clear_evts(stIn.aq3)
    QuarterRecord aq4 = f_q_clear_evts(stIn.aq4)
    QuarterRecord aprev1 = f_q_clear_evts(stIn.aprev1)
    QuarterRecord aprev2 = f_q_clear_evts(stIn.aprev2)
    int alignedLastStart2 = stIn.alignedLastStartTs
    int alignedLastBoundary2 = stIn.alignedLastBoundaryTs
    int alignedLastBar2 = stIn.alignedLastBarTs

    // If cycle rolled, finalize remaining old-cycle quarters (gap-safe), then reset records for the new cycle.
    if cycleChanged
        int lastIdxOld = f_q_idx_from_boundary(lastBoundary2, q1.boundaryTs, q2.boundaryTs, q3.boundaryTs, q4.boundaryTs)

        if lastIdxOld == 0 or lastIdxOld == 1   
            [tmpQ1_1, tmpP1_1, tmpP2_1] = f_finalize_and_roll(q1, prev1, prev2)
            q1 := tmpQ1_1
            prev1 := tmpP1_1
            prev2 := tmpP2_1

            [tmpQ2_2, tmpP1_2, tmpP2_2] = f_finalize_and_roll(q2, prev1, prev2)
            q2 := tmpQ2_2
            prev1 := tmpP1_2
            prev2 := tmpP2_2

            [tmpQ3_3, tmpP1_3, tmpP2_3] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_3
            prev1 := tmpP1_3
            prev2 := tmpP2_3

            [tmpQ4_4, tmpP1_4, tmpP2_4] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_4
            prev1 := tmpP1_4
            prev2 := tmpP2_4

        else if lastIdxOld == 2
            [tmpQ2_5, tmpP1_5, tmpP2_5] = f_finalize_and_roll(q2, prev1, prev2)
            q2 := tmpQ2_5
            prev1 := tmpP1_5
            prev2 := tmpP2_5

            [tmpQ3_6, tmpP1_6, tmpP2_6] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_6
            prev1 := tmpP1_6
            prev2 := tmpP2_6

            [tmpQ4_7, tmpP1_7, tmpP2_7] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_7
            prev1 := tmpP1_7
            prev2 := tmpP2_7

        else if lastIdxOld == 3
            [tmpQ3_8, tmpP1_8, tmpP2_8] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_8
            prev1 := tmpP1_8
            prev2 := tmpP2_8

            [tmpQ4_9, tmpP1_9, tmpP2_9] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_9
            prev1 := tmpP1_9
            prev2 := tmpP2_9

        else if lastIdxOld == 4
            [tmpQ4_10, tmpP1_10, tmpP2_10] = f_finalize_and_roll(q4, prev1, prev2)
            q4 := tmpQ4_10
            prev1 := tmpP1_10
            prev2 := tmpP2_10


        q1 := f_make_empty_q(q1Ts)
        q2 := f_make_empty_q(q2Ts)
        q3 := f_make_empty_q(q3Ts)
        q4 := f_make_empty_q(q4Ts)
        lastBoundary2 := int(na)
        pendingBoundary2 := int(na)
        pendingOpen2 := float(na)
        pendingOpenTs2 := int(na)
        pendingHas2 := false

    // Ensure boundaries are correct (first run or mismatch)
    if na(q1.boundaryTs) or q1.boundaryTs != q1Ts
        q1 := f_make_empty_q(q1Ts)
    if na(q2.boundaryTs) or q2.boundaryTs != q2Ts
        q2 := f_make_empty_q(q2Ts)
    if na(q3.boundaryTs) or q3.boundaryTs != q3Ts
        q3 := f_make_empty_q(q3Ts)
    if na(q4.boundaryTs) or q4.boundaryTs != q4Ts
        q4 := f_make_empty_q(q4Ts)
    if pendingHas2 and pendingBoundary2 != q1Ts and pendingBoundary2 != q2Ts and pendingBoundary2 != q3Ts and pendingBoundary2 != q4Ts
        pendingBoundary2 := int(na)
        pendingOpen2 := float(na)
        pendingOpenTs2 := int(na)
        pendingHas2 := false

    // Current quarter boundary for this bar
    int qCurTs = q1Ts
    if qi == 2
        qCurTs := q2Ts
    else if qi == 3
        qCurTs := q3Ts
    else if qi == 4
        qCurTs := q4Ts

    bool startEdge = inW and (tClose > qCurTs) and (na(lastBoundary2) or qCurTs != lastBoundary2)
    float nanoO5 = float(na)
    int   nanoOTs5 = int(na)
    int   nanoQi5 = int(na)
    int   nanoQCurTs5 = int(na)
    float microO30 = float(na)
    int   microOTs30 = int(na)
    int   microQi30 = int(na)
    int   microQCurTs30 = int(na)
    if isNano
        [tNanoO5, tNanoOTs5, tNanoQi5, tNanoQCurTs5] = f_nano_open_current_5s()
        nanoO5 := tNanoO5
        nanoOTs5 := tNanoOTs5
        nanoQi5 := tNanoQi5
        nanoQCurTs5 := tNanoQCurTs5
        if not na(nanoO5) and not na(nanoOTs5)
            if nanoQCurTs5 == q1Ts or nanoQCurTs5 == q2Ts or nanoQCurTs5 == q3Ts or nanoQCurTs5 == q4Ts
                pendingBoundary2 := nanoQCurTs5
                pendingOpen2 := nanoO5
                pendingOpenTs2 := nanoOTs5
                pendingHas2 := true
    if isMicro
        [tMicroO30, tMicroOTs30, tMicroQi30, tMicroQCurTs30] = f_micro_open_current_30s()
        microO30 := tMicroO30
        microOTs30 := tMicroOTs30
        microQi30 := tMicroQi30
        microQCurTs30 := tMicroQCurTs30
        if not na(microO30) and not na(microOTs30)
            if microQCurTs30 == q1Ts or microQCurTs30 == q2Ts or microQCurTs30 == q3Ts or microQCurTs30 == q4Ts
                pendingBoundary2 := microQCurTs30
                pendingOpen2 := microO30
                pendingOpenTs2 := microOTs30
                pendingHas2 := true

    // Aligned-TF quarter aggregation (Micro/Nano/90m).
    [aO, aH, aL, aC, aT] = f_aligned_ohlc_pick(isNano, isMicro, isM90)

    bool aNew = not na(aT) and (na(alignedLastBar2) or aT != alignedLastBar2)
    if aNew
        alignedLastBar2 := aT
        [aLen, aRef, aClose] = f_aligned_bar_timing(isNano, isMicro, isM90, aT)
        int aDs = f_qt_day_start(aRef, cfg)
        int aCStart = f_cycle_start(aRef, aDs, lenMs)
        int aCEnd = aCStart + lenMs
        int aQLen = int(lenMs / 4)

        int aq1Ts = aCStart
        int aq2Ts = aCStart + 1 * aQLen
        int aq3Ts = aCStart + 2 * aQLen
        int aq4Ts = aCStart + 3 * aQLen

        int aQi = f_quarter_index(aRef, aCStart, lenMs)
        bool aInW = aRef >= aCStart and aRef < aCEnd
        bool aCycleChanged = na(alignedLastStart2) or aCStart != alignedLastStart2
        if aCycleChanged
            int aLastIdxOld = f_q_idx_from_boundary(alignedLastBoundary2, aq1.boundaryTs, aq2.boundaryTs, aq3.boundaryTs, aq4.boundaryTs)

            if aLastIdxOld == 0 or aLastIdxOld == 1
                [tmpAQ1_1, tmpAP1_1, tmpAP2_1] = f_finalize_and_roll(aq1, aprev1, aprev2)
                aq1 := tmpAQ1_1
                aprev1 := tmpAP1_1
                aprev2 := tmpAP2_1

                [tmpAQ2_2, tmpAP1_2, tmpAP2_2] = f_finalize_and_roll(aq2, aprev1, aprev2)
                aq2 := tmpAQ2_2
                aprev1 := tmpAP1_2
                aprev2 := tmpAP2_2

                [tmpAQ3_3, tmpAP1_3, tmpAP2_3] = f_finalize_and_roll(aq3, aprev1, aprev2)
                aq3 := tmpAQ3_3
                aprev1 := tmpAP1_3
                aprev2 := tmpAP2_3

                [tmpAQ4_4, tmpAP1_4, tmpAP2_4] = f_finalize_and_roll(aq4, aprev1, aprev2)
                aq4 := tmpAQ4_4
                aprev1 := tmpAP1_4
                aprev2 := tmpAP2_4

            else if aLastIdxOld == 2
                [tmpAQ2_5, tmpAP1_5, tmpAP2_5] = f_finalize_and_roll(aq2, aprev1, aprev2)
                aq2 := tmpAQ2_5
                aprev1 := tmpAP1_5
                aprev2 := tmpAP2_5

                [tmpAQ3_6, tmpAP1_6, tmpAP2_6] = f_finalize_and_roll(aq3, aprev1, aprev2)
                aq3 := tmpAQ3_6
                aprev1 := tmpAP1_6
                aprev2 := tmpAP2_6

                [tmpAQ4_7, tmpAP1_7, tmpAP2_7] = f_finalize_and_roll(aq4, aprev1, aprev2)
                aq4 := tmpAQ4_7
                aprev1 := tmpAP1_7
                aprev2 := tmpAP2_7

            else if aLastIdxOld == 3
                [tmpAQ3_8, tmpAP1_8, tmpAP2_8] = f_finalize_and_roll(aq3, aprev1, aprev2)
                aq3 := tmpAQ3_8
                aprev1 := tmpAP1_8
                aprev2 := tmpAP2_8

                [tmpAQ4_9, tmpAP1_9, tmpAP2_9] = f_finalize_and_roll(aq4, aprev1, aprev2)
                aq4 := tmpAQ4_9
                aprev1 := tmpAP1_9
                aprev2 := tmpAP2_9

            else if aLastIdxOld == 4
                [tmpAQ4_10, tmpAP1_10, tmpAP2_10] = f_finalize_and_roll(aq4, aprev1, aprev2)
                aq4 := tmpAQ4_10
                aprev1 := tmpAP1_10
                aprev2 := tmpAP2_10

            aq1 := f_make_empty_q(aq1Ts)
            aq2 := f_make_empty_q(aq2Ts)
            aq3 := f_make_empty_q(aq3Ts)
            aq4 := f_make_empty_q(aq4Ts)
            alignedLastBoundary2 := int(na)
            alignedLastStart2 := aCStart

        if na(aq1.boundaryTs) or aq1.boundaryTs != aq1Ts
            aq1 := f_make_empty_q(aq1Ts)
        if na(aq2.boundaryTs) or aq2.boundaryTs != aq2Ts
            aq2 := f_make_empty_q(aq2Ts)
        if na(aq3.boundaryTs) or aq3.boundaryTs != aq3Ts
            aq3 := f_make_empty_q(aq3Ts)
        if na(aq4.boundaryTs) or aq4.boundaryTs != aq4Ts
            aq4 := f_make_empty_q(aq4Ts)

        int aQCurTs = aq1Ts
        if aQi == 2
            aQCurTs := aq2Ts
        else if aQi == 3
            aQCurTs := aq3Ts
        else if aQi == 4
            aQCurTs := aq4Ts

        bool aStartEdge = aInW and (aClose > aQCurTs) and (na(alignedLastBoundary2) or aQCurTs != alignedLastBoundary2)
        if aStartEdge and not aCycleChanged
            int aLastIdx = f_q_idx_from_boundary(alignedLastBoundary2, aq1Ts, aq2Ts, aq3Ts, aq4Ts)
            int aNewIdx  = aQi

            if aLastIdx == 1
                [tmpAQ1_A, tmpAP1_A, tmpAP2_A] = f_finalize_and_roll(aq1, aprev1, aprev2)
                aq1 := tmpAQ1_A
                aprev1 := tmpAP1_A
                aprev2 := tmpAP2_A

                if aNewIdx >= 3
                    [tmpAQ2_B, tmpAP1_B, tmpAP2_B] = f_finalize_and_roll(aq2, aprev1, aprev2)
                    aq2 := tmpAQ2_B
                    aprev1 := tmpAP1_B
                    aprev2 := tmpAP2_B

                if aNewIdx >= 4
                    [tmpAQ3_C, tmpAP1_C, tmpAP2_C] = f_finalize_and_roll(aq3, aprev1, aprev2)
                    aq3 := tmpAQ3_C
                    aprev1 := tmpAP1_C
                    aprev2 := tmpAP2_C

            else if aLastIdx == 2
                [tmpAQ2_D, tmpAP1_D, tmpAP2_D] = f_finalize_and_roll(aq2, aprev1, aprev2)
                aq2 := tmpAQ2_D
                aprev1 := tmpAP1_D
                aprev2 := tmpAP2_D

                if aNewIdx >= 4
                    [tmpAQ3_E, tmpAP1_E, tmpAP2_E] = f_finalize_and_roll(aq3, aprev1, aprev2)
                    aq3 := tmpAQ3_E
                    aprev1 := tmpAP1_E
                    aprev2 := tmpAP2_E

            else if aLastIdx == 3
                [tmpAQ3_F, tmpAP1_F, tmpAP2_F] = f_finalize_and_roll(aq3, aprev1, aprev2)
                aq3 := tmpAQ3_F
                aprev1 := tmpAP1_F
                aprev2 := tmpAP2_F

        if aStartEdge
            alignedLastBoundary2 := aQCurTs

        if not na(aO) and not na(aH) and not na(aL) and not na(aC)
            if aQi == 1 and not aq1.isFinal
                aq1 := f_q_apply_bar(aq1, aT, aO, aH, aL, aC, aStartEdge)
            else if aQi == 2 and not aq2.isFinal
                aq2 := f_q_apply_bar(aq2, aT, aO, aH, aL, aC, aStartEdge)
            else if aQi == 3 and not aq3.isFinal
                aq3 := f_q_apply_bar(aq3, aT, aO, aH, aL, aC, aStartEdge)
            else if aQi == 4 and not aq4.isFinal
                aq4 := f_q_apply_bar(aq4, aT, aO, aH, aL, aC, aStartEdge)


    // Finalize the quarter we were last in (and any skipped quarters) on the first bar of the new quarter.
    if startEdge and not cycleChanged
        int lastIdx = f_q_idx_from_boundary(lastBoundary2, q1Ts, q2Ts, q3Ts, q4Ts)
        int newIdx  = qi

        if lastIdx == 1
            [tmpQ1_A, tmpP1_A, tmpP2_A] = f_finalize_and_roll(q1, prev1, prev2)
            q1 := tmpQ1_A
            prev1 := tmpP1_A
            prev2 := tmpP2_A

            if newIdx >= 3
                [tmpQ2_B, tmpP1_B, tmpP2_B] = f_finalize_and_roll(q2, prev1, prev2)
                q2 := tmpQ2_B
                prev1 := tmpP1_B
                prev2 := tmpP2_B

            if newIdx >= 4
                [tmpQ3_C, tmpP1_C, tmpP2_C] = f_finalize_and_roll(q3, prev1, prev2)
                q3 := tmpQ3_C
                prev1 := tmpP1_C
                prev2 := tmpP2_C

        else if lastIdx == 2
            [tmpQ2_D, tmpP1_D, tmpP2_D] = f_finalize_and_roll(q2, prev1, prev2)
            q2 := tmpQ2_D
            prev1 := tmpP1_D
            prev2 := tmpP2_D

            if newIdx >= 4
                [tmpQ3_E, tmpP1_E, tmpP2_E] = f_finalize_and_roll(q3, prev1, prev2)
                q3 := tmpQ3_E
                prev1 := tmpP1_E
                prev2 := tmpP2_E

        else if lastIdx == 3
            [tmpQ3_F, tmpP1_F, tmpP2_F] = f_finalize_and_roll(q3, prev1, prev2)
            q3 := tmpQ3_F
            prev1 := tmpP1_F
            prev2 := tmpP2_F


    if startEdge
        lastBoundary2 := qCurTs

    // Update active quarter OHLC on chart TF
    if qi == 1 and not q1.isFinal
        q1 := f_q_apply_bar(q1, t, open, high, low, close, startEdge)
    else if qi == 2 and not q2.isFinal
        q2 := f_q_apply_bar(q2, t, open, high, low, close, startEdge)
    else if qi == 3 and not q3.isFinal
        q3 := f_q_apply_bar(q3, t, open, high, low, close, startEdge)
    else if qi == 4 and not q4.isFinal
        q4 := f_q_apply_bar(q4, t, open, high, low, close, startEdge)

    // Micro/Nano: apply pending true-open when its quarter becomes active.
    if (isNano or isMicro) and pendingHas2
        if pendingBoundary2 == q1Ts and qi == 1
            q1.o   := pendingOpen2
            q1.oTs := pendingOpenTs2
            pendingHas2 := false
        else if pendingBoundary2 == q2Ts and qi == 2
            q2.o   := pendingOpen2
            q2.oTs := pendingOpenTs2
            pendingHas2 := false
        else if pendingBoundary2 == q3Ts and qi == 3
            q3.o   := pendingOpen2
            q3.oTs := pendingOpenTs2
            pendingHas2 := false
        else if pendingBoundary2 == q4Ts and qi == 4
            q4.o   := pendingOpen2
            q4.oTs := pendingOpenTs2
            pendingHas2 := false
        else if (pendingBoundary2 == q1Ts and qi > 1) or (pendingBoundary2 == q2Ts and qi > 2) or (pendingBoundary2 == q3Ts and qi > 3)
            pendingBoundary2 := int(na)
            pendingOpen2 := float(na)
            pendingOpenTs2 := int(na)
            pendingHas2 := false

    // Phase 3: Micro/Nano H/L/C come from aligned-TF quarter aggregation.
    if isNano or isMicro
        q1.h := aq1.h
        q1.hTs := aq1.hTs
        q1.l := aq1.l
        q1.lTs := aq1.lTs
        q1.c := aq1.c
        q1.cTs := aq1.cTs

        q2.h := aq2.h
        q2.hTs := aq2.hTs
        q2.l := aq2.l
        q2.lTs := aq2.lTs
        q2.c := aq2.c
        q2.cTs := aq2.cTs

        q3.h := aq3.h
        q3.hTs := aq3.hTs
        q3.l := aq3.l
        q3.lTs := aq3.lTs
        q3.c := aq3.c
        q3.cTs := aq3.cTs

        q4.h := aq4.h
        q4.hTs := aq4.hTs
        q4.l := aq4.l
        q4.lTs := aq4.lTs
        q4.c := aq4.c
        q4.cTs := aq4.cTs

    // Phase 3b: 90m O/C come from aligned-TF quarter aggregation.
    if isM90
        q1.o := aq1.o
        q1.oTs := aq1.oTs
        q1.c := aq1.c
        q1.cTs := aq1.cTs

        q2.o := aq2.o
        q2.oTs := aq2.oTs
        q2.c := aq2.c
        q2.cTs := aq2.cTs

        q3.o := aq3.o
        q3.oTs := aq3.oTs
        q3.c := aq3.c
        q3.cTs := aq3.cTs

        q4.o := aq4.o
        q4.oTs := aq4.oTs
        q4.c := aq4.c
        q4.cTs := aq4.cTs

    FixedCycleState stOut = FixedCycleState.new(starts2, lastStart2, lastBoundary2, q1, q2, q3, q4, prev1, prev2, pendingBoundary2, pendingOpen2, pendingOpenTs2, pendingHas2, aq1, aq2, aq3, aq4, aprev1, aprev2, alignedLastStart2, alignedLastBoundary2, alignedLastBar2)

    CycleResult res = CycleResult.new(
        cStart, cEnd,
        sR, eR,
        q1Ts, q2Ts, q3Ts, q4Ts,
        q2R, q3R, q4R,
        qi, inW,
        q1, q2, q3, q4
    )

    [stOut, res]

f_weekly_update(
    WeeklyState stIn,
    QTConfig cfg,
    int t,
    int tClose
) =>
    int tRef = tClose - 1
    int wsIntent = f_week_start_intent(tRef, cfg)
    int wsNextIntent = wsIntent + 7 * LEN_24H

    int q1Intent = wsIntent
    int q2Intent = wsIntent + 1 * LEN_24H
    int q3Intent = wsIntent + 2 * LEN_24H
    int q4Intent = wsIntent + 3 * LEN_24H
    int q5Intent = wsIntent + 4 * LEN_24H

    bool weekChanged = na(stIn.wsIntent) or wsIntent != stIn.wsIntent

    WeeklyQuarter q1 = stIn.q1
    WeeklyQuarter q2 = stIn.q2
    WeeklyQuarter q3 = stIn.q3
    WeeklyQuarter q4 = stIn.q4
    WeeklyQuarter q5 = stIn.q5
    int wsEff = stIn.wsEff
    int wsNextEff = stIn.wsNextEff

    if weekChanged
        q1 := f_weekly_q_new(q1Intent)
        q2 := f_weekly_q_new(q2Intent)
        q3 := f_weekly_q_new(q3Intent)
        q4 := f_weekly_q_new(q4Intent)
        q5 := f_weekly_q_new(q5Intent)
        wsEff := int(na)
        wsNextEff := int(na)
    else
        if q1.startIntent != q1Intent
            q1 := f_weekly_q_new(q1Intent)
        if q2.startIntent != q2Intent
            q2 := f_weekly_q_new(q2Intent)
        if q3.startIntent != q3Intent
            q3 := f_weekly_q_new(q3Intent)
        if q4.startIntent != q4Intent
            q4 := f_weekly_q_new(q4Intent)
        if q5.startIntent != q5Intent
            q5 := f_weekly_q_new(q5Intent)

    int tPrev = time[1]
    wsEff := f_eff_from_intent(wsIntent, wsEff, t, tPrev)
    wsNextEff := f_eff_from_intent(wsNextIntent, wsNextEff, t, tPrev)

    q1.startEff := f_eff_from_intent(q1Intent, q1.startEff, t, tPrev)
    q2.startEff := f_eff_from_intent(q2Intent, q2.startEff, t, tPrev)
    q3.startEff := f_eff_from_intent(q3Intent, q3.startEff, t, tPrev)
    q4.startEff := f_eff_from_intent(q4Intent, q4.startEff, t, tPrev)
    q5.startEff := f_eff_from_intent(q5Intent, q5.startEff, t, tPrev)

    q1.endEff := q2.startEff
    q2.endEff := q3.startEff
    q3.endEff := q4.startEff
    q4.endEff := q5.startEff
    q5.endEff := wsNextEff

    q1 := f_weekly_apply_bar(q1, t, open)
    q2 := f_weekly_apply_bar(q2, t, open)
    q3 := f_weekly_apply_bar(q3, t, open)
    q4 := f_weekly_apply_bar(q4, t, open)
    q5 := f_weekly_apply_bar(q5, t, open)

    WeeklyState stOut = WeeklyState.new(wsIntent, wsEff, wsNextIntent, wsNextEff, q1, q2, q3, q4, q5)
    WeeklyResult res = WeeklyResult.new(wsIntent, wsEff, wsNextIntent, wsNextEff, q1, q2, q3, q4, q5)
    [stOut, res]


// ============================================================================
// EXPORTED API — Fixed cycles only (no Weekly)
// ============================================================================

export qt_daily_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [d2, r] = f_fixed_cycle_update(st.daily, cfg, t, tClose, LEN_24H)
    CycleState out = CycleState.new(d2, st.m90, st.micro, st.nano, st.weekly)
    [out, r]

export qt_m90_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [m2, r] = f_fixed_cycle_update(st.m90, cfg, t, tClose, LEN_6H)
    CycleState out = CycleState.new(st.daily, m2, st.micro, st.nano, st.weekly)
    [out, r]

export qt_micro_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [u2, r] = f_fixed_cycle_update(st.micro, cfg, t, tClose, LEN_90M)
    CycleState out = CycleState.new(st.daily, st.m90, u2, st.nano, st.weekly)
    [out, r]

export qt_nano_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [n2, r] = f_fixed_cycle_update(st.nano, cfg, t, tClose, LEN_22M30S)
    CycleState out = CycleState.new(st.daily, st.m90, st.micro, n2, st.weekly)
    [out, r]

export qt_weekly_update(CycleState st, QTConfig cfg, int t, int tClose) =>
    [w2, r] = f_weekly_update(st.weekly, cfg, t, tClose)
    CycleState out = CycleState.new(st.daily, st.m90, st.micro, st.nano, w2)
    [out, r]

// ============================================================================
// DEBUG EXPORTS (read-only)
// ============================================================================

export qt_nano_open_debug() =>
    f_nano_open_current_5s()

export qt_micro_aligned_ohlc_debug() =>
    f_micro_aligned_ohlc_current()

export qt_nano_aligned_ohlc_debug() =>
    f_nano_aligned_ohlc_current()

export qt_m90_aligned_ohlc_debug() =>
    f_m90_aligned_ohlc_current()

export qt_micro_aligned_qr_debug(CycleState st) =>
    [st.micro.aq1, st.micro.aq2, st.micro.aq3, st.micro.aq4]

export qt_nano_aligned_qr_debug(CycleState st) =>
    [st.nano.aq1, st.nano.aq2, st.nano.aq3, st.nano.aq4]

export qt_weekly_debug(CycleState st) =>
    st.weekly
