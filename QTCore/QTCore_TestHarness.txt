//@version=6
indicator("QT Core — Test Harness (m90 Step 2)", overlay=true, max_labels_count=500)

// paste the copied import line here:
// import <you>/<QT Core>/<version> as qt
import Jaw1312/QTCore/3 as qt

// -----------------------------------------------------------------------------
// Helpers (display-only)
// -----------------------------------------------------------------------------
f_hhmm(int ts, string tz) =>
    int hh = hour(ts, tz)
    int mm = minute(ts, tz)
    hh * 100 + mm

// -----------------------------------------------------------------------------
// State
// -----------------------------------------------------------------------------
var qt.QTConfig cfg = qt.qt_config_default()
var qt.CycleState st = qt.qt_state_new()

int t = time
int tClose = time_close

// Keep Daily update first (shared state), then m90.
[stD, d] = qt.qt_daily_update(st, cfg, t, tClose)
[stM, m] = qt.qt_m90_update(stD, cfg, t, tClose)

// -----------------------------------------------------------------------------
// Labels (optional) — to visually confirm boundary realizes where you expect
// -----------------------------------------------------------------------------
showM90Labels = input.bool(true, "Label m90 Q# on chart")

// Use the current quarter boundary for label placement.
int tsM = m.q1Ts
if m.curQuarterIndex == 2
    tsM := m.q2Ts
else if m.curQuarterIndex == 3
    tsM := m.q3Ts
else if m.curQuarterIndex == 4
    tsM := m.q4Ts

bool okM = not na(tsM)
var int lastM90LabelTs = na

if showM90Labels
    if okM and tsM != lastM90LabelTs and tClose > tsM
        label.new(tsM, high, "m90 Q" + str.tostring(m.curQuarterIndex), xloc=xloc.bar_time, style=label.style_label_down)
        lastM90LabelTs := tsM

// -----------------------------------------------------------------------------
// Step 1 checks (timestamps parity)
// -----------------------------------------------------------------------------
showStep1M90 = input.bool(true, "Step 1: QuarterRecord boundaryTs checks (m90)")

plot(m.curQuarterIndex, "m90 Q#", display=display.data_window)

plot(showStep1M90 ? (m.q1Ts == m.q1.boundaryTs ? 1 : 0) : na, "m90 QR match q1Ts==q1.boundaryTs", display=display.data_window)
plot(showStep1M90 ? (m.q2Ts == m.q2.boundaryTs ? 1 : 0) : na, "m90 QR match q2Ts==q2.boundaryTs", display=display.data_window)
plot(showStep1M90 ? (m.q3Ts == m.q3.boundaryTs ? 1 : 0) : na, "m90 QR match q3Ts==q3.boundaryTs", display=display.data_window)
plot(showStep1M90 ? (m.q4Ts == m.q4.boundaryTs ? 1 : 0) : na, "m90 QR match q4Ts==q4.boundaryTs", display=display.data_window)

// -----------------------------------------------------------------------------
// Step 2 checks (chart-TF OHLC aggregation + finalize/skip + history roll)
// - For this test harness we only surface q1 and q2 to stay under the 64-plot limit.
// -----------------------------------------------------------------------------
showStep2M90 = input.bool(true, "Step 2: QuarterRecord OHLC + flags (m90)")

// q1
plot(showStep2M90 ? m.q1.o : na, "m90 QR q1.o", display=display.data_window)
plot(showStep2M90 ? m.q1.h : na, "m90 QR q1.h", display=display.data_window)
plot(showStep2M90 ? m.q1.l : na, "m90 QR q1.l", display=display.data_window)
plot(showStep2M90 ? m.q1.c : na, "m90 QR q1.c", display=display.data_window)

plot(showStep2M90 ? float(f_hhmm(m.q1.oTs, cfg.tz)) : na, "m90 QR q1.oTs (HHMM)", display=display.data_window)
plot(showStep2M90 ? float(f_hhmm(m.q1.hTs, cfg.tz)) : na, "m90 QR q1.hTs (HHMM)", display=display.data_window)
plot(showStep2M90 ? float(f_hhmm(m.q1.lTs, cfg.tz)) : na, "m90 QR q1.lTs (HHMM)", display=display.data_window)
plot(showStep2M90 ? float(f_hhmm(m.q1.cTs, cfg.tz)) : na, "m90 QR q1.cTs (HHMM)", display=display.data_window)

plot(showStep2M90 ? (m.q1.isEmpty ? 1 : 0) : na, "m90 QR q1.isEmpty", display=display.data_window)
plot(showStep2M90 ? (m.q1.has ? 1 : 0) : na, "m90 QR q1.has", display=display.data_window)
plot(showStep2M90 ? (m.q1.isFinal ? 1 : 0) : na, "m90 QR q1.isFinal", display=display.data_window)
plot(showStep2M90 ? (m.q1.evtStart ? 1 : 0) : na, "m90 QR q1.evtStart", display=display.data_window)
plot(showStep2M90 ? (m.q1.evtFinalize ? 1 : 0) : na, "m90 QR q1.evtFinalize", display=display.data_window)

// q2
plot(showStep2M90 ? m.q2.o : na, "m90 QR q2.o", display=display.data_window)
plot(showStep2M90 ? m.q2.h : na, "m90 QR q2.h", display=display.data_window)
plot(showStep2M90 ? m.q2.l : na, "m90 QR q2.l", display=display.data_window)
plot(showStep2M90 ? m.q2.c : na, "m90 QR q2.c", display=display.data_window)

plot(showStep2M90 ? float(f_hhmm(m.q2.oTs, cfg.tz)) : na, "m90 QR q2.oTs (HHMM)", display=display.data_window)
plot(showStep2M90 ? float(f_hhmm(m.q2.hTs, cfg.tz)) : na, "m90 QR q2.hTs (HHMM)", display=display.data_window)
plot(showStep2M90 ? float(f_hhmm(m.q2.lTs, cfg.tz)) : na, "m90 QR q2.lTs (HHMM)", display=display.data_window)
plot(showStep2M90 ? float(f_hhmm(m.q2.cTs, cfg.tz)) : na, "m90 QR q2.cTs (HHMM)", display=display.data_window)

plot(showStep2M90 ? (m.q2.isEmpty ? 1 : 0) : na, "m90 QR q2.isEmpty", display=display.data_window)
plot(showStep2M90 ? (m.q2.has ? 1 : 0) : na, "m90 QR q2.has", display=display.data_window)
plot(showStep2M90 ? (m.q2.isFinal ? 1 : 0) : na, "m90 QR q2.isFinal", display=display.data_window)
plot(showStep2M90 ? (m.q2.evtStart ? 1 : 0) : na, "m90 QR q2.evtStart", display=display.data_window)
plot(showStep2M90 ? (m.q2.evtFinalize ? 1 : 0) : na, "m90 QR q2.evtFinalize", display=display.data_window)

// Composite pulses (handy sanity)
plot(showStep2M90 ? (m.anyStart ? 1 : 0) : na, "m90 anyStart", display=display.data_window)
plot(showStep2M90 ? (m.anyFinalize ? 1 : 0) : na, "m90 anyFinalize", display=display.data_window)
