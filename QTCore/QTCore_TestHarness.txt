//@version=6
indicator("QT Core â€” Test Harness (m90 Visual, Old QT Exact)", overlay=true, max_lines_count=500, max_labels_count=500)

// NOTE:
// - This harness is intentionally focused on m90 View A visuals.
// - Divider + open-line visuals are ported from your Old QT Indicator's fixed-cycle runner.
// - QTCore is used to supply the active cycle start (and to keep the engine in-scope as you build it).

// Paste your own library import line here:
import Jaw1312/QTCore/4 as qt

// ============================================================================
// CONSTANTS (matching Old QT Indicator)
// ============================================================================
var string TZ = "America/New_York"

var int MS_SEC = 1000
var int MS_MIN = 60 * MS_SEC
var int MS_HR  = 60 * MS_MIN

var int LEN_90M = 90 * MS_MIN
var int LEN_6H  = 6  * MS_HR
var int LEN_24H = 24 * MS_HR

// Quarter colors (fixed)
var color COL_Q1 = color.rgb( 99,  99,  99)   // #636363
var color COL_Q2 = color.rgb(242,  54,  69)   // #f23645
var color COL_Q3 = color.rgb( 76, 175,  80)   // #4caf50
var color COL_Q4 = color.rgb( 41,  98, 255)   // #2962ff

// Vertical opacity: 30% opacity => 70 transparency
var int V_TRANSP = 70
f_vcol(color c) =>
    color.new(c, V_TRANSP)

// Use THIS exactly (your requested mapping)
lineStyleFrom(string s) =>
    switch s
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        =>          line.style_dotted

// ============================================================================
// INPUTS (matching Old QT Indicator defaults for opens/styles)
// ============================================================================
groupCycles = "TIME CYCLES"
useM90      = input.bool(true,  "m90", group=groupCycles)

groupAll        = "CYCLE SETTINGS"
showOpens       = input.bool(true,  "Show Opens", group=groupAll)
keepCycles      = input.int(1,      "# of Cycles", minval=1, maxval=200, group=groupAll)
q1OpenCol       = input.color(color.rgb(255, 152, 0), "Q1 Open Color", group=groupAll)
trueOpenCol     = input.color(color.rgb(0,   0,   0), "Q2 Open Color", group=groupAll)
q1OpenStyleStr   = input.string("Dashed", "Q1 Open Style", options=["Solid","Dashed","Dotted"], group=groupAll)
trueOpenStyleStr = input.string("Dashed", "Q2 Open Style", options=["Solid","Dashed","Dotted"], group=groupAll)

groupDW = "DATA WINDOW (Minimal)"
showDW  = input.bool(true, "Show minimal m90 timestamps", group=groupDW)

// ============================================================================
// HELPERS (subset copied from Old QT Indicator)
// ============================================================================
f_clamp_int(int x, int lo, int hi) =>
    int a = x < lo ? lo : x
    int b = a > hi ? hi : a
    b

crosses_ts(int ts) =>
    bool havePrev = bar_index > 0 and not na(time[1])
    bool overlap  = (time <= ts) and (time_close > ts)
    bool gapCross = havePrev and (time >= ts) and (time[1] < ts)
    overlap or gapCross

// ============================================================================
// OPEN FETCH (m90 uses m1 "containing" policy; implemented with lookahead_off)
// ============================================================================
open_at_ts_m1_containing(int ts) =>
    float out = request.security(
         syminfo.tickerid,
         "1",
         ta.valuewhen(time <= ts and (time + MS_MIN) > ts, open, 0),
         lookahead=barmerge.lookahead_off
    )

    // Last-resort fallbacks (only safe when the boundary equals or is inside THIS bar)
    if na(out) and time == ts
        out := open
    if na(out) and crosses_ts(ts)
        out := open

    out

// ============================================================================
// DRAWING SETS (ported from Old QT Indicator)
// ============================================================================
type vset
    line[] ln
    int[]  ts

vset_new() =>
    vset.new(array.new_line(), array.new_int())

vset_clear(vset s) =>
    int i = s.ln.size() - 1
    while i >= 0
        line.delete(s.ln.get(i))
        i -= 1
    s.ln.clear()
    s.ts.clear()
    0

vset_trim_since(vset s, int cutoff) =>
    int i = s.ts.size() - 1
    while i >= 0
        if s.ts.get(i) < cutoff
            line.delete(s.ln.get(i))
            array.remove(s.ln, i)
            array.remove(s.ts, i)
        i -= 1
    0

vset_has(vset s, int ts) =>
    bool found = false
    int i = s.ts.size() - 1
    while i >= 0 and not found
        found := s.ts.get(i) == ts
        i -= 1
    found

vset_add(vset s, int ts, color c) =>
    if not vset_has(s, ts)
        s.ln.push(line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c)))
        s.ts.push(ts)
    0

type hset
    line[] ln
    int[]  st

hset_new() =>
    hset.new(array.new_line(), array.new_int())

hset_clear(hset s) =>
    int i = s.ln.size() - 1
    while i >= 0
        line.delete(s.ln.get(i))
        i -= 1
    s.ln.clear()
    s.st.clear()
    0

hset_trim_since(hset s, int cutoff) =>
    int i = s.st.size() - 1
    while i >= 0
        if s.st.get(i) < cutoff
            line.delete(s.ln.get(i))
            array.remove(s.ln, i)
            array.remove(s.st, i)
        i -= 1
    0

hset_has(hset s, int st) =>
    bool found = false
    int i = s.st.size() - 1
    while i >= 0 and not found
        found := s.st.get(i) == st
        i -= 1
    found

hset_add(hset s, int st, int et, float y, color c, string styleStr) =>
    if not hset_has(s, st)
        s.ln.push(line.new(st, y, et, y, xloc=xloc.bar_time, extend=extend.none, style=lineStyleFrom(styleStr), width=1, color=c))
        s.st.push(st)
    0

hset_sync(hset s, color c, string styleStr) =>
    int i = s.ln.size() - 1
    while i >= 0
        line ln = s.ln.get(i)
        if not na(ln)
            line.set_color(ln, c)
            line.set_style(ln, lineStyleFrom(styleStr))
            line.set_width(ln, 1)
        i -= 1
    0

// ============================================================================
// PROJECTION HELPERS (ported from Old QT Indicator)
// ============================================================================
f_set_or_make_vline(line ln, int ts, color c) =>
    line out = ln
    if na(out)
        out := line.new(ts, low, ts, high, xloc=xloc.bar_time, extend=extend.both, style=line.style_solid, width=1, color=f_vcol(c))
    else
        line.set_xy1(out, ts, low)
        line.set_xy2(out, ts, high)
        line.set_color(out, f_vcol(c))
        line.set_style(out, line.style_solid)
        line.set_width(out, 1)
    out

f_kill(line ln) =>
    if not na(ln)
        line.delete(ln)
    line(na)

// ============================================================================
// FIXED-CYCLE RUNNER (ported from Old QT Indicator; m90 parameterization)
// ============================================================================
f_push_unique_int(int[] a, int v, int maxSize) =>
    if array.size(a) == 0 or array.get(a, array.size(a) - 1) != v
        array.push(a, v)
        if array.size(a) > maxSize
            array.shift(a)
    0

run_fixed_cycle(
    int curStart,
    int parentLenMs,
    int quarterLenMs,
    bool snapQuarters,
    int alignMs,
    int keepEff,
    int storeMax,
    int[] starts,
    vset v,
    hset hQ1,
    hset hQ2,
    line projQ2,
    line projQ3,
    line projQ4,
    line projEnd
) =>
    // Record current printed cycle start (one entry per printed cycle)
    f_push_unique_int(starts, curStart, storeMax)

    int nAvail = array.size(starts)
    int nUse   = math.min(keepEff, nAvail)
    int first  = nAvail - nUse

    int cutoff = curStart
    if nUse > 0
        cutoff := array.get(starts, first)

    // Trim drawings to cutoff window
    vset_trim_since(v, cutoff)
    if showOpens
        hset_trim_since(hQ1, cutoff)
        hset_trim_since(hQ2, cutoff)

    // Realized dividers + opens across the kept printed cycles
    int i = first
    while i < nAvail
        int bStart = array.get(starts, i)
        int bEnd   = bStart + parentLenMs

        int q1 = bStart
        int q2 = snapQuarters ? (bStart + 1 * quarterLenMs + (alignMs > 0 ? (alignMs - ((bStart + 1 * quarterLenMs) % alignMs)) % alignMs : 0)) : (bStart + 1 * quarterLenMs)
        int q3 = snapQuarters ? (bStart + 2 * quarterLenMs + (alignMs > 0 ? (alignMs - ((bStart + 2 * quarterLenMs) % alignMs)) % alignMs : 0)) : (bStart + 2 * quarterLenMs)
        int q4 = snapQuarters ? (bStart + 3 * quarterLenMs + (alignMs > 0 ? (alignMs - ((bStart + 3 * quarterLenMs) % alignMs)) % alignMs : 0)) : (bStart + 3 * quarterLenMs)

        if time_close > q1
            vset_add(v, q1, COL_Q1)
        if time_close > q2
            vset_add(v, q2, COL_Q2)
        if time_close > q3
            vset_add(v, q3, COL_Q3)
        if time_close > q4
            vset_add(v, q4, COL_Q4)

        if showOpens
            if time_close > q1
                float p1 = open_at_ts_m1_containing(q1)
                if not na(p1)
                    hset_add(hQ1, q1, bEnd, p1, q1OpenCol, q1OpenStyleStr)

            if time_close > q2
                float p2 = open_at_ts_m1_containing(q2)
                if not na(p2)
                    hset_add(hQ2, q2, bEnd, p2, trueOpenCol, trueOpenStyleStr)

        i += 1

    if showOpens
        hset_sync(hQ1, q1OpenCol, q1OpenStyleStr)
        hset_sync(hQ2, trueOpenCol, trueOpenStyleStr)

    // Projections for the currently-active printed cycle.
    int curEnd = curStart + parentLenMs
    int curQ2  = snapQuarters ? (curStart + 1 * quarterLenMs + (alignMs > 0 ? (alignMs - ((curStart + 1 * quarterLenMs) % alignMs)) % alignMs : 0)) : (curStart + 1 * quarterLenMs)
    int curQ3  = snapQuarters ? (curStart + 2 * quarterLenMs + (alignMs > 0 ? (alignMs - ((curStart + 2 * quarterLenMs) % alignMs)) % alignMs : 0)) : (curStart + 2 * quarterLenMs)
    int curQ4  = snapQuarters ? (curStart + 3 * quarterLenMs + (alignMs > 0 ? (alignMs - ((curStart + 3 * quarterLenMs) % alignMs)) % alignMs : 0)) : (curStart + 3 * quarterLenMs)

    line q2L = projQ2
    line q3L = projQ3
    line q4L = projQ4
    line eL  = projEnd

    if time_close > curQ2
        q2L := f_kill(q2L)
    else
        q2L := f_set_or_make_vline(q2L, curQ2, COL_Q2)

    if time_close > curQ3
        q3L := f_kill(q3L)
    else
        q3L := f_set_or_make_vline(q3L, curQ3, COL_Q3)

    if time_close > curQ4
        q4L := f_kill(q4L)
    else
        q4L := f_set_or_make_vline(q4L, curQ4, COL_Q4)

    if time_close > curEnd
        eL := f_kill(eL)
    else
        eL := f_set_or_make_vline(eL, curEnd, COL_Q1)

    line[] out = array.new_line()
    array.push(out, q2L)
    array.push(out, q3L)
    array.push(out, q4L)
    array.push(out, eL)
    out

// ============================================================================
// QTCORE STATE + m90 VIEW A
// ============================================================================
var qt.QTConfig   cfg = qt.qt_config_default()
var qt.CycleState st  = qt.qt_state_new()

int t      = time
int tClose = time_close

[st2, m] = qt.qt_m90_update(st, cfg, t, tClose)
st := st2

// Exact gating from Old QT Indicator: m90 visible on m5 only
bool m90Live = useM90 and timeframe.isminutes and timeframe.multiplier == 5

// m90 drawings (matching Old QT Indicator)
var vset m90V    = vset_new()
var hset m90HQ1  = hset_new()
var hset m90HTru = hset_new()

var line m90ProjQ2  = na
var line m90ProjQ3  = na
var line m90ProjQ4  = na
var line m90ProjEnd = na

var int[] m90Starts = array.new_int()
var int   M90_STORE_MAX = 600

int m90KeepEff = keepCycles
m90KeepEff := showOpens ? f_clamp_int(m90KeepEff, 1, 70) : f_clamp_int(m90KeepEff, 1, 110)

if not m90Live or na(m.startTs)
    if m90V.ln.size() > 0
        vset_clear(m90V)
    if m90HQ1.ln.size() > 0
        hset_clear(m90HQ1)
    if m90HTru.ln.size() > 0
        hset_clear(m90HTru)

    m90ProjQ2  := f_kill(m90ProjQ2)
    m90ProjQ3  := f_kill(m90ProjQ3)
    m90ProjQ4  := f_kill(m90ProjQ4)
    m90ProjEnd := f_kill(m90ProjEnd)

    // Also clear start history so re-enabling doesn't backfill unexpectedly
    if array.size(m90Starts) > 0
        array.clear(m90Starts)
else
    int curSt = m.startTs

    line[] projs = run_fixed_cycle(
        curSt,
        LEN_6H,
        LEN_90M,
        false,
        0,
        m90KeepEff,
        M90_STORE_MAX,
        m90Starts,
        m90V,
        m90HQ1,
        m90HTru,
        m90ProjQ2,
        m90ProjQ3,
        m90ProjQ4,
        m90ProjEnd
    )

    m90ProjQ2  := array.get(projs, 0)
    m90ProjQ3  := array.get(projs, 1)
    m90ProjQ4  := array.get(projs, 2)
    m90ProjEnd := array.get(projs, 3)

// ============================================================================
// MINIMAL DATA WINDOW OUTPUT (optional)
// ============================================================================
int m90_q1 = m.q1Ts
int m90_q2 = m.q2Ts
int m90_q3 = m.q3Ts
int m90_q4 = m.q4Ts

plot(showDW ? float(m90_q1) : na, title="m90 q1Ts", display=display.data_window)
plot(showDW ? float(m90_q2) : na, title="m90 q2Ts", display=display.data_window)
plot(showDW ? float(m90_q3) : na, title="m90 q3Ts", display=display.data_window)
plot(showDW ? float(m90_q4) : na, title="m90 q4Ts", display=display.data_window)

plot(showDW ? (m.q2Realized ? 1.0 : 0.0) : na, title="m90 q2Realized", display=display.data_window)
plot(showDW ? (m.q3Realized ? 1.0 : 0.0) : na, title="m90 q3Realized", display=display.data_window)
plot(showDW ? (m.q4Realized ? 1.0 : 0.0) : na, title="m90 q4Realized", display=display.data_window)
